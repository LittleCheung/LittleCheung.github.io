<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElasticSearch搜索引擎基本使用</title>
    <url>/2021/10/05/ElasticSearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-JavaAPI操作ElasticSearch"><a href="#1-JavaAPI操作ElasticSearch" class="headerlink" title="1. JavaAPI操作ElasticSearch"></a>1. JavaAPI操作ElasticSearch</h2><h3 id="0-Maven先引入依赖"><a href="#0-Maven先引入依赖" class="headerlink" title="0. Maven先引入依赖"></a>0. Maven先引入依赖</h3><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticSearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticSearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticSearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticSearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-创建ElasticSearch客户端"><a href="#1-创建ElasticSearch客户端" class="headerlink" title="1. 创建ElasticSearch客户端"></a>1. 创建ElasticSearch客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ES客户端</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">esClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">	RestClient.builder( <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">esClient.close();</span><br></pre></td></tr></table></figure>

<h3 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2. 创建索引"></a>2. 创建索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;自定义索引名&quot;</span>);</span><br><span class="line"><span class="type">CreateIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.indices().create(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="3-查询和删除索引"><a href="#3-查询和删除索引" class="headerlink" title="3. 查询和删除索引"></a>3. 查询和删除索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询索引</span></span><br><span class="line"><span class="type">GetIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.indices().get(<span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;自定义索引名&quot;</span>), RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除索引</span></span><br><span class="line"><span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.indices().delete(<span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;自定义索引名&quot;</span>), RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="4-新增和修改文档（即插入和修改数据）"><a href="#4-新增和修改文档（即插入和修改数据）" class="headerlink" title="4. 新增和修改文档（即插入和修改数据）"></a>4. 新增和修改文档（即插入和修改数据）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>();</span><br><span class="line">request.index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>)；</span><br><span class="line">  </span><br><span class="line"><span class="comment">//先创建实体类对象，set设置数据</span></span><br><span class="line"><span class="comment">//向ES插入数据，必须将数据转换为JSON格式</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">xxxJson</span> <span class="operator">=</span> mapper.writeValueAsString(实体类对象);</span><br><span class="line">request.source(xxxJson, XContentType.JSON);</span><br><span class="line">    </span><br><span class="line"><span class="type">IndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.index(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line"><span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>();</span><br><span class="line">request.index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>);</span><br><span class="line">request.doc(XContentType.JSON, <span class="string">&quot;字段名&quot;</span>, <span class="string">&quot;字段值&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UpdateResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.update(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="5-查询和删除文档"><a href="#5-查询和删除文档" class="headerlink" title="5. 查询和删除文档"></a>5. 查询和删除文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询数据</span></span><br><span class="line"><span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>();</span><br><span class="line">request.index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>);</span><br><span class="line"><span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.get(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"><span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>();</span><br><span class="line">request.index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>);</span><br><span class="line"><span class="type">DeleteResponse</span> <span class="variable">response</span> <span class="operator">=</span> </span><br><span class="line">    esClient.delete(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="6-批量插入和删除数据"><a href="#6-批量插入和删除数据" class="headerlink" title="6. 批量插入和删除数据"></a>6. 批量插入和删除数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量插入数据</span></span><br><span class="line"><span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">request.add(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">IndexRequest</span>().index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>).source(XContentType.JSON, <span class="string">&quot;字段名&quot;</span>, <span class="string">&quot;字段值1&quot;</span>)</span><br><span class="line">);</span><br><span class="line">request.add(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">IndexRequest</span>().index(<span class="string">&quot;指定索引名&quot;</span>).id(<span class="string">&quot;主键id&quot;</span>).source(XContentType.JSON, <span class="string">&quot;字段名&quot;</span>, <span class="string">&quot;字段值2&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//将多个请求包装起来一起发送</span></span><br><span class="line"><span class="type">BulkResponse</span> <span class="variable">response</span> <span class="operator">=</span> esClient.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除数据同理，只是使用deleteRequest</span></span><br></pre></td></tr></table></figure>

<h3 id="7-全量查询"><a href="#7-全量查询" class="headerlink" title="7. 全量查询"></a>7. 全量查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	查询操作前必须要写的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>();</span><br><span class="line">request.indices(<span class="string">&quot;指定索引名&quot;</span>)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询索引中全部的数据</span></span><br><span class="line"><span class="comment">//构建查询对象和查询全部查询的条件</span></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(QueryBuilders.matchAllQuery()));</span><br><span class="line">    </span><br><span class="line"><span class="type">SearchResponse</span> <span class="variable">rseponse</span> <span class="operator">=</span> </span><br><span class="line">    esClient.search(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="8-条件查询"><a href="#8-条件查询" class="headerlink" title="8. 条件查询"></a>8. 条件查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建查询对象和查询条件查询的条件</span></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(QueryBuilders.termQuery(<span class="string">&quot;字段名&quot;</span>, <span class="string">&quot;字段值&quot;</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建查询对象和查询分页查询的条件</span></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(QueryBuilders.matchAllQuery())</span><br><span class="line">               .from(<span class="string">&quot;起始位置&quot;</span>).size(<span class="string">&quot;每次显示页数&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建查询对象和查询条件，并规定对查询结果的排序规则，同时对字段进行过滤</span></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(QueryBuilders.matchAllQuery())</span><br><span class="line">               .sort(<span class="string">&quot;排序字段&quot;</span>, SortOrder.ASC)</span><br><span class="line">               .fetchSource(<span class="string">&quot;包含字段&quot;</span>, <span class="string">&quot;排除字段&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="9-组合查询和范围查询"><a href="#9-组合查询和范围查询" class="headerlink" title="9. 组合查询和范围查询"></a>9. 组合查询和范围查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建组合查询条件</span></span><br><span class="line"><span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">boolQueryBuilder.should(QueryBuilders.matchQuery(<span class="string">&quot;字段名1&quot;</span>, <span class="string">&quot;字段值&quot;</span>));</span><br><span class="line">boolQueryBuilder.should(QueryBuilders.matchQuery(<span class="string">&quot;字段名2&quot;</span>, <span class="string">&quot;字段值&quot;</span>));</span><br><span class="line"></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(boolQueryBuilder));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建范围查询条件</span></span><br><span class="line"><span class="type">RangeQueryBuilder</span> <span class="variable">rangeQueryBuilder</span> <span class="operator">=</span> QueryBuilders.rangeQuery(<span class="string">&quot;字段名&quot;</span>);</span><br><span class="line"><span class="comment">//取大于等于字段值1，小于等于字段值2范围内的值</span></span><br><span class="line">rangeQueryBuilder.gte(<span class="string">&quot;字段值1&quot;</span>)；</span><br><span class="line">rangeQueryBuilder.lte(<span class="string">&quot;字段值2&quot;</span>);</span><br><span class="line"></span><br><span class="line">request.source(<span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>().query(rangeQueryBuilder));</span><br></pre></td></tr></table></figure>

<h3 id="10-模糊查询"><a href="#10-模糊查询" class="headerlink" title="10. 模糊查询"></a>10. 模糊查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询到与参考字段值相差一个字符以内的数据</span></span><br><span class="line">builder.query(QueryBuilders.fuzzyQuery(<span class="string">&quot;字段名&quot;</span>, <span class="string">&quot;参考字段值&quot;</span>).fuzziness(Fuzziness.ONE));</span><br><span class="line"></span><br><span class="line">request.source(builder);</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Java web开发中的各种层作用理解</title>
    <url>/2020/09/03/Java%20web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B1%82%E5%8F%8A%E5%90%84%E8%87%AA%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般的项目模块中都有Dao层、Entity层、Service层、Controller层和View层，今天来分享一下个人对各层作用的理解；</p>
<span id="more"></span>

<h3 id="1、Dao层（持久层、数据访问层、Mapper层）"><a href="#1、Dao层（持久层、数据访问层、Mapper层）" class="headerlink" title="1、Dao层（持久层、数据访问层、Mapper层）"></a>1、Dao层（持久层、数据访问层、Mapper层）</h3><p><strong>功能</strong>：访问数据库，向数据库发送sql语句，完成数据的增删改查任务，实现数据的持久化，使用@Repository和@Mapper注解都可用于标注数据访问组件Dao层；</p>
<p>​        两个注解的区别：</p>
<ul>
<li>@Mapper注解是MyBatis的注解，用来说明这个是一个Mapper，对应的xxxMapper.xml就是来实现这个Mapper，在Sevice层使用@Autowired注解引用Dao层会报红但是不影响使用，这是因为@Autowired是Spring的注解，会提示找不到相应的bean，这里可以用JDK的注解@Resource替代@Autowired；</li>
<li>@Repository注解是Spring的注解，用来把当前类注册成一个bean，在Service层通常使用@Autowired注解引用Dao层，但需要在主要启动类配置@MapperScan注解；</li>
</ul>
<p><strong>使用流程</strong>：Dao层先要设计Dao接口，然后在配置文件中定义该接口的实现类，接着就可以在Service层调用Dao层的接口进行业务处理；</p>
<p><strong>个人理解</strong>：Dao层只是定义方法接口，然后在Service层的xxxServiceImpl实现类调用接口的方法，从而达到操作数据库的目的。Dao层对数据库进行数据持久化操作，方法语句主要是针对数据库实现的一些增删改查操作，在Mapper中的方法与xxxMapper.xml一一映射。</p>
<h3 id="2、Service层（业务逻辑层）"><a href="#2、Service层（业务逻辑层）" class="headerlink" title="2、Service层（业务逻辑层）"></a>2、Service层（业务逻辑层）</h3><p><strong>功能</strong>：用于实现操作的具体方法，包含了对页面操作模块的代码；</p>
<p><strong>个人理解</strong>：Service用于存放业务逻辑处理，不直接和数据库打交道，Service层是建立在DAO层之上的，同时又是在Controller层之下的，因而Service层应该既调用DAO层的接口进行实现，又要提供封装后的接口给Controller层的类来进行调用，它刚好处于一个中间层的位置，不仅有面向Controller层的接口也有对Dao层接口的实现方法，Dao层接口的实现方法在xxxServiceImpl文件中，标注@Service注解，把mapper和service进行整合封装Service层的业务逻辑；</p>
<h3 id="3、Controller层（表现层、控制层）"><a href="#3、Controller层（表现层、控制层）" class="headerlink" title="3、Controller层（表现层、控制层）"></a>3、Controller层（表现层、控制层）</h3><p><strong>功能</strong>：控制业务逻辑，负责具体业务模块流程的控制；</p>
<p><strong>个人理解</strong>：Controller层负责请求转发，接收页面过来的参数后传给Service层处理，接到返回值后再返回给页面。Controller层一般会和前端以json文件进行数据的交互， Controller层是前台数据的接收器，后台处理好的数据也是通过Controller层传递到前台进行显示的；xxxController上标注@RestController注解，具体方法上标注@RequestMapping注解或具体的@xxxMapping（Get、Post…）注解</p>
<h3 id="4、View层（视图层）"><a href="#4、View层（视图层）" class="headerlink" title="4、View层（视图层）"></a>4、View层（视图层）</h3><p><strong>功能</strong>：此层与Controller层联系紧密，需要协同开发。View层主要负责前台页面的展示</p>
<h3 id="5、Model层（Entity层、实体层）"><a href="#5、Model层（Entity层、实体层）" class="headerlink" title="5、Model层（Entity层、实体层）"></a>5、Model层（Entity层、实体层）</h3><p><strong>功能</strong>：与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供getter/setter方法，tostring方法，有参和无参构造器；</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象术语(PO/POJO/VO/BO/DAO/DTO)总结</title>
    <url>/2020/02/12/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚开始学习Java Web时接触到DAO和POJO还经常搞混，后来上网查才发现还不只有这两种对象，每一层的Java Bean有不同的称呼，于是试着结合网上的资料和一些个人的理解对Java中常用的一些对象进行总结。</p>
<span id="more"></span>

<h2 id="1-PO-persistant-object-持久化对象"><a href="#1-PO-persistant-object-持久化对象" class="headerlink" title="1. PO(persistant object) : 持久化对象"></a><strong>1. PO(persistant object) : 持久化对象</strong></h2><ol>
<li><p>可理解为DAO层中接收和返回的Java Bean，与数据库的数据结构形成一一对应的映射关系。</p>
</li>
<li><p>是数据库表中的记录在Java对象中的显示状态，一个PO对应一张数据库表，数据库表中的每个字段就对应PO的一个属性。</p>
</li>
</ol>
<h2 id="2-VO-value-object-值对象-view-object表现层对象"><a href="#2-VO-value-object-值对象-view-object表现层对象" class="headerlink" title="2. VO(value object) : 值对象 / view object表现层对象"></a><strong>2. VO(value object) : 值对象 / view object表现层对象</strong></h2><ol>
<li><p>可理解为View层中用于显示的Java Bean</p>
</li>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不和表对应（大部分情况是表所有字段集合的子集）。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的Web Service传输中，而VO用于界面的展示，也可以把DTO转化为VO提供给前台。</p>
</li>
</ol>
<h2 id="3-BO-business-object-业务对象"><a href="#3-BO-business-object-业务对象" class="headerlink" title="3. BO(business object) : 业务对象"></a><strong>3. BO(business object) : 业务对象</strong></h2><ol>
<li><p>可理解为Service层中接收和返回的Java Bean。</p>
</li>
<li><p>从业务模型的角度看，是封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从数据库中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ol>
<h2 id="4-POJO-plain-ordinary-java-object-简单无规则java对象"><a href="#4-POJO-plain-ordinary-java-object-简单无规则java对象" class="headerlink" title="4. POJO(plain ordinary java object) : 简单无规则java对象"></a><strong>4. POJO(plain ordinary java object) : 简单无规则java对象</strong></h2><ol>
<li><p>理解为各个层中接收和返回的Java Bean统称，实际上就是普通的Java Bean，POJO类中有属性和getter、setter方法，但是没有业务逻辑，可以作为支持业务逻辑的协助类。</p>
</li>
<li><p>是一个抽象的统一概念，可以当作简单的Java对象，也可以如下转化为PO、DTO、VO（或者说PO、DTO、VO是POJO的不同的具体阶段的名字）。</p>
</li>
<li><p>POJO持久化之后==〉PO</p>
</li>
<li><p>POJO传输过程中==〉DTO</p>
</li>
<li><p>POJO用作表示层==〉VO</p>
</li>
</ol>
<h2 id="5-DAO-data-access-object-数据访问对象"><a href="#5-DAO-data-access-object-数据访问对象" class="headerlink" title="5. DAO(data access object) : 数据访问对象"></a><strong>5. DAO(data access object) : 数据访问对象</strong></h2><ol>
<li><p>DAO负责将PO持久化到数据库，也负责将数据库查询的结果集映射为PO。</p>
</li>
<li><p>为业务层提供接口，此对象用于访问数据库（CRUD操作），通常和PO结合使用；DAO中包含了各种数据库的操作方法，通过它的方法，结合PO对数据库进行相关的操作，夹在业务逻辑与数据库资源中间，配合VO,，提供数据库的CRUD操作。</p>
</li>
</ol>
<h2 id="6-DTO-Data-Transfer-Object-数据传输对象"><a href="#6-DTO-Data-Transfer-Object-数据传输对象" class="headerlink" title="6. DTO (Data Transfer Object) : 数据传输对象"></a><strong>6. DTO (Data Transfer Object) : 数据传输对象</strong></h2><ol>
<li>可理解为Controller层中接收和返回的Java Bean</li>
<li>用于在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>举一个例子：比如一张表有100个字段，那么对应的PO就有100个属性，但View层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面进行显示，那此时它的身份就转为VO。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的IO流学习笔记</title>
    <url>/2020/03/04/Java%E7%9A%84IO%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习Java的IO流知识时所记录的笔记，涉及IO流的基础知识；</p>
<span id="more"></span>

<h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h2><h3 id="1-1-File类基本概念"><a href="#1-1-File类基本概念" class="headerlink" title="1.1 File类基本概念"></a>1.1 File类基本概念</h3><ol>
<li>File类的一个对象，代表一个文件或一个文件目录；</li>
<li>File类声明在java.io包下；</li>
<li>创建实例的三种方式：<ul>
<li>File(String filePath)<br>①相对路径：相较于某个路径下指明的路径<br>②绝对路径：包含盘符在内的文件或文件目录的路径</li>
<li>File(String parentPath, String childPath)</li>
<li>File(File parentPath, String childPath)</li>
</ul>
</li>
<li>File类的对象常会作为参数传递到流的构造器中，指明读取或写入的终点；</li>
</ol>
<p><strong>注意：</strong>涉及读取或写入文件内容必须使用IO流来完成；</p>
<h3 id="1-2-File类常用方法"><a href="#1-2-File类常用方法" class="headerlink" title="1.2 File类常用方法"></a>1.2 File类常用方法</h3><p><strong>获取功能：</strong></p>
<ol>
<li><code>String getAbsolutePath()</code>：获取绝对路径</li>
<li><code>String getPath()</code>：获取路径</li>
<li><code>String getName()</code>：获取名称</li>
<li><code>String getParent()</code>：获取上层文件目录路径，若没有就返回null</li>
<li><code>Long length()</code>：获取文件长度，不能获取目录的长度</li>
<li><code>Long lastModified()</code>：获取最后一次的修改时间(ms)</li>
<li><code>String[] list()</code>：获取指定目录下的所有文件或文件目录的名称数组</li>
<li><code>File[] listFiles()</code>：获取指定目录下的所有文件或文件目录的File数组</li>
</ol>
<p><strong>重命名功能：</strong></p>
<ol start="9">
<li><p><code>boolean renameTo(File dest)</code>：把文件重命名为指定的文件路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> file1.renameTo(file2)</span><br><span class="line"><span class="comment">// 注意：要想返回true，需要file1在硬盘中必须存在，且file2不能在硬盘中存在；</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>判断功能：</strong></p>
<ol start="10">
<li><code>boolean isDirectory()</code>：判断是否是文件目录</li>
<li><code>boolean isFile()</code>：判断是否是文件</li>
<li><code>boolean exists()</code>：判断是否存在</li>
<li><code>boolean canRead()</code>：判断是否可读</li>
<li><code>boolean canWrite()</code>：判断是否可写</li>
<li><code>boolean isHidden()</code>：判断是否隐藏</li>
</ol>
<p><strong>创建和删除功能：</strong></p>
<ol start="16">
<li><code>boolean createNewFile()</code>：创建文件，若文件已存在返回false</li>
<li><code>boolean mkdir()</code>：创建文件目录，上层目录不存在就不创建</li>
<li><code>boolean mkdirs()</code>：创建文件目录，上层目录不存在就一并创建</li>
<li><code>boolean delete()</code>：删除文件或文件夹</li>
</ol>
<h2 id="2-节点流（文件流）"><a href="#2-节点流（文件流）" class="headerlink" title="2. 节点流（文件流）"></a>2. 节点流（文件流）</h2><p><strong>注意：</strong>字符流不能用来处理图片等字节数据，处理字节数据要用字节流；</p>
<p><strong>总结：</strong>字节流和字符流的读写操作基本步骤一致，都是分为4步；</p>
<h3 id="2-1-字节流"><a href="#2-1-字节流" class="headerlink" title="2.1 字节流"></a>2.1 字节流</h3><h4 id="2-1-1-字节输入流：FileInputStream"><a href="#2-1-1-字节输入流：FileInputStream" class="headerlink" title="2.1.1 字节输入流：FileInputStream"></a>2.1.1 字节输入流：FileInputStream</h4><p><strong>FileInputStream读取非文本文件基本操作：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明要操作的文件：</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>FileInputStream流的实例化，提供具体的流：</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入操作</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; <span class="comment">// 记录每次读取的字节的个数 </span></span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">	System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流的关闭操作</span><br><span class="line"><span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">	fis.close( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="number">1.</span>对于文本文件(.txt, .java, .c, .cpp等)建议使用字符流处理，字节流处理可能出现乱码；</span><br><span class="line"><span class="number">2.</span>对于非文本文件(图片、视频等)必须使用字节流处理；</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-字节输出流：FileOutputStream"><a href="#2-1-2-字节输出流：FileOutputStream" class="headerlink" title="2.1.2 字节输出流：FileOutputStream"></a>2.1.2 字节输出流：FileOutputStream</h4><p><strong>使用FileInputStream和FileOutputStream实现非文本文件的复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件： </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象：</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);  </span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 （复制过程）</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>];</span><br><span class="line"><span class="comment">// 记录每次读入到buffer数组中的字符的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.read(buffer); </span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//每次写出len个字符，从0开始</span></span><br><span class="line">	fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;  </span><br><span class="line">	fis.close( ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;  </span><br><span class="line">	fos.close( ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-字符流"><a href="#2-2-字符流" class="headerlink" title="2.2 字符流"></a>2.2 字符流</h3><h4 id="2-2-1-字符输入流：FileReader"><a href="#2-2-1-字符输入流：FileReader" class="headerlink" title="2.2.1 字符输入流：FileReader"></a>2.2.1 字符输入流：FileReader</h4><p><strong>FileReader读入数据基本操作步骤：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明要操作的文件：</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"><span class="comment">//相对地址相较于当前Module</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Filereader流的实例化，提供具体的流：</span><br><span class="line">fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="comment">//读入的文件一定要存在，否则就会报FileNotFoundException</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入操作</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fr.read( );</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.println((<span class="type">char</span>)data);</span><br><span class="line">	data = fr.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//read( )：返回读入的一个字符，如果到达文件末尾返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流的关闭操作</span><br><span class="line"><span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">	fr.close( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理，把close()放在finally块中</span></span><br></pre></td></tr></table></figure>

<p>使用read的重载方法<code>read(char[ ] cbuf)</code>进行读入操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fr.read(cbuf);</span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 方式一：遍历char[]数组,注意此处i&lt;len不可以写成 i&lt;cbuf.length</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">		System.out.print(cbuf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：将char[]数组转换为str再遍历字符串,注意不可以只写cbuf，要指定范围</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">	System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read(char[ ] cbuf)：返回每次读入cbuf数组中字符的个数，如果到达文件末尾返回-1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-字符输出流：FileWriter"><a href="#2-2-2-字符输出流：FileWriter" class="headerlink" title="2.2.2 字符输出流：FileWriter"></a>2.2.2 字符输出流：FileWriter</h4><p><strong>FileWriter写出数据基本操作步骤：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明写出到的文件： </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>； </span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>FileWriter流的实例化，用于数据写出： </span><br><span class="line">fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的写出操作 </span><br><span class="line">fw.write(<span class="string">&quot;String&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123; </span><br><span class="line">	fw.close( ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="number">1.</span>输出操作，对应的File如果不存在，在输出的过程中会自动创建此文件；</span><br><span class="line"><span class="number">2.</span>对应的File如果存在，根据构造器不同:</span><br><span class="line">	<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file)会对原有文件进行覆盖</span><br><span class="line">	<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>)不会对原有文件进行覆盖，而是在原有文件基础上追加内容</span><br></pre></td></tr></table></figure>

<p><strong>使用FileReader和FileWriter实现文本文件的复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件： </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象：</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);  </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 （复制过程）</span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>];</span><br><span class="line"><span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fr.read(cbuf); </span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//每次写出len个字符，从0开始</span></span><br><span class="line">	fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123; </span><br><span class="line">	fr.close( ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123; </span><br><span class="line">	fw.close( ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-处理流"><a href="#3-处理流" class="headerlink" title="3. 处理流"></a>3. 处理流</h2><h3 id="3-1-缓冲流"><a href="#3-1-缓冲流" class="headerlink" title="3.1 缓冲流"></a>3.1 缓冲流</h3><p><strong>作用：</strong>内部提供了一个缓冲区，提高流的读取和写入的速度；(因此缓冲流读写速度快于文件流)</p>
<h4 id="3-1-1-字节型"><a href="#3-1-1-字节型" class="headerlink" title="3.1.1 字节型"></a>3.1.1 字节型</h4><p>作用在InputStream上：BufferedInputStream</p>
<p>作用在OutputStream上：BufferedOutputStream</p>
<p><strong>使用BufferedInputStream和BufferedOutputStream实现非文本文件复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件:（造文件）</span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象:（造流）</span><br><span class="line"><span class="comment">// 先造内层的节点流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile); </span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(destFile); </span><br><span class="line"><span class="comment">// 再造外层的缓冲流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 ：（复制过程） </span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line"> 	bos.write(buffer, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="comment">// 要求：先关闭外层的流，再关闭内层的流（即造流先内后外，关流先外后内）</span></span><br><span class="line">bos.close( ); </span><br><span class="line">bis.close( ); </span><br><span class="line"><span class="comment">// 说明：关闭外层流的同时，内层流也会自动地进行关闭，关于内层流的关闭操作其实可以省略</span></span><br><span class="line">fos.close( ); </span><br><span class="line">fis.close( ); </span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-字符型"><a href="#3-1-2-字符型" class="headerlink" title="3.1.2 字符型"></a>3.1.2 字符型</h4><p>作用在FileReader上：BufferedReader</p>
<p>作用在FileWriter上：BufferedWriter</p>
<p><strong>使用BufferedReader和BufferedWriter实现文本文件复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件:（造文件） </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象:（造流） </span><br><span class="line"><span class="comment">// 先造内层的节点流 </span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile); </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile); </span><br><span class="line"><span class="comment">// 再造外层的缓冲流 </span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr); </span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 ：（复制过程） </span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = br.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	bw.write(cbuf, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作</span><br><span class="line"><span class="comment">// 内层文件流会在外层缓冲流关闭时自动关闭，因此可以省略文件流的关闭步骤</span></span><br><span class="line">br.close( ); </span><br><span class="line">bw.close( ); </span><br></pre></td></tr></table></figure>

<h3 id="3-2-转换流"><a href="#3-2-转换流" class="headerlink" title="3.2 转换流"></a>3.2 转换流</h3><p><strong>作用：</strong>提供了在字节流和字符流之间的转换，本身属于字符流；</p>
<p>将一个字节的输入流转换为字符的输入流（解码）：InputStreamReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 造文件、造流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String filepath)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数2指明字符集，具体使用哪个字符集取决于文件保存时使用的字符集 </span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure>

<p>将一个字符的输出流转换为字节的输出流（编码）：OutputStreamWriter</p>
<p><strong>切换字符集实现文件读入与写出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String path));</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String path));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStream -&gt; Reader(字节流转换为字符流)</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="comment">// Writer -&gt; OutputStream(字符流转换为字节流)</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">isr.close();</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure>

<h3 id="3-3-对象流"><a href="#3-3-对象流" class="headerlink" title="3.3 对象流"></a>3.3 对象流</h3><p><strong>作用：</strong>用于存储和读取基本数据类型数据或对象的处理流，可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来；</p>
<p><strong>对象序列化机制：</strong>允许把内存中任何实现了Serializable接口的对象转换成与平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象；</p>
<p><strong>ObjectOutputStream序列化：对象写入到数据源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>造文件、造节点流和处理流</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;object.data&quot;</span>)</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file))</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>写出对象</span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a example&quot;</span>));</span><br><span class="line"><span class="comment">//刷新操作</span></span><br><span class="line">oos.flush( ); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源</span><br><span class="line">oos.close( );</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInputStream反序列化：从数据源还原对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化：将磁盘文件中的对象还原为内存中的一个Java对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>造文件、造节点流和处理流 </span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;object.data&quot;</span>) </span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>读取对象   </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) ois.readObject( );</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源 </span><br><span class="line">ois.close( );</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<h3 id="3-4-其他流"><a href="#3-4-其他流" class="headerlink" title="3.4 其他流"></a>3.4 其他流</h3><h4 id="3-4-1-标准输入流、输出流"><a href="#3-4-1-标准输入流、输出流" class="headerlink" title="3.4.1 标准输入流、输出流"></a>3.4.1 标准输入流、输出流</h4><ul>
<li><p>System.in：标准的输入流，默认从键盘输入</p>
</li>
<li><p>System.out：标准的输出流，默认从控制台输出</p>
<p><strong>注意：</strong>可以通过System类的<code>setIn(InputStream is)</code> / <code>setOut(PrintStream ps)</code>方式重新指定输入和输出的流；</p>
</li>
</ul>
<h4 id="3-4-2-打印流"><a href="#3-4-2-打印流" class="headerlink" title="3.4.2 打印流"></a>3.4.2 打印流</h4><p><strong>作用：</strong>将基本数据类型的数据格式转化为字符串输出；</p>
<ul>
<li>字节输出流：PrintStream</li>
<li>字符输出流：PrintWriter</li>
</ul>
<h4 id="3-4-3-数据流"><a href="#3-4-3-数据流" class="headerlink" title="3.4.3 数据流"></a>3.4.3 数据流</h4><p><strong>作用：</strong>用于读取或写出基本数据类型的变量或字符串；</p>
<ul>
<li>DateInputStream：将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中</li>
<li>DateOutputStream：将内存中的字符串、基本数据类型的变量写出到文件中</li>
</ul>
<p><strong>注意：</strong>读取不同类型的数据的顺序要与当初写入文件时保存的数据的顺序一致；</p>
<h4 id="3-4-4-随机存取文件流"><a href="#3-4-4-随机存取文件流" class="headerlink" title="3.4.4 随机存取文件流"></a>3.4.4 随机存取文件流</h4><ul>
<li>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口，既可作为输入流，也可作为输出流；</li>
<li>RandomAccessFile支持随机访问方式，程序可以直接跳到文件的任意地方读、写文件（由于其对象包含一个记录指针用以标示当前读写处的位置），支持只访问文件的部分内容，或者向已存在的文件后追加内容；</li>
<li>如果RandomAccessFile作为输出流时，写出到的文件如果不存在则会在执行过程中自动创建，如果已经存在则会对原有文件内容从头覆盖；</li>
</ul>
<p><strong>RandomAccessFile实现数据的读写操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建两个对象，一个用于写入，一个用于读取</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mode参数指定RandomAccessFile的访问模式：</span></span><br><span class="line"><span class="comment">访问模式有以下4种：</span></span><br><span class="line"><span class="comment">r：以只读方式打开</span></span><br><span class="line"><span class="comment">rw：打开以便读取和写入</span></span><br><span class="line"><span class="comment">rwd：打开以便读取和写入，并同步文件内容的更新</span></span><br><span class="line"><span class="comment">rws：打开以便读取和写入，并同步文件内容和元数据的更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String pathname, mode))</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String pathname, mode))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[ ] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line"> 	raf2.write(buffer, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raf1.close();</span><br><span class="line">raf2.close();</span><br></pre></td></tr></table></figure>

<p><strong>RandomAccessFile实现数据的插入操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法：<span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span>：将文件记录指针定位到角标为pos位置</span><br><span class="line"></span><br><span class="line">如何实现插入新的数据而不会覆盖后面数据的效果?</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将指针调到角标为pos的位置</span></span><br><span class="line">raf.seek(pos); </span><br><span class="line"><span class="comment">//保存指针pos后面的所有数据到StringBuilder中</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>().length);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[ ] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = raf.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调指针到pos，写入要插入到pos后的内容</span></span><br><span class="line">raf.seek(pos); </span><br><span class="line">raf.write(<span class="string">&quot;String&quot;</span>.getBytes())</span><br><span class="line"><span class="comment">//将StringBuilder中保存的数据重新写入到文件中</span></span><br><span class="line">raf.write(builder.toString().getBytes())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习笔记</title>
    <url>/2020/03/08/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人学习Java相关反射时所总结的入门笔记，对反射的理解还不够深入；</p>
<span id="more"></span>



<h2 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1. 问题导入"></a>1. 问题导入</h2><h3 id="1-1-如何看待面向对象的封装性和反射机制？两者是否矛盾？"><a href="#1-1-如何看待面向对象的封装性和反射机制？两者是否矛盾？" class="headerlink" title="1.1 如何看待面向对象的封装性和反射机制？两者是否矛盾？"></a>1.1 如何看待面向对象的封装性和反射机制？两者是否矛盾？</h3><p>答：两者并不矛盾。封装性相当于是建议其他类去调用当前类的公共方法，而私有方法不建议去调用，因为公共的方法可能比私有的方法更好，在公共方法里面可能添加了一些私有方法没有的逻辑。如果非要调用私有的方法，也可以调用，那我们就通过反射的方式去调用。<strong>（总结：封装性解决的是访问权限。即建议调用哪个的问题；反射解决的是调用类的问题 ，即能不能调的问题。）</strong></p>
<h3 id="1-2-开发中到底用直接new还是反射的方式调用公共结构？"><a href="#1-2-开发中到底用直接new还是反射的方式调用公共结构？" class="headerlink" title="1.2 开发中到底用直接new还是反射的方式调用公共结构？"></a>1.2 开发中到底用直接new还是反射的方式调用公共结构？</h3><p><strong>建议：</strong>直接使用new的方式调用公共结构；</p>
<p><strong>什么时候会用反射的方式：</strong>反射的特征是动态性，在编译时无法确定要new哪个类的对象时可以选用反射；</p>
<h2 id="2-反射常用API的使用"><a href="#2-反射常用API的使用" class="headerlink" title="2. 反射常用API的使用"></a>2. 反射常用API的使用</h2><h3 id="2-1-获取反射中的Class实例"><a href="#2-1-获取反射中的Class实例" class="headerlink" title="2.1 获取反射中的Class实例"></a>2.1 获取反射中的Class实例</h3><h4 id="2-1-1-调用Class的静态方法：Class-forname-String-classPath"><a href="#2-1-1-调用Class的静态方法：Class-forname-String-classPath" class="headerlink" title="2.1.1 调用Class的静态方法：Class.forname(String classPath)"></a>2.1.1 调用Class的静态方法：Class.forname(String classPath)</h4><p>当可以知道该类的全路径名时，推荐优先使用使用该方法获取 Class 类对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-调用运行时类的属性：类名-class"><a href="#2-1-2-调用运行时类的属性：类名-class" class="headerlink" title="2.1.2 调用运行时类的属性：类名.class"></a>2.1.2 调用运行时类的属性：类名.class</h4><p>这种方法只适合在编译前就知道操作的 Class;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-通过运行时类的对象：对象名-getClass"><a href="#2-1-3-通过运行时类的对象：对象名-getClass" class="headerlink" title="2.1.3 通过运行时类的对象：对象名.getClass()"></a>2.1.3 通过运行时类的对象：对象名.getClass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-使用类的加载器：ClassLoader"><a href="#2-1-4-使用类的加载器：ClassLoader" class="headerlink" title="2.1.4 使用类的加载器：ClassLoader"></a>2.1.4 使用类的加载器：ClassLoader</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-创建运行时类的对象"><a href="#2-2-创建运行时类的对象" class="headerlink" title="2.2 创建运行时类的对象"></a>2.2 创建运行时类的对象</h3><h4 id="2-2-1-通过-Class类对象的-newInstance-方法"><a href="#2-2-1-通过-Class类对象的-newInstance-方法" class="headerlink" title="2.2.1 通过 Class类对象的 newInstance() 方法"></a>2.2.1 通过 Class类对象的 newInstance() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)clazz.newInstance();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-通过-Constructor构造器对象的-newInstance-方法"><a href="#2-2-2-通过-Constructor构造器对象的-newInstance-方法" class="headerlink" title="2.2.2 通过 Constructor构造器对象的 newInstance() 方法"></a>2.2.2 通过 Constructor构造器对象的 newInstance() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是：</strong>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p>
<h3 id="2-3-获取运行时类的属性、方法、构造器"><a href="#2-3-获取运行时类的属性、方法、构造器" class="headerlink" title="2.3 获取运行时类的属性、方法、构造器"></a>2.3 获取运行时类的属性、方法、构造器</h3><h4 id="2-3-1-获取运行时类的属性"><a href="#2-3-1-获取运行时类的属性" class="headerlink" title="2.3.1 获取运行时类的属性"></a>2.3.1 获取运行时类的属性</h4><ul>
<li><code>getFields()</code>：获取当前运行时类及其父类中声明为public访问权限的属性；</li>
<li><code>getDeclaredFields()</code>：获取当前运行时类中声明的所有属性（不包括父类中声明的属性）；</li>
</ul>
<h4 id="2-3-2-获取运行时类的方法"><a href="#2-3-2-获取运行时类的方法" class="headerlink" title="2.3.2 获取运行时类的方法"></a>2.3.2 获取运行时类的方法</h4><ul>
<li><code>getMethods()</code>：获取当前运行时类及其父类中声明为public访问权限的方法；</li>
<li><code>getDeclaredMethods()</code>：获取当前运行时类中声明的所有方法（不包括父类中声明的属性）；</li>
</ul>
<h4 id="2-3-3-获取运行时类的构造器"><a href="#2-3-3-获取运行时类的构造器" class="headerlink" title="2.3.3 获取运行时类的构造器"></a>2.3.3 获取运行时类的构造器</h4><ul>
<li><code>getConstructors()</code>：获取当前运行时类中声明为public访问权限的构造器；</li>
<li><code>getDeclaredConstructors()</code>：获取当前运行时类中声明的所有构造器；</li>
</ul>
<h3 id="2-4-调用运行时类的指定属性、方法"><a href="#2-4-调用运行时类的指定属性、方法" class="headerlink" title="2.4 调用运行时类的指定属性、方法"></a>2.4 调用运行时类的指定属性、方法</h3><h4 id="2-4-1-调用运行时类的指定属性"><a href="#2-4-1-调用运行时类的指定属性" class="headerlink" title="2.4.1 调用运行时类的指定属性"></a>2.4.1 调用运行时类的指定属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以自定义类Person为例：</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"><span class="comment">//创建运行时类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取运行时类中指定变量名的属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证当前属性时可访问的</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取、设置指定对象的此属性值</span></span><br><span class="line"><span class="comment">//set()：参数1指明设置哪个对象的属性，参数2设置具体的当前属性值</span></span><br><span class="line">name.set(p, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="comment">//get()：参数指明获取哪个对象的当前属性值</span></span><br><span class="line">System.out.println(name.get(p));</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-调用运行时类的指定方法"><a href="#2-4-2-调用运行时类的指定方法" class="headerlink" title="2.4.2 调用运行时类的指定方法"></a>2.4.2 调用运行时类的指定方法</h4><p><strong>一、对于非静态方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以自定义类Person为例：</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"><span class="comment">//创建运行时类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定的某个方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethd(方法名, 可变形参);</span><br><span class="line"><span class="comment">//保证当前方法是可访问的</span></span><br><span class="line">show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//调用invoke()</span></span><br><span class="line"><span class="comment">// invoke()：参数1是方法的调用者，参数2是给方法形参赋值的实参，invoke()的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line">show.invoke(p, 实参)</span><br></pre></td></tr></table></figure>

<p><strong>二、对于静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethd(方法名);</span><br><span class="line">showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//静态方法使用当前类去调用，使用当前类.class的形式</span></span><br><span class="line">showDesc.invoke(Person.class)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架(Spring+SpringMVC+MyBatis)整合搭建步骤</title>
    <url>/2020/09/01/SSM%E6%A1%86%E6%9E%B6(Spring+SpringMVC+MyBatis)%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>因为 Spring MVC 是 Spring 框架中的一个子模块，所以 Spring 与 SpringMVC 之间不存在整合的问题，本质上SSM框架的整合只涉及 Spring 与 MyBatis 的整合，以及 Spring MVC 与 MyBatis 的整合。而各自整合的步骤如下：</p>
<span id="more"></span>

<h3 id="一、基本环境搭建"><a href="#一、基本环境搭建" class="headerlink" title="一、基本环境搭建"></a>一、基本环境搭建</h3><ol>
<li><p>新建一个Maven项目</p>
</li>
<li><p>在pom.xml中导入需要用到的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Servlet、JSP--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在pom.xml中添加Maven资源过滤，预防资源无法导出</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>建立基本目录结构（controller、dao、service、pojo）</p>
</li>
<li><p>配置框架</p>
<ul>
<li>Mybatis 配置文件 ：<strong>mybatis-config.xml</strong> </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 配置文件 ：<strong>applicationContext.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二、MyBatis层编写"><a href="#二、MyBatis层编写" class="headerlink" title="二、MyBatis层编写"></a>二、MyBatis层编写</h3><ol>
<li><p>数据库配置文件 ：<strong>database.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：MySQL 8.0以上的版本要配置时区，serverTimezone=GMT%2B8否则会有时区问题，并且驱动由&quot;com.mysql.jdbc.Driver&quot; 变为：&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用IDEA连接数据库</p>
</li>
<li><p>在pojo包下创建实体类（以Blog为例），使用lombok插件创建有参、无参构造器和getter、setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> String create_time;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写dao层接口及对应的Mapper.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mq.pojo.Blog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有的博客</span></span><br><span class="line">    List&lt;Blog&gt; <span class="title function_">queryAllBLog</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace:绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssm.dao.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--绑定对应的方法，以及定义返回值类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllBLog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">                select * from firend_mq.blog</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>.编写 Mybatis 的核心配置文件，导入实体类和映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描pojo包下的实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册mapper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Service层的接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BlogService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用dao层中的方法</span></span><br><span class="line">    <span class="keyword">private</span> BlogMapper blogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; <span class="title function_">queryAllBLog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blogMapper.queryAllBLog();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、Spring层编写"><a href="#三、Spring层编写" class="headerlink" title="三、Spring层编写"></a>三、Spring层编写</h3><ol>
<li><p>编写Spring整合Mybatis的相关的配置文件：<strong>spring-dao.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.关联数据库文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:database.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池的私有属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring IoC的依赖注入：<strong>spring-service.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service相关的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--将BlogServiceImpl注入到IOC容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;BlogServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ssm.service.BlogServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> 	<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四、SpringMVC层编写"><a href="#四、SpringMVC层编写" class="headerlink" title="四、SpringMVC层编写"></a>四、SpringMVC层编写</h3><ol>
<li><p>编写网络配置文件：<strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册前端控制器DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--自定义配置文件位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--表示服务器Tomcat创建对象的顺序，数值越小创建对象的时间越早--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置编码过滤器CharacterEncodingFilter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置HiddenHttpMethodFilter过滤器--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置Session过期时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring MVC配置文件：<strong>spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2.静态资源默认servlet配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 3.开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置ViewResolver视图解析器，也可以配置为Thymeleaf--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 根据需要还可以配置文件上传解析器、拦截器和异常处理器--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring配置整合文件：<strong>applicationContext.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-service.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-mvc.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>至此SSM框架就整合完成！</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录三种实现方式比较</title>
    <url>/2021/10/03/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​            单点登录（Single Sign On, 简称SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。以百度为例，如果用户在百度贴吧登录过之后，当他访问百度知道时就无需再次登录即可使用服务，而百度贴吧和百度知道是百度公司旗下的两个不同的应用系统，那么就说明百度贴吧和百度知道之间实现了单点登录。</p>
<p>​            单点登录的实现方式有多种，下面来总结三种在学习过程中遇到过的实现方法：</p>
<span id="more"></span>

<h3 id="1-Session广播机制实现"><a href="#1-Session广播机制实现" class="headerlink" title="1. Session广播机制实现"></a>1. Session广播机制实现</h3><p>实现机制：参与集群的每个节点的Session状态都被复制到该集群中的其他所有节点上，无论何时，只要Session发生改变，Session数据都要重新被复制到其他节点上，由于每个节点都复制一份Session，当一个节点出现问题时其它节点可以接替它的工作，但是节点间进行Session复制同步会造成数据重复，占据大量的系统空间，整体性能随着集群节点数的增加而急剧下降，不适合多模块项目。</p>
<h3 id="2-Cookie-Redis实现"><a href="#2-Cookie-Redis实现" class="headerlink" title="2. Cookie+Redis实现"></a>2. Cookie+Redis实现</h3><p>实现机制：</p>
<p>(1)客户端第在集群某节点一次登录时，通过服务端产生cookie和一个与之对相应的session；<br>(2)将第一次登录产生的User对象(即登录所需信息)，以key-value的形式存储在Redis中，key存放按照一定规则生成的唯一随机值，value存储用户登录所需信息，并把生成的唯一随机值放到cookie中；<br>(3)当客户端再次该集群中访问另外需要登录操作的页面时，发送请求会带着cookie进行发送，将该客户端的cookie拿到Redis中根据key进行查询比对，如果存在，则视为已登录；</p>
<h3 id="3-token实现"><a href="#3-token实现" class="headerlink" title="3. token实现"></a>3. token实现</h3><p>实现机制：<br>(1)客户端第一次在集群中某模块登录时获取登录凭证（按照一定规则生成的字符串），把登录后的用户信息经过加密后包含到生成字符串中，并把字符串返回，字符串返回的方式有两种：</p>
<ul>
<li>可以把字符串通过cookie返回</li>
<li>把字符串通过地址栏返回</li>
</ul>
<p>(2)客户端再去访问集群中的其他模块，每次访问在地址栏都带着生成的字符串，在访问的模块中获取地址栏的字符串，根据字符串获取用户信息，如果可以获取到就登录；</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>难点记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合学习笔记</title>
    <url>/2020/03/12/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习Java集合时所记录的笔记；</p>
<span id="more"></span>



<h2 id="1-Java集合概述"><a href="#1-Java集合概述" class="headerlink" title="1. Java集合概述"></a>1. Java集合概述</h2><h3 id="1-1-集合与数组的比较"><a href="#1-1-集合与数组的比较" class="headerlink" title="1.1 集合与数组的比较"></a>1.1 集合与数组的比较</h3><p><strong>一、数组在存储多个数据方面的特点：</strong></p>
<ul>
<li>一旦初始化以后，其长度就确定了；</li>
<li>数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据了；</li>
</ul>
<p><strong>二、数组在存储多个数据方面的缺点：</strong></p>
<ul>
<li>一旦初始化以后，其长度就不可修改了；</li>
<li>数组中提供的方法有限，不便于添加、删除、插入数据等操作。同时效率不高；</li>
<li>数组没有现成的属性或方法获取数组中实际元素的个数；</li>
<li>数组存储对于无序、不可重复的需求不能满足；</li>
</ul>
<p><strong>三、集合存储的优点：</strong></p>
<ul>
<li>可以解决数组存储数据方面的以上弊端；</li>
</ul>
<h2 id="2-Collection接口（重点）"><a href="#2-Collection接口（重点）" class="headerlink" title="2. Collection接口（重点）"></a>2. Collection接口（重点）</h2><h3 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h3><p><strong>注意：</strong>Collection接口的实现类的对象中添加数据obj时，要求obj所在类必须要<strong>重写equals( )方法</strong>;</p>
<p><strong>常用方法如下：</strong></p>
<ol>
<li><code>add(Object e)</code>：将元素e添加到集合中</li>
<li><code>size( )</code>：获取添加的元素的个数</li>
<li><code>addAll(Collection coll)</code>：将coll集合中的元素添加到当前的集合中</li>
<li><code>isEmpty( )</code>：判断当前集合是否为空</li>
<li><code>clear( )</code>：清空结合元素</li>
<li><code>contains(Object obj)</code>：判断当前集合中是否包含obj，在判断氏会调用obj对象所在类的equals( )方法</li>
<li><code>containsAll(Collection coll)</code>：判断形参coll中的所有元素是否都存在于当前集合中</li>
<li><code>remove(Object obj)</code>：从当前集合中移除obj元素</li>
<li><code>removeAll(Collection coll)</code>：从当前集合中移除coll中的所有的元素</li>
<li><code>retainAll(Collection coll)</code>：获取当前集合和coll集合的交集，并返回给当前集合</li>
<li><code>equals(Object obj)</code>：判断两个集合的元素是否相同</li>
<li><code>hasjCode( )</code>：返回当前对象的哈希值</li>
<li><code>toAttay( )</code>：将集合变为数组（将数组变为集合：调用Arrays类的静态方法asList( )；）</li>
<li><code>iterator( )</code>：返回Iterator接口的实例，用于遍历集合元素</li>
</ol>
<h3 id="2-2-Iterator迭代器接口"><a href="#2-2-Iterator迭代器接口" class="headerlink" title="2.2 Iterator迭代器接口"></a>2.2 Iterator迭代器接口</h3><p><strong>Iterator迭代器的作用：</strong>进行集合元素的遍历操作；</p>
<h4 id="2-2-1-Iterator接口使用方法"><a href="#2-2-1-Iterator接口使用方法" class="headerlink" title="2.2.1 Iterator接口使用方法"></a>2.2.1 Iterator接口使用方法</h4><ol>
<li><code>hasNext( )</code>：判断是否还有下一个元素；</li>
<li><code>next( )</code>：①指针下移；②将下移以后集合位置上的元素返回；</li>
<li><code>remove( )</code>：Iterator内部定义的方法，可以在遍历的时候删除集合中的元素，<strong>注意此方法不同于集合直接调用的remove( )</strong>;</li>
</ol>
<h4 id="2-2-2-遍历集合的几种方式"><a href="#2-2-2-遍历集合的几种方式" class="headerlink" title="2.2.2 遍历集合的几种方式"></a>2.2.2 遍历集合的几种方式</h4><h5 id="1-遍历方式一：使用iterator迭代器"><a href="#1-遍历方式一：使用iterator迭代器" class="headerlink" title="1. 遍历方式一：使用iterator迭代器"></a>1. 遍历方式一：使用iterator迭代器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator( );</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext( )) &#123;</span><br><span class="line">	System.out.println(iterator.next( ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意以下错误方式：</span></span><br><span class="line"><span class="keyword">while</span>(coll.iterator( ).hasNext( )) &#123;</span><br><span class="line">	System.out.println(coll.iterator( ).next( ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误原因：集合对象每次调用iterator( )方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前；</span></span><br></pre></td></tr></table></figure>

<h5 id="2-遍历方式二：使用foreach循环"><a href="#2-遍历方式二：使用foreach循环" class="headerlink" title="2. 遍历方式二：使用foreach循环"></a>2. 遍历方式二：使用foreach循环</h5><p><strong>注意：</strong>foreach循环用于遍历集合和数组，内部其实仍然调用了迭代器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="keyword">for</span>(Object obj : coll) &#123;</span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-遍历方式三：使用普通循环"><a href="#3-遍历方式三：使用普通循环" class="headerlink" title="3. 遍历方式三：使用普通循环"></a>3. 遍历方式三：使用普通循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; coll.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-List接口"><a href="#2-3-List接口" class="headerlink" title="2.3 List接口"></a>2.3 List接口</h3><p>特点：<strong>存储有序的、可重复的数据；</strong>可理解为动态数组，用于替换原有的数组；</p>
<h4 id="2-3-1-ArrayList（常用）"><a href="#2-3-1-ArrayList（常用）" class="headerlink" title="2.3.1 ArrayList（常用）"></a>2.3.1 ArrayList（常用）</h4><p>ArrayList 继承自 AbstractList，实现了 List 接口，是一个可以动态修改的数组，与普通数组的区别就是它<strong>没有固定大小的限制</strong>；</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>add()</code>：将元素插入到指定位置的ArrayList中；</li>
<li><code>contains()</code>：判断元素是否在ArrayList；</li>
<li><code>get()</code>：通过索引值获取ArrayList中的元素；</li>
<li><code>subList(int fromIndex, int toIndex)</code>：用于截取并返回动态数组中的一部分；</li>
<li><code>set(int index, E element)</code>：用于替换动态数组中指定索引的元素；</li>
<li><code>sort(Comparator c)</code>：根据指定的顺序对动态数组中的元素进行排序；</li>
<li><code>removeIf(Predicate&lt;E&gt; filter)</code>：用于删除所有满足特定条件的数组元素；</li>
<li><code>forEach(Consumer&lt;E&gt; action)</code>：用于遍历动态数组中每一个元素并执行特定操作</li>
</ul>
<h4 id="2-3-2-LinkedList（常用）"><a href="#2-3-2-LinkedList（常用）" class="headerlink" title="2.3.2 LinkedList（常用）"></a>2.3.2 LinkedList（常用）</h4><p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低;</p>
<p><strong>注意：</strong>LinkedList 实现了 Queue接口 ，可作为单向队列使用；同时实现了Deque接口，可作为双端队列和栈使用；</p>
<ul>
<li>队列(Queue)：限定所有的插入只能在表的一端进行，而所有的删除都在表的另一端进行的线性表。表中允许插入的一端称为队尾(Rear)，允许删除的一端称为队头(Front)。队列的操作是按先进先出(FIFO)的原则进行的。</li>
<li>栈(Stack)：限定仅在表尾进行插入和删除运算的线性表，表尾称为栈顶(top)，表头称为栈底(bottom)。也是一种特殊的线性表，是一种后进先出(LIFO)的结构。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>add(int index, E element)</code>：向指定位置插入元素；</li>
<li><code>addFirst() / addLast()</code>：把元素加到列表首部 / 尾部；</li>
<li><code>removeLast()</code>：删除并返回最后一个元素；</li>
<li><code>E poll()</code>：删除并返回第一个元素；</li>
<li><code>E get(int index)</code>：返回指定位置的元素；</li>
<li><code>int indexOf(Object o)</code>：查找指定元素从前往后第一次出现的索引；</li>
<li><code>E set(int index, E element)</code>：设置指定位置的元素；</li>
<li><code>Object[] toArray()</code>：返回一个由链表元素组成的数组；</li>
<li><code>int size()</code>：返回链表元素个数；</li>
</ul>
<h4 id="2-3-3-Vector（已过时）"><a href="#2-3-3-Vector（已过时）" class="headerlink" title="2.3.3 Vector（已过时）"></a>2.3.3 Vector（已过时）</h4><h4 id="2-3-4-三者的异同点"><a href="#2-3-4-三者的异同点" class="headerlink" title="2.3.4 三者的异同点"></a>2.3.4 三者的异同点</h4><ul>
<li>相同点：两个类都实现了List接口，存储数据的特点相同，都是存储有序的、可重复的数据；</li>
<li>不同点：<ul>
<li>ArrayList：作为List接口的主要实现类：线程不安全，效率高，底层使用Object[ ] elementData存储；</li>
<li>LinkedList：底层使用双向循环链表存储，在此链表上每一个数据节点都由三部分组成：前指针（指向前面的节点的位置），数据，后指针（指向后面的节点的位置），最后一个节点的后指针指向第一个节点的前指针，形成一个循环。线程不安全，对于频繁的插入和删除操作，使用此类效率比ArrayList效率高；</li>
<li>Vector：作为List接口的古老实现类：线程安全，效率低，底层使用Object[ ] elementData存储；</li>
</ul>
</li>
</ul>
<h4 id="2-3-5-List接口使用场景推荐"><a href="#2-3-5-List接口使用场景推荐" class="headerlink" title="2.3.5 List接口使用场景推荐"></a>2.3.5 List接口使用场景推荐</h4><p><strong>如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List</strong></p>
<p>对ArrayList和LinkedList的优缺点进行分析：</p>
<p><strong>ArrayList</strong></p>
<p>优点：ArrayList是实现了基于动态数组的数据结构，地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着的）。</p>
<p>缺点：因为地址连续，当要插入和删除时，Arraylist需要前后移动数据，所以插入和删除操作效率比较低。</p>
<p><strong>LinkedList</strong></p>
<p>优点：LinkedList是基于链表的数据结构，地址任意，所以开辟内存空间时不需要连续的地址，对于新增和删除操作比较占优势。</p>
<p>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</p>
<p>即对于ArrayList和LinkedList的使用场景推荐如下：</p>
<ol>
<li>对于需要快速插入，删除元素，应该使用LinkedList。</li>
<li>对于需要快速随机访问元素，应该使用ArrayList。</li>
<li>对于“<strong>单线程环境</strong>” 或者 “<strong>多线程环境，但List仅仅只会被单个线程操作</strong>”，此时应该使用ArrayList。对于“<strong>多线程环境，且List可能同时被多个线程操作</strong>”，此时，应该使用LinkedList。</li>
</ol>
<h3 id="2-4-Set接口"><a href="#2-4-Set接口" class="headerlink" title="2.4 Set接口"></a>2.4 Set接口</h3><p>特点：<strong>存储无序的、不可重复的数据</strong>；</p>
<ul>
<li><strong>无序性</strong>：不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的；</li>
<li><strong>不可重复性</strong>：保证添加的元素按照equals( )判断时不能返回true，即相同的元素只能添加一个；</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>向Set中添加数据，其所在的类一定要重写hashCode( )和equals( )；<ul>
<li><strong>要同时重写equals()和hashCode()的原因：</strong>因为添加进集合的时候首先需要判断该集合中是否含有需要添加的元素，这个时候就要使用contains方法。contains方法内部调用equals方法，所以要重写**<code>equals()</code><strong>；而本来Object类中equals()相等，hashCode()必然相等，只有两个都相等才能说明是同一个对象，仅仅重写equals()就打破了这种逻辑，所以还需要重写</strong><code>hashCode()</code>**;</li>
</ul>
</li>
<li>重写的hashCode( )和equals( )尽可能保持一致：相等的对象必须具有相等的散列码；</li>
</ol>
<h4 id="2-4-1-HashSet（常用）"><a href="#2-4-1-HashSet（常用）" class="headerlink" title="2.4.1 HashSet（常用）"></a>2.4.1 HashSet（常用）</h4><p>HashSet底层是<strong>数组+链表</strong>的结构；<br><strong>元素添加例子：</strong><br>向HashSet中添加元素a，首先调用元素a所在类的hashCode( )方法，计算元素a的哈希值，此哈希值通过某种算法计算出在HashSet底层数组中的存放位置（即索引位置），判断数组此位置上是否已经有元素：</p>
<ul>
<li>如果此位置上没有其他元素，则元素a添加成功；<strong>（情况1）</strong></li>
<li>如果此位置上有其他元素b（或以链表形式存放的多个元素），则比较元素a与元素b的hash值：<ul>
<li>如果hash值不相同，则元素a添加成功；<strong>（情况2）</strong></li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul>
<li>若equals()返回true，元素a添加失败；</li>
<li>若返回false则元素a添加成功；<strong>（情况3）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上元素b以链表方式存储，元素b存储在数组中并指向元素a；</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>boolean contains(Object o)</code>：若此set包含指定的元素，则返回true;</li>
<li><code>boolean add(E e)</code>：如果指定的元素尚不存在，则将其添加到此集合中</li>
</ul>
<h4 id="2-4-2-LinkedHashSet"><a href="#2-4-2-LinkedHashSet" class="headerlink" title="2.4.2 LinkedHashSet"></a>2.4.2 LinkedHashSet</h4><p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据；</p>
<h4 id="2-4-3-TreeSet"><a href="#2-4-3-TreeSet" class="headerlink" title="2.4.3 TreeSet"></a>2.4.3 TreeSet</h4><p><strong>使用要求：</strong></p>
<ol>
<li>向TreeSet中添加的数据，要求是相同类的对象，不能添加不同类的对象；</li>
<li>两种排序方式：自然排序（实现Comparable接口）、定制排序（实现Comparator接口）<ul>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo( )返回0，不再是equals( )</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare( )返回0，不再是equals( )</li>
</ul>
</li>
</ol>
<h4 id="2-4-4-三者的异同点"><a href="#2-4-4-三者的异同点" class="headerlink" title="2.4.4 三者的异同点"></a>2.4.4 三者的异同点</h4><ul>
<li><p>相同点：三者都实现了Set接口，存储无序的、不可重复的数据；</p>
</li>
<li><p>不同点：</p>
<ul>
<li>HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值；</li>
<li>LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet；</li>
<li>TreeSet：可以按照添加对象的指定属性进行排序，底层存储结构是红黑树；</li>
</ul>
</li>
</ul>
<h2 id="3-Map接口（重点）"><a href="#3-Map接口（重点）" class="headerlink" title="3. Map接口（重点）"></a>3. Map接口（重点）</h2><p>定义：双列集合，用来存储一对对（key-value）的数据</p>
<h3 id="3-1-Map的特点"><a href="#3-1-Map的特点" class="headerlink" title="3.1 Map的特点"></a>3.1 Map的特点</h3><ul>
<li>Map中的key：无序的、不可重复的，使用Set存储所有key（以HashMap类为例，key所在的类要重写equals()和hashCode()方法）</li>
<li>Map中的value：无序的、可重复的，使用Collection存储所有value（value所在的类要重写equals()方法）<br>一个键值对：key-value构成了一个Entry对象</li>
<li>Map中的entry：无序的、不可重复的，key-value构成了一个Entry键值对对象，使用Set存储所有的entry</li>
</ul>
<h3 id="3-2-HashMap（常用）"><a href="#3-2-HashMap（常用）" class="headerlink" title="3.2 HashMap（常用）"></a>3.2 HashMap（常用）</h3><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1. HashMap概述"></a>1. HashMap概述</h4><p><strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表后通过key对象的equals()逐一比对查找。</p>
<ul>
<li><strong>注意：</strong>JDK7.0时底层结构只有数组+链表，JDK8.0后底层结构为<strong>数组+链表+红黑树</strong>；（当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储）</li>
</ul>
<p><strong>哈希冲突：</strong>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了（即<strong>两个不同的元素，通过哈希函数得出的实际存储地址相同</strong>），其实这就是所谓的哈希冲突，也叫哈希碰撞。</p>
<h4 id="2-HashMap在JDK7-0与JDK-8-0底层实现原理对比"><a href="#2-HashMap在JDK7-0与JDK-8-0底层实现原理对比" class="headerlink" title="2. HashMap在JDK7.0与JDK 8.0底层实现原理对比"></a>2. HashMap在JDK7.0与JDK 8.0底层实现原理对比</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">HashMap</span>( );</span><br><span class="line">不同于像JDK7<span class="number">.0</span>在实例化以后，底层创建了长度为<span class="number">16</span>的一维数组Entry[ ] table，在JDK8<span class="number">.0</span>后底层没有创建一个长度为<span class="number">16</span>的数组，底层数组变为是Node[ ]，而非Entry[ ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.put(key1, value1)</span><br><span class="line">在JDK8<span class="number">.0</span>，首次调用put( )方法时，底层才创建了长度为<span class="number">16</span>的数组执行put()</span><br><span class="line">    </span><br><span class="line">JDK7<span class="number">.0</span>与<span class="number">8.0</span>时执行流程类似如下：</span><br><span class="line">首先调用key1所在类的hashcode( )计算key1哈希值，哈希值经过某种算法计算以后得到在Entry数组中的存放位置</span><br><span class="line">如果此位置上的数据为空，此时的key1-value1添加成功；（情况<span class="number">1</span>）</span><br><span class="line">如果此位置上的数据不为空，比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">	如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功；（情况<span class="number">2</span>）</span><br><span class="line">	如果key1的哈希值与已经存在的某个数据（key2-value2）的哈希值相同，继续调用key1所在类的equals(key2)方法比较：</span><br><span class="line">		如果equals()返回<span class="literal">false</span>，则key1-value1添加成功；（情况<span class="number">3</span>）</span><br><span class="line">		如果equals()返回<span class="literal">true</span>，使用value1替换value2</span><br><span class="line"></span><br><span class="line">注意：关于情况<span class="number">2</span>和<span class="number">3</span>，此时key1-value1和原来的数据以链表的方式存储；</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<ul>
<li><code>size()</code>：计算 HashMap 中键/值对的数量；</li>
<li><code>put(K key，V value)</code>：将键/值对添加到 HashMap 中；</li>
<li><code>containsKey(Object key)</code>：检查 HashMap 中是否存在指定的 key 对应的映射关系；</li>
<li><code>replace(K key, V oldValue, V newValue)</code>：替换 HashMap 中是指定的 key 对应的 value；</li>
<li><code>forEach(BiConsumer&lt;K, V&gt; action)</code>：用于对 HashMap 中的每个映射执行指定的操作；</li>
<li><code>merge(key, value, remappingFunction)</code>：先判断指定的 key 是否存在，如果不存在，则添加键值对到 hashMap 中；</li>
<li><code>keySet() / values() / entrySet()</code>：分别是返回所有key / value / 键值对；</li>
<li><code>getOrDefault(Object key, V defaultValue)</code>：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值；</li>
</ul>
<h3 id="3-3-LinkedHashMap"><a href="#3-3-LinkedHashMap" class="headerlink" title="3.3 LinkedHashMap"></a>3.3 LinkedHashMap</h3><h3 id="3-4-TreeMap"><a href="#3-4-TreeMap" class="headerlink" title="3.4 TreeMap"></a>3.4 TreeMap</h3><h3 id="3-5-HashTable（已过时）"><a href="#3-5-HashTable（已过时）" class="headerlink" title="3.5 HashTable（已过时）"></a>3.5 HashTable（已过时）</h3><h3 id="3-6-Properties"><a href="#3-6-Properties" class="headerlink" title="3.6 Properties"></a>3.6 Properties</h3><h3 id="3-7-五者的异同点"><a href="#3-7-五者的异同点" class="headerlink" title="3.7 五者的异同点"></a>3.7 五者的异同点</h3><ul>
<li>不同点：<ul>
<li>HashMap：作为Map接口的主要实现类，线程不安全，效率高；可以存储null的key和value；</li>
<li>LinkedHashMap：保证在遍历Map元素时，可以按照添加的顺序实现遍历，原因在原有的HashMap底层结构基础上添加了一对指针，指向前一个和后一个元素；（对于频繁的遍历操作，此类执行效率高于HashMap）</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历，此时考虑key的自然排序或定制排序；</li>
<li>Hashtable：作为古老的实现类，线程安全，效率低，不可以存储null的key和value；</li>
<li>Properties：Hashtable的子类，<strong>常用来处理配置文件</strong>，key和value都是String类型的；</li>
</ul>
</li>
</ul>
<h2 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4. Collections工具类"></a>4. Collections工具类</h2><p>Collections：是操作Set、、List和Map等集合的工具类</p>
<p><strong>常用方法：</strong></p>
<ol>
<li><p>排序操作（均为static方法）</p>
<ul>
<li><code>reverse(List)</code>：反转List中元素的顺序</li>
<li><code>shuffle(List)</code>：对List集合元素进行随机排序</li>
<li><code>sort(List, Comparator)</code>：根据指定的Comparator产生的顺序对List集合元素按升序排序</li>
<li><code>swap(List, int, int)</code>：将指定List集合中的i处元素和j处元素进行交换</li>
</ul>
</li>
<li><p>查找替换</p>
<ul>
<li><code>Object max(Collection)</code>：根据元素的自然排序，返回给定集合中的最大元素</li>
<li><code>int frequency(Collection, Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest, List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：使用新值替换旧值</li>
</ul>
<p><code>synchronizedList(List)</code>：将指定集合包装成线程同步的集合（用于解决ArrayList和HashMap线程安全问题）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2020/10/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis个人总结的学习笔记，后续继续补充知识点</p>
<span id="more"></span>

<h2 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1.Redis概述"></a>1.Redis概述</h2><p><strong>Redis实现机制：</strong>单线程+多路IO复用（具有原子性的原因）</p>
<h3 id="1-1-Redis基础命令"><a href="#1-1-Redis基础命令" class="headerlink" title="1.1 Redis基础命令"></a>1.1 Redis基础命令</h3><h4 id="1-1-1-Redis手动启动方式"><a href="#1-1-1-Redis手动启动方式" class="headerlink" title="1.1.1 Redis手动启动方式"></a>1.1.1 <strong>Redis手动启动方式</strong></h4><p>Redis服务器启动命令：redis-server</p>
<h4 id="1-1-2-Redis后台自启动方式"><a href="#1-1-2-Redis后台自启动方式" class="headerlink" title="1.1.2 Redis后台自启动方式"></a>1.1.2 <strong>Redis后台自启动方式</strong></h4><ol>
<li>复制redis.conf到任意新目录（自定义redis.conf）</li>
<li>修改redis.conf中的daemonize no改为yes，让服务自启动</li>
<li>redis-server  /新目录/redis.conf：启动服务</li>
<li>redis-cli：连接客户端</li>
</ol>
<h4 id="1-1-3-Redis关闭方式："><a href="#1-1-3-Redis关闭方式：" class="headerlink" title="1.1.3 Redis关闭方式："></a>1.1.3 <strong>Redis关闭方式：</strong></h4><ul>
<li>单实例关闭：redis-cli shutdown</li>
<li>多实例关闭：<ol>
<li>ps -ef |grep redis</li>
<li> redis-cli -p 指定端口号 shutdown</li>
</ol>
</li>
</ul>
<h4 id="1-1-4-Redis键相关命令："><a href="#1-1-4-Redis键相关命令：" class="headerlink" title="1.1.4 Redis键相关命令："></a>1.1.4 <strong>Redis键相关命令：</strong></h4><ul>
<li>查看当前库所有key：**key **</li>
<li>用于查找所有符合给定模式 pattern 的 key：<strong>keys pattern</strong></li>
<li>迭代数据库中的数据库键：SCAN cursor pattern count</li>
<li>设置键值对：<strong>set key value</strong></li>
<li>查找key对应value：<strong>get key</strong></li>
<li><strong>只有在key不存在时设置key的值，成功添加返回1：setnx key value</strong></li>
<li>判断key是否存在：<strong>exist key</strong></li>
<li>查看key的数据类型：<strong>type key</strong></li>
<li>删除指定的key：<strong>del key</strong></li>
<li>根据value选择非阻塞删除：<strong>unlink key</strong>（仅将key从keyspace元数据中删除，真正的删除会在后续异步操作）</li>
<li>将给定的value追加到原值的末尾：<strong>append key value</strong></li>
<li>获取值的长度：<strong>strlen key</strong></li>
<li>将key中存储的数字值增加1：<strong>incr key</strong></li>
<li>将key中存储的数字值减少1：<strong>decr key</strong></li>
<li>将key中存储的数字值增减自定义值：<strong>incrby/decrby key 步长</strong></li>
<li><strong>为给定的key设置过期时间：expire key 指定时间</strong></li>
<li>查看key还有多久过期：<strong>ttl key</strong>（-1表示永不过期，-2表示已经过期）</li>
</ul>
<h4 id="1-1-5-操作数据库相关命令"><a href="#1-1-5-操作数据库相关命令" class="headerlink" title="1.1.5 操作数据库相关命令"></a>1.1.5 操作数据库相关命令</h4><ul>
<li>切换数据库：<strong>select 数字</strong></li>
<li>查看当前数据库的key的数量：<strong>dbsize</strong></li>
<li>清空所有库：<strong>flushdb</strong></li>
</ul>
<h2 id="2-常用数据类型"><a href="#2-常用数据类型" class="headerlink" title="2. 常用数据类型"></a>2. 常用数据类型</h2><h3 id="2-1-String字符串"><a href="#2-1-String字符串" class="headerlink" title="2.1 String字符串"></a>2.1 String字符串</h3><p><strong>注意</strong>：String的数据结构为简单动态字符串，是可以修改的字符串没类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><p>同时设置一个或多个key-value对：<strong>mset key1 value1 key2 value2</strong></p>
</li>
<li><p>同时获取一个或多个value：<strong>mget key1 key2 key3</strong></p>
</li>
<li><p>当且仅当所有给定的key都不存在时，同时设置一个或多个key-value对：<strong>msetnx key1 value1 key2 value2  (具有原子性，有一个失败则都会失败)</strong></p>
</li>
<li><p>获取范围内的值：<strong>getrange key 起始位置 结束位置</strong></p>
</li>
<li><p>用value覆写key所存储的字符串值中的字符，从起始位置开始：<strong>setrange key 起始位置 value</strong></p>
</li>
<li><p><strong>设置键值的同时设置过期时间：setex key 过期时间 value</strong></p>
</li>
<li><p>获取key对应旧值的同时设置为新值value：<strong>getset key value</strong></p>
</li>
</ul>
<h3 id="2-2-List列表"><a href="#2-2-List列表" class="headerlink" title="2.2 List列表"></a>2.2 List列表</h3><p><strong>注意：</strong>List是单键多值的，底层是双向链表，可以添加元素到列表头部或者尾部<br>（Redis将链表和ziplist结合起来组成了quicklist，即将多个ziplist使用双向指针串起来使用）<br><strong>常用命令：</strong></p>
<ul>
<li><p>从左边/右边插入一个或多个值：<strong>lpush/rpush key value1 value2</strong></p>
</li>
<li><p>从左边/右边弹出一个值（值在键在）：<strong>lpop/rpop key</strong></p>
</li>
<li><p>从key1列表右边弹出值插到key2列表左边：<strong>rpoplpush key1 key2</strong></p>
</li>
<li><p>按照索引下标获取范围内的元素：<strong>lrange key start stop</strong>（0左边第一个，-1右边第一个，0 -1表示获取所有）</p>
</li>
<li><p>按照索引下标获取指定位置的元素：<strong>lindex key index</strong></p>
</li>
<li><p>获取列表长度：<strong>llen key</strong></p>
</li>
<li><p>在value的前面/后面插入值：<strong>linsert key before/after value newValue</strong></p>
</li>
<li><p>从左边开始删除n个相同的value：<strong>lrem key n value</strong></p>
</li>
<li><p>将列表key下标为index的值替换成value：<strong>lset key index value</strong></p>
</li>
</ul>
<h3 id="2-3-Set无序集合"><a href="#2-3-Set无序集合" class="headerlink" title="2.3 Set无序集合"></a>2.3 Set无序集合</h3><p><strong>注意：</strong>Set是String类型的无序集合，底层是一个value为null的哈希表，添加、删除、查找的复杂度都为O(1)<br><strong>常用命令：</strong></p>
<ul>
<li><p>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略：<strong>sadd key value1 value2</strong></p>
</li>
<li><p>取出该集合中的所有值：<strong>smembers key</strong></p>
</li>
<li><p>判断集合key是否含有对应的value：<strong>sismember key value</strong>（有则为1，没有为0）</p>
</li>
<li><p>返回该集合的元素个数：<strong>scard key</strong></p>
</li>
<li><p>删除集合中的某个元素：<strong>srem key value1 value2</strong></p>
</li>
<li><p>随机从集合中弹出一个值：<strong>spop key</strong></p>
</li>
<li><p>随机从集合中取出n个值，不会从集合中删除：<strong>srandmember key n</strong></p>
</li>
<li><p>把集合中一个值从集合1移动到集合2：<strong>smove 集合1 集合2 value</strong></p>
</li>
<li><p>返回两个集合的交集元素：<strong>sinter key1 key2</strong></p>
</li>
<li><p>返回两个集合的并集元素：<strong>sunion key1 key2</strong></p>
</li>
<li><p>返回两个集合的差集元素（key1中有的而key2没有的）：<strong>sdiff key1 key2</strong></p>
</li>
</ul>
<h3 id="2-4-Hash哈希表"><a href="#2-4-Hash哈希表" class="headerlink" title="2.4 Hash哈希表"></a>2.4 Hash哈希表</h3><p><strong>注意：</strong>Redis的Hash是一个String类型的key-(field: value)的映射表（键值对集合），而Hash类型对应的数据结构有两种，当field:value长度较短且个数较少时使用ziplist，否则使用hashtable</p>
<p><strong>常用命令：</strong><br>给key集合中的field键赋值为value：<strong>hset key field value</strong></p>
<p>从key集合的field中取出对应的value：<strong>hget key field</strong></p>
<p>批量设置hash值：<strong>hmset key field1 value1 field2 value2</strong></p>
<p>查看key中给定的field是否存在：<strong>hexists key field</strong></p>
<p>列出该key集合中所有的field：<strong>hkeys key</strong></p>
<p>列出该key结合中所有的value：<strong>hvals key</strong></p>
<p>为key中的域field的值加上指定增量：<strong>hincrby key field 指定增量</strong></p>
<p>将哈希表key中的域field的值设置为value，当且仅当域field不存在：<strong>hsetnx key field value</strong></p>
<h3 id="2-5-Zset有序集合"><a href="#2-5-Zset有序集合" class="headerlink" title="2.5 Zset有序集合"></a>2.5 Zset有序集合</h3><p><strong>注意：没有重复元素的字符串集合</strong>（有序集合的每个成员都关联了一个score，score被用来按照从最低到最高的方式排序集合中的成员，<strong>集合中的成员是唯一的，但是score可以重复</strong>），其底层结构是Hash+跳跃表</p>
<p><strong>常用命令：</strong><br>将一个或多个member元素及其score值加入到有序集key中：<strong>zadd key score1 value1 score2 value2</strong></p>
<p>返回有序集合key中下标在start和stop之间的元素，并让分数一起和值返回到结果集：<strong>zrange key start stop withscores</strong></p>
<p>返回有序集合key中所有score值介于min和max之间的成员，有序集合成员按score</p>
<p>递增排列：<strong>zrangebyscore key min max</strong></p>
<p>递减排序：<strong>zrevrangebyscore key max min</strong></p>
<p>为元素的score加上增量：<strong>zincrby key 增量 value</strong></p>
<p>删除有序集合key中指定值的元素：<strong>zrem key value</strong></p>
<p>统计集合指定区间内的元素个数：<strong>zcount key min max</strong></p>
<p>返回该值在集合中的排名，从0开始：<strong>zrank key value</strong></p>
<h2 id="3-Redis-6新数据类型"><a href="#3-Redis-6新数据类型" class="headerlink" title="3. Redis 6新数据类型"></a>3. Redis 6新数据类型</h2><h3 id="3-1-Bitmaps字符串"><a href="#3-1-Bitmaps字符串" class="headerlink" title="3.1 Bitmaps字符串"></a>3.1 Bitmaps字符串</h3><p><strong>注意：</strong>Bitmaps字符串本身不是一种数据类型，只是对字符串进行位操作（以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量）</p>
<p><strong>常用命令：</strong><br>设置Bitmaps中某个偏移量的值(0或1)：<strong>setbit key offset value</strong></p>
<p>获取Bitmaps中某个偏移量的值：<strong>getbit key offset</strong></p>
<p>统计字符串从start到end之间比特值为1的数量（0为左边第一个，-1为右边第一个）：<strong>bitcount key start end</strong></p>
<p>做多个Bitmaps的与或非操作并将结果保存在destkey中：<strong>bitop and(or/not/xor) destkey key1 key2…</strong></p>
<h3 id="3-2-HyperLogLog去重"><a href="#3-2-HyperLogLog去重" class="headerlink" title="3.2 HyperLogLog去重"></a>3.2 HyperLogLog去重</h3><p><strong>注意：</strong>HyperLogLog去重是用来做基数统计，即统计不重复元素的算法；（计算基数所需的空间总是固定的并且很小）</p>
<p><strong>常用命令：</strong></p>
<p>添加指定元素到HyperLogLog中：<strong>pfadd key element</strong> （执行命令后如果近似基数发生变化则返回1，否则返回0）</p>
<p>计算HyperLogLog的近似基数：<strong>pfcount key…</strong></p>
<p>将一个或多个HyperLogLog合并后的结果存储在另一个HyperLogLog中：<strong>pfmerge destkey sourcekey…</strong></p>
<h3 id="3-3-Geospatial经纬度"><a href="#3-3-Geospatial经纬度" class="headerlink" title="3.3 Geospatial经纬度"></a>3.3 Geospatial经纬度</h3><p><strong>注意：</strong>Geospatial经纬度用于经纬度设置查询、范围查询、距离查询、经纬度Hash等操作</p>
<p><strong>常用命令：</strong></p>
<p>添加地理位置(经度、维度、名称)：<strong>geoadd key longitude latitude member</strong></p>
<p>获取指定地区的坐标值：<strong>geopos key member</strong></p>
<p>获取两个位置之间的直线距离：<strong>geodist key member1 member2</strong></p>
<p>以给定的经纬度为中心找出某一半径内的元素：<strong>georadius key longitude latitude radius</strong></p>
<h2 id="4-Redis的发布和订阅"><a href="#4-Redis的发布和订阅" class="headerlink" title="4. Redis的发布和订阅"></a>4. Redis的发布和订阅</h2><p><strong>概念：Redis发布订阅（pub/sub）是一种消息通信模式</strong>，发送者发送消息，订阅者接收信息，Redis客户端可以订阅任意数量的频道，当频道发布消息后消息就会推送给订阅者；</p>
<p><strong>发布订阅实现：</strong></p>
<ul>
<li><p>订阅频道：<strong>subscribe channel名</strong></p>
</li>
<li><p>推送内容：<strong>publish channel名 ’推送内容‘</strong></p>
</li>
</ul>
<h2 id="5-Jedis操作Redis-6"><a href="#5-Jedis操作Redis-6" class="headerlink" title="5. Jedis操作Redis 6"></a>5. Jedis操作Redis 6</h2><p><strong>Jedis使用步骤：</strong></p>
<ol>
<li><p>先在pom/xml引入jedis相关依赖！</p>
</li>
<li><p>创建Jedis对象：<strong>Jedis jedis = new Jedis(“访问redis所在主机ip地址”，端口号)</strong><br>（注意：必须要先修改redis.conf允许远程访问，以及linux防火墙放行端口号）</p>
</li>
<li><p>创建成功后即可使用redis-api的相关方法</p>
</li>
</ol>
<p><strong>模拟验证码发送步骤与要求：</strong></p>
<ol>
<li>输入手机号点击发送后随机生成6位数字码，<pre><code>**random.nextInt(10)循环生成6位随机数字符串**
</code></pre>
</li>
<li>验证码2分钟有效，<pre><code>**把验证码放到redis中，expire设置过期时间为120秒**
</code></pre>
</li>
<li>输入验证码点击验证判断是否一致，<pre><code>**从redis获取验证码和输入的验证码进行比较**
</code></pre>
</li>
<li>每个手机号每天只能输入3次；<pre><code>**第一次发送setnx设置发送次数是1，incr每次发送后+1，当大于3时提交不能发送**
</code></pre>
</li>
</ol>
<h2 id="6-Redis与Spring-Boot整合"><a href="#6-Redis与Spring-Boot整合" class="headerlink" title="6. Redis与Spring Boot整合"></a>6. Redis与Spring Boot整合</h2><p>整合步骤：</p>
<ol>
<li><p>先引入依赖spring-boot-starter-data-redis和commons-pool2</p>
</li>
<li><p>在application.properties中配置redis配置</p>
<ul>
<li>spring.redis.host：redis服务器地址</li>
<li>spring.redis.port：redis服务器连接端口</li>
<li>spring.redis.database：redis数据库索引</li>
<li>spring.redis.timeout：连接超时时间</li>
<li>spring.redis.lettuce.pool.max-active：连接池最大连接数</li>
<li>spring.redis.lettuce.pool.max-wait：最大诸塞等待时间</li>
<li>spring.redis.lettuce.pool.max-idle：连接池中最大空闲连接数</li>
<li>spring.redis.lettuce.pool.min-idle：连接池中最小空闲连接数</li>
</ul>
</li>
<li><p>创建Redis配置类RedisConfig</p>
</li>
</ol>
<h2 id="7-Redis的事务操作和锁"><a href="#7-Redis的事务操作和锁" class="headerlink" title="7. Redis的事务操作和锁"></a>7. Redis的事务操作和锁</h2><p><strong>事务定义：</strong>Redis是一个单独的隔离操作，事务中的所有命令都会序列化并按顺序执行，事务在执行的过程中不会被其他客户端发送来的命令请求所打断（<strong>串联执行多个命令并防止别的命令插队</strong>）</p>
<h3 id="7-1-执行命令"><a href="#7-1-执行命令" class="headerlink" title="7.1 执行命令"></a>7.1 执行命令</h3><ul>
<li><p>输入<strong>Multi命令</strong>：输入的命令依次进入命令队列中但不会执行；（组队阶段，组队过程可通过<strong>discard命令</strong>放弃组队）</p>
</li>
<li><p>输入<strong>Exec命令</strong>：之前命令队列中的命令依次执行；（执行阶段）</p>
</li>
</ul>
<h3 id="7-2-事务错误处理"><a href="#7-2-事务错误处理" class="headerlink" title="7.2 事务错误处理"></a>7.2 事务错误处理</h3><p>一、<strong>组队阶段出现错误：</strong><br>组队阶段有任意某个命令出现错误，则所有组队的命令都不会被执行，进行回滚；</p>
<p>二、<strong>执行阶段出现错误：</strong><br>执行阶段任意某个命令出现错误，则只有错误的命令不会被执行，而其他命令会继续执行，不会进行回滚；</p>
<h3 id="7-3-Redis事务特性"><a href="#7-3-Redis事务特性" class="headerlink" title="7.3 Redis事务特性"></a>7.3 Redis事务特性</h3><ol>
<li><p><strong>单独的隔离操作</strong>：事务执行过程中不会被其他客户端发送来的命令请求所打断；</p>
</li>
<li><p><strong>没有隔离级别概念</strong>：事务提交前任何指令都不会被实际执行；</p>
</li>
<li><p><strong>不保证原子性</strong>：事务中有一条命令执行失败其他命令仍然会被执行，没有回滚；</p>
</li>
</ol>
<h3 id="7-4-乐观锁解决事务冲突问题"><a href="#7-4-乐观锁解决事务冲突问题" class="headerlink" title="7.4 乐观锁解决事务冲突问题"></a>7.4 乐观锁解决事务冲突问题</h3><p><strong>Watch key1, key2…</strong>：在执行Multi命令前，先执行watch key命令监视一个或多个key，<strong>如果在事务执行之前这些key先被其他命令所改动，那么事务将被打断</strong>；</p>
<p><strong>Unwatch</strong>：取消Watch命令对所有key的监视；</p>
<h2 id="8-日志持久化AOF与RDB"><a href="#8-日志持久化AOF与RDB" class="headerlink" title="8. 日志持久化AOF与RDB"></a>8. 日志持久化AOF与RDB</h2><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><p>含义：<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘；</strong></p>
<p><strong>持久化流程：</strong><br>Redis单独创建一个子进程来进行持久化，会<strong>先将数据写入到一个临时文件中</strong>，待持久化过程都结束后再用这个<strong>临时文件替换上次持久化好的文件</strong>；（写时复制技术）</p>
<p>注意：<strong>RDB最后一次持久化后的数据可能会丢失</strong></p>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>含义：<strong>以日志形式来记录每个写操作（增量保存）</strong>，将Redis执行过的所有写指令记录下来，不记录读操作，<strong>只许追加文件但不可以改写文件，Redis启动后就会重新覆盖新文件，追加保存每次写操作到文件末尾</strong>；</p>
<p><strong>持久化流程：</strong></p>
<ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内，</li>
<li>AOF缓冲区根据AOF持久化策略操作sync同步到磁盘的AOF文件中，</li>
<li><strong>当AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</strong></li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ol>
<p><strong>注意：</strong>AOF默认不开启，可以在redis.conf中配置文件名称，默认为appendonly.aof，AOF文件保存路径和RDB的路径一致（<strong>当AOF和RDB同时开启时，系统默认读取AOF的数据，因为AOF的数据不会存在对视</strong>）</p>
<h2 id="9-主从复制"><a href="#9-主从复制" class="headerlink" title="9. 主从复制"></a>9. 主从复制</h2><h3 id="主从模型"><a href="#主从模型" class="headerlink" title="主从模型"></a>主从模型</h3><p><strong>主从复制原理：</strong></p>
<ol>
<li><p>当从服务器连接上主服务器之后，从服务器向主服务器发送进行数据同步消息；</p>
</li>
<li><p>主服务器接到从服务器发送过来的同步消息后，把主服务器数据进行持久化生成rdb文件，把rdb文件发送给从服务器，从服务器拿到rdb文件后进行读取完成复制；</p>
</li>
<li><p>每次主服务器进行写操作后主动发起，会和从服务器进行数据同步；</p>
</li>
</ol>
<p><strong>主从复制步骤：</strong></p>
<ol>
<li><p>配置好多个从服务器redis,conf文件，分别<strong>redis -server redis.conf</strong>启动服务器</p>
</li>
<li><p>在从服务器客户端操作命令：<strong>slaveof 主服务器ip 主服务器端口</strong>，操作命令后即可形成一主多从结构</p>
</li>
<li><p>在主服务器输入命令：info replication即可查看连接的从服务器的具体数量；</p>
</li>
</ol>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>概念：<strong>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库（原来的主机就算后来恢复正常也是作为原来从机的从库）</strong>；</p>
<p><strong>哨兵模式使用步骤：</strong></p>
<ol>
<li><p>新建sentinel.conf配置文件，在文件中输入内容：<strong>sentinel monitor 监控服务器名称 服务器端口号 1</strong>，1为至少有多少个哨兵同意才进行迁移的数量</p>
</li>
<li><p><strong>redis.sentinel /目录/sentinel.conf</strong>：启动哨兵</p>
</li>
</ol>
<h2 id="10-Redis集群"><a href="#10-Redis集群" class="headerlink" title="10. Redis集群"></a>10. Redis集群</h2><p>集群概念：Redis集群实现了对Redis的水平扩容，即启动N个Reids节点将整个数据库分布存储在这M个节点中，每个节点存储总数据的1/N；</p>
<h2 id="11-Redis应用问题解决"><a href="#11-Redis应用问题解决" class="headerlink" title="11. Redis应用问题解决"></a>11. Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>出现现象：</strong></p>
<ol>
<li>redis命中率降低，导致一直查询数据库，应用服务器压力变大</li>
</ol>
<p><strong>出现原因：</strong></p>
<ol>
<li>redis中查询不到，一直访问数据库</li>
<li>出现大量非正常url访问</li>
</ol>
<p><strong>解决方法：</strong><br>（1）对空值缓存<br>（2）设置可访问的白名单（bitmaps定义可访问名单）<br>（3）采用布隆过滤器<br>（4）进行实时监控（设置黑名单）</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>产生原因：</strong>redis中的某个key过期了，瞬时大量访问使用这个key</p>
<p><strong>解决方法：</strong><br>（1）预先设置热门数据到redis中，加大热门数据key的时长<br>（2）实时调整key的过期时长<br>（3）使用锁</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>产生原因：</strong>在极少时间段内，出现大量查询key的集中过期情况</p>
<p><strong>解决方法：</strong><br>（1）<strong>构建多级缓存架构：nginx缓存+redis缓存+其他缓存(ehcache等)</strong><br>（2）使用锁或队列（可以使用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，但是不适用高并发情况）<br>（3）设置过期标志更新缓存（设置提前量，如果快过期就触发通知另外的线程在后台去更新实际key的缓存）<br>（4）把缓存失效时间分散开，随机数生成过期时间</p>
<h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><p>Redis实现分布式锁的步骤：</p>
<ol>
<li><p>使用setnx key value上锁，通过del key释放锁</p>
</li>
<li><p>锁如果一直没有释放则设置key过期时间<br><strong>上锁同时设置过期时间实现原子操作：set key value nx ex 过期时间</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记</title>
    <url>/2021/10/05/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是个人在学习JVM时记录的学习笔记，大体上分为内存与垃圾回收以及性能监控与调优两部分</p>
<span id="more"></span>

<h2 id="一、内存与垃圾回收篇"><a href="#一、内存与垃圾回收篇" class="headerlink" title="一、内存与垃圾回收篇"></a>一、内存与垃圾回收篇</h2><h3 id="1-类加载子系统"><a href="#1-类加载子系统" class="headerlink" title="1. 类加载子系统"></a>1. 类加载子系统</h3><h4 id="1-1-类加载器与类加载子系统概述"><a href="#1-1-类加载器与类加载子系统概述" class="headerlink" title="1.1 类加载器与类加载子系统概述"></a>1.1 类加载器与类加载子系统概述</h4><p><strong>类加载器子系统作用：</strong>负责从文件系统或网络中加载.class文件生成Class文件，.class文件在文件开头有特定的文件标识；（类加载器ClassLoader只负责.class文件的加载，至于它是否可以运行，则由Execution Engine决定）</p>
<p><strong>注意：</strong>加载的类信息(DNA元数据模板)存放在方法区中，除了类信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<h4 id="1-2-类的加载过程（类的生命周期）"><a href="#1-2-类的加载过程（类的生命周期）" class="headerlink" title="1.2 类的加载过程（类的生命周期）"></a>1.2 类的加载过程（类的生命周期）</h4><p>类的加载过程分为三部分：Loading加载→Linking链接→Initialization初始化（其中链接阶段包括Verification验证→Preparation准备→Resolution解析）</p>
<h5 id="类的加载过程一：Loading加载"><a href="#类的加载过程一：Loading加载" class="headerlink" title="类的加载过程一：Loading加载"></a>类的加载过程一：Loading加载</h5><ul>
<li><p><strong>加载的理解：</strong></p>
<p>将Java类的字节码文件加载到机器内存中，并在内存中构建出类模板对象</p>
</li>
<li><p><strong>加载完成的操作：</strong></p>
<ul>
<li>通过一个类的全限定名（即全类名）获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>创建<code>java.lang.Class</code>类的实例，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
</ul>
<h5 id="类的加载过程二：Linking链接"><a href="#类的加载过程二：Linking链接" class="headerlink" title="类的加载过程二：Linking链接"></a>类的加载过程二：Linking链接</h5><ul>
<li><strong>验证</strong><ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证加载的字节码是合法、合理并符合规范的</li>
<li>主要包括四种验证方式：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li>为类变量分配内存并且设置该类变量的默认初始值</li>
<li><strong>注意：不包括用final修饰的static</strong>，因为final在编译的时候就会分配了，准备阶段会显式初始化；也<strong>不会为实例变量分配初始化</strong>，因为类变量会分配在方法区中，而实例变量会随着对象一起分配到堆中；</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>解析操作会随着JVM在执行完初始化之后再执行</li>
<li>解析主要针对类或接口、字段、类方法、接口方法、方法类型等</li>
</ul>
</li>
</ul>
<h5 id="类的加载过程三：Initialization初始化"><a href="#类的加载过程三：Initialization初始化" class="headerlink" title="类的加载过程三：Initialization初始化"></a>类的加载过程三：Initialization初始化</h5><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程，注意<code>&lt;clinit&gt;()</code>不等同于类的构造器</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ul>
<h4 id="1-3-类加载器分类"><a href="#1-3-类加载器分类" class="headerlink" title="1.3 类加载器分类"></a>1.3 类加载器分类</h4><p>JVM支持两种类型的类加载器，分别为引导类加载器Bootstrap ClassLoader和自定义类加载器User-Defined ClassLoader（注意所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器）</p>
<p><strong>常见的3个类加载器：</strong></p>
<ol>
<li><strong>启动类加载器</strong>（引导类加载器Bootstrap ClassLoader）<ul>
<li>嵌套在JVM内部，这个加载器用来加载Java核心库(JAVA_HOME、jre、lib、rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</li>
<li>并不继承自ClassLoader抽象类，没有父加载器</li>
<li>加载扩展类或应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>
</li>
<li><strong>扩展类加载器</strong>（Extension ClassLoader）<ul>
<li>派生于ClassLoader抽象类、父类加载器为启动类加载器</li>
<li>从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库，如果用户创建的JAR放在此目录下，也会自动有扩展类加载器加载</li>
</ul>
</li>
<li><strong>应用程序类加载器</strong>（系统类加载器，AppClassLoader）<ul>
<li>派生于ClassLoader抽象类、父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li><strong>是程序中默认的类加载器</strong>，一般Java应用的类都是由它来完成加载</li>
</ul>
</li>
</ol>
<h4 id="1-4-双亲委派机制"><a href="#1-4-双亲委派机制" class="headerlink" title="1.4 双亲委派机制"></a>1.4 双亲委派机制</h4><p><strong>工作原理：</strong></p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务就成功返回，若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。</li>
</ol>
<p><strong>双亲委派机制的优势：</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<p><strong>沙箱安全机制：</strong></p>
<p>含义：就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<h3 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2. 运行时数据区"></a>2. 运行时数据区</h3><h4 id="2-1-运行时数据区概述"><a href="#2-1-运行时数据区概述" class="headerlink" title="2.1 运行时数据区概述"></a>2.1 运行时数据区概述</h4><p>JVM虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动和退出而创建和销毁；另外一些则与线程一一对应，随着线程开始和结束而创建和销毁</p>
<ul>
<li><strong>每个线程私有</strong>：程序计数器、虚拟机栈、本地方法栈；（生命周期与线程生命周期保持一致）</li>
<li><strong>线程间共享</strong>：堆、方法区（永久代或元空间、代码缓存）；（生命周期与虚拟机的生命周期保持一致）</li>
</ul>
<h4 id="2-2-程序计数器（PC寄存器）"><a href="#2-2-程序计数器（PC寄存器）" class="headerlink" title="2.2 程序计数器（PC寄存器）"></a>2.2 程序计数器（PC寄存器）</h4><h5 id="2-2-1-程序计数器概述"><a href="#2-2-1-程序计数器概述" class="headerlink" title="2.2.1 程序计数器概述"></a>2.2.1 程序计数器概述</h5><ul>
<li>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟；</li>
<li>唯一一个在虚拟机规范中没有规定任何OutOtMemoryError情况的区域；</li>
</ul>
<p>作用：<strong>用来存储指向下一条指令的地址，即是将要执行的代码</strong>。由执行引擎读取下一条指令。</p>
<h5 id="2-2-2-程序计数器常见问题"><a href="#2-2-2-程序计数器常见问题" class="headerlink" title="2.2.2 程序计数器常见问题"></a>2.2.2 程序计数器常见问题</h5><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？</p>
<p><strong>答：</strong>因为CPU需要不停地切换各个进程，有可能导致切换回来以后就不知道接着从哪开始继续执行，因此JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令；</p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p><strong>答：</strong>每个线程都分配一个PC寄存器目的在于使能够准确记录各个线程正在执行的当前字节码指令地址，这样每个线程之间就可以进行独立计算不会出现相互干扰的情况；</p>
</li>
</ol>
<h4 id="2-3-虚拟机栈（重点）"><a href="#2-3-虚拟机栈（重点）" class="headerlink" title="2.3 虚拟机栈（重点）"></a>2.3 虚拟机栈（重点）</h4><h5 id="2-3-1-虚拟机栈概述"><a href="#2-3-1-虚拟机栈概述" class="headerlink" title="2.3.1 虚拟机栈概述"></a>2.3.1 虚拟机栈概述</h5><p><strong>内存中的栈和堆：</strong></p>
<p>栈是运行时的单位，而堆是存储的单位，即栈解决程序的运行问题（程序如何执行或者如何处理数据），而堆解决数据的存储问题（数据怎么放，放在哪儿）。</p>
<p><strong>Java虚拟机栈概念：</strong></p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用</p>
<p><strong>虚拟机栈作用：</strong></p>
<p>管理Java程序的运行，<strong>保存方法的局部变量、部分结果，并参与方法的调用的返回</strong>；</p>
<p><strong>虚拟机栈的特点：</strong></p>
<ul>
<li>JVM直接对虚拟机栈的操作只有两个：<ul>
<li>每个方法执行伴随着对栈帧的压栈</li>
<li>方法执行结束后对应栈帧就执行出栈</li>
</ul>
</li>
<li>对于栈来说，其访问速度仅次于程序计数器。并且其不存在垃圾回收问题</li>
</ul>
<h5 id="2-3-2-栈中可能出现的异常"><a href="#2-3-2-栈中可能出现的异常" class="headerlink" title="2.3.2 栈中可能出现的异常"></a>2.3.2 栈中可能出现的异常</h5><ol>
<li>如果采用固定大小的虚拟机栈，那每一个线程的虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，将会抛出<strong>StackOverflowError</strong>（栈溢出）异常。</li>
<li>如果虚拟机栈可以动态扩展，并且在尝试扩展时无法申请到足够的内存，或者在创建新的线程时没有足够内存去创建对应的虚拟机栈，将会抛出<strong>OutOfMemoryError</strong>（内存溢出）异常</li>
</ol>
<h5 id="2-3-3-栈的存储结构和运行原理"><a href="#2-3-3-栈的存储结构和运行原理" class="headerlink" title="2.3.3 栈的存储结构和运行原理"></a>2.3.3 栈的存储结构和运行原理</h5><p><strong>栈的存储结构：</strong></p>
<p>每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在，在线程上正在执行的每个方法都各自对应一个栈帧（栈帧是一个内存区块，维系着方法执行过程中的各种数据信息）；</p>
<p><strong>栈的运行原理：</strong></p>
<ul>
<li><p>在一个活动线程中，每个时间点上只会有一个活动的栈帧，即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>，与当前栈帧相对应的方法就是<strong>当前方法</strong>，定义这个方法的类就是<strong>当前类</strong>；</p>
</li>
<li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作；</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在站的顶端成为新的当前帧；</p>
</li>
<li><p>不可以在一个栈帧之中引用另外一个线程的栈帧；（栈是每个线程私有的）</p>
</li>
<li><p>如果当前方法调用了其他方法，在方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧；</p>
</li>
</ul>
<h5 id="2-3-4-栈帧的内部结构"><a href="#2-3-4-栈帧的内部结构" class="headerlink" title="2.3.4 栈帧的内部结构"></a>2.3.4 栈帧的内部结构</h5><p>每个栈帧中都存储着<strong>局部变量表</strong>、<strong>操作数栈</strong>（表达式栈）、<strong>动态链接</strong>（指向运行时常量池的方法引用）、<strong>方法返回地址</strong>（方法正常退出或异常退出的定义）、<strong>一些附加信息</strong>；</p>
<ul>
<li><p><strong>局部变量表</strong></p>
<ul>
<li>定义为一个数字数组，<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong></li>
<li>局部变量表所需的容量大小是在编译期确定下来的，方法运行期间是不会改变局部变量表的大小的；</li>
<li>局部变量表中的变量只在当前方法调用中有效，当方法调用结束后随着方法栈桢的销毁，局部变量表也会随之销毁；</li>
<li>局部变量表最基本的存储单元是Slot（变量槽），32位以内的类型只占用一个slot，64位的类型(long和double)占用两个slot；</li>
<li>局部变量表中的每一个Slot都分配一个<strong>访问索引</strong>用于访问，如果需要访问局部变量表中一个64位的局部变量值时，只需要使用前一个索引即可；</li>
</ul>
</li>
<li><p><strong>操作数栈</strong></p>
<ul>
<li><strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好，保存在方法的Code属性中，为max_stack的值</li>
<li>32位类型数据占用一个栈单位深度，64位类型数据占用两个栈单位深度</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的<strong>入栈和出栈操作</strong>来完成一次数据访问</li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前站真的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
</ul>
<p><strong>栈顶缓存技术：</strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</p>
</li>
<li><p><strong>动态链接</strong></p>
<ul>
<li><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接；</p>
<ul>
<li><p>为什么需要常量池呢？</p>
<p>常量池的作用就是为了提供一些符号和常量，便于指令的识别</p>
</li>
</ul>
</li>
<li><p><strong>作用是为了将这些符号引用转换为调用方法的直接引用</strong></p>
</li>
</ul>
</li>
<li><p><strong>方法返回地址</strong></p>
<ul>
<li><strong>作用是用于存放该方法的PC寄存器的值</strong></li>
<li>当方法正常退出时，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址；当异常退出时，不会给上层调用者产生任何返回值</li>
</ul>
</li>
</ul>
<h5 id="2-3-5-方法的调用"><a href="#2-3-5-方法的调用" class="headerlink" title="2.3.5 方法的调用"></a>2.3.5 方法的调用</h5><ol>
<li><strong>方法的绑定机制</strong><ul>
<li>静态链接：<strong>被调用的目标方法在编译期可知且运行期间保持不变</strong>，这种情况下将调用方法的符号引用转换为直接引用的过程（早期绑定）</li>
<li>动态链接：<strong>被调用的目标方法在编译期无法被确定下来</strong>，这种情况下只能在程序运行期将调用方法的符号引用转换为直接引用的过程，具有动态性（晚期绑定）</li>
</ul>
</li>
<li><strong>虚方法与非虚方法</strong><ul>
<li>非虚方法：方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法成为非虚方法<strong>（非虚方法包含静态方法、私有方法、final方法、实例构造器、父类方法）</strong></li>
<li>虚方法：除了以上非虚方法的都是虚方法</li>
</ul>
</li>
</ol>
<h5 id="2-3-6-虚拟机栈常见问题"><a href="#2-3-6-虚拟机栈常见问题" class="headerlink" title="2.3.6 虚拟机栈常见问题"></a>2.3.6 虚拟机栈常见问题</h5><ol>
<li><p>举例栈溢出（StackOverflowFrror）的情况</p>
</li>
<li><p>调整栈大小就能保证不出现溢出吗？</p>
<p><strong>答</strong>：不能，调整栈大小只能是延迟栈溢出的情况，但是不能保证一定不出现栈溢出</p>
</li>
<li><p>垃圾回收是否会涉及到虚拟机栈？</p>
<p><strong>答</strong>：不涉及，因为虚拟机栈是每个线程私有的；</p>
</li>
<li><p>方法中定义的局部变量是否线程安全？</p>
<p><strong>答</strong>：如果只有一个线程操作此数据，则必定是线程安全的；如果多个线程操作此数据，则此数据是共享数据，如果不考虑同步机制的话，会存在线程安全问题</p>
</li>
</ol>
<h4 id="2-4-本地方法栈"><a href="#2-4-本地方法栈" class="headerlink" title="2.4 本地方法栈"></a>2.4 本地方法栈</h4><h5 id="2-4-1-本地方法栈概述"><a href="#2-4-1-本地方法栈概述" class="headerlink" title="2.4.1 本地方法栈概述"></a>2.4.1 本地方法栈概述</h5><ul>
<li>虚拟机栈用于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong></li>
<li>本地方法栈允许被实现成固定或者可动态扩展的内存大小（在内存溢出和栈溢出方面与虚拟机栈相同）</li>
<li>本地方法使用C语言实现，在本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库</li>
<li>当某个线程调用一个本地方法时，本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li>
<li>HotSpot JVM将虚拟机栈和本地方法栈合成了一块区域</li>
</ul>
<h4 id="2-5-堆空间（重点）"><a href="#2-5-堆空间（重点）" class="headerlink" title="2.5 堆空间（重点）"></a>2.5 堆空间（重点）</h4><h5 id="2-5-1-堆的核心概述"><a href="#2-5-1-堆的核心概述" class="headerlink" title="2.5.1 堆的核心概述"></a>2.5.1 堆的核心概述</h5><ul>
<li>一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域，<strong>所有的对象实例以及数组在运行时都分配在堆上</strong></li>
<li>堆内存的大小是可以调节的，其在JVM启动时就被创建，其空间大小也就确定了（JVM管理最大的内存空间）</li>
<li>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</li>
<li>所有的线程共享Java堆，在堆中还可以划分线程私有的缓冲区（TLAB）</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除</li>
<li>堆空间内存可细分为：<strong>年轻代（新生区）+老年代（养老区）+元空间</strong></li>
</ul>
<h5 id="2-5-2-设置堆内存大小"><a href="#2-5-2-设置堆内存大小" class="headerlink" title="2.5.2 设置堆内存大小"></a>2.5.2 设置堆内存大小</h5><ul>
<li>-Xms用于表示堆区的起始内存，等价于-XX：InitialHeapSize</li>
<li>-Xmx用于表示堆区的最大内存，等价于-XX：MaxHeapSize，一旦堆区内存大小超过指定的最大内存时，将会抛出OutOfMemory异常</li>
<li>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小从而提高性能</strong></li>
</ul>
<h5 id="2-5-3-年轻代与老年代"><a href="#2-5-3-年轻代与老年代" class="headerlink" title="2.5.3 年轻代与老年代"></a>2.5.3 年轻代与老年代</h5><ul>
<li>堆区进一步细分可以划分为年轻代和老年代，年轻代又可划分为Eden空间、两块大小相同的Survivor（又称为from区和to区，to区总为空），老年代存放新生代中经历多次GC仍然存活的对象</li>
<li>可以通过-XX：SurvivorRatio调正Eden空间和另外两个SAurvivor空间的空间比例</li>
<li><strong>几乎所有的Java对象都是在Eden区被new出来的</strong>，绝大部分的Java对象的销毁都在新生代进行</li>
</ul>
<h5 id="2-5-4-对象分配过程"><a href="#2-5-4-对象分配过程" class="headerlink" title="2.5.4 对象分配过程"></a>2.5.4 对象分配过程</h5><ol>
<li>new的对象先放到Eden区，当Eden区的空间填满而程序又需要创建对象时，JVM的Minor GC将对Eden区进行垃圾回收，将Eden去中不再被其他对象所引用的对象销毁，再加载新的对象放到Eden区，然后将Eden区中的剩余对象移动到from区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来放到from区的对象，如果没有回收就会放到to区</li>
<li>如果再次经历垃圾回收，此时会重新回到from区，接下来再去to区，不断循环此过程直到计数器到达设置值，如果还没有被回收就从年轻代移动到老年代</li>
</ol>
<h5 id="2-5-5-对于堆的GC垃圾回收概述"><a href="#2-5-5-对于堆的GC垃圾回收概述" class="headerlink" title="2.5.5 对于堆的GC垃圾回收概述"></a>2.5.5 对于堆的GC垃圾回收概述</h5><p>概述：频繁在新生代收集，很少在老年代收集，几乎不在元空间收集</p>
<ul>
<li>部分收集：<ul>
<li><strong>Minor GC</strong>：只是新生代的垃圾收集<ul>
<li>当新生代空间不足（指的是Eden区满，Survivor区满互惠引发GC）就会触发Minor GC</li>
<li>Minor GC工作频繁且回收速度较快，工作时会引发STW，暂停其他用户的线程，等垃圾回收结束后用户线程才恢复运行</li>
</ul>
</li>
<li><strong>Major GC</strong>：只是老年代的垃圾收集<ul>
<li>目前只有CMS GC会有单独收集老年代的行为</li>
<li>老年代空间不足时会先尝试触发Minor GC，如果之后空间还不足则触发Major GC，如果Major之后空间还不足就报OOM异常了</li>
<li>Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长</li>
</ul>
</li>
<li><strong>Mixed GC</strong>：收集整个新生代以及部分老年代的垃圾收集</li>
</ul>
</li>
<li>整堆收集：<ul>
<li><strong>Full GC</strong>：收集整个堆和方法区的垃圾收集</li>
</ul>
</li>
</ul>
<h5 id="2-5-6-堆空间分代思想"><a href="#2-5-6-堆空间分代思想" class="headerlink" title="2.5.6 堆空间分代思想"></a>2.5.6 堆空间分代思想</h5><ul>
<li>分代的原因是优化GC性能，如果没有分代那么GC时就需要对堆的所有区域进行扫描才能找到哪些对象没用，很多对象的生命周期很短，而通过分代就可以在GC是先把这部分对象的区域进行回收从而腾出很大的空间</li>
</ul>
<h5 id="2-5-7-内存分配策略"><a href="#2-5-7-内存分配策略" class="headerlink" title="2.5.7 内存分配策略"></a>2.5.7 内存分配策略</h5><p>针对不同年龄段的对象分配原则如下：</p>
<ul>
<li>优先分配到新生代的Eden区</li>
<li>大对象直接分配到老年代，长期存活的对象也分配到老年代</li>
<li>如果Survivor区中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到要求的年龄<strong>（动态对象年龄判断）</strong></li>
</ul>
<h5 id="2-5-8-为对象分配缓冲区内存：TLAB"><a href="#2-5-8-为对象分配缓冲区内存：TLAB" class="headerlink" title="2.5.8 为对象分配缓冲区内存：TLAB"></a>2.5.8 为对象分配缓冲区内存：TLAB</h5><ul>
<li>TLAB概念：对Eden区继续进行划分，在Eden区中JVM为每个线程分配一个私有缓存区域，可以避免一些多线程环境下的线程安全问题</li>
<li>默认情况下，TLAB空间内存非常小，仅占整个Eden空间的1%</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM会通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</li>
</ul>
<h5 id="2-5-9-堆是分配对象存储的唯一选择吗？"><a href="#2-5-9-堆是分配对象存储的唯一选择吗？" class="headerlink" title="2.5.9 堆是分配对象存储的唯一选择吗？"></a>2.5.9 堆是分配对象存储的唯一选择吗？</h5><ul>
<li>如果经过<strong>逃逸分析</strong>后发现，一个对象如果<strong>没有逃逸出方法</strong>的话，那么就可能被优化成在栈上分配<ul>
<li>逃逸分析概述：一种分析算法，基本行为就是分析对象动态作用域<ul>
<li>当一个对象在方法中被定义时，对象只在方法内部使用，则认为没有发生逃逸（没有发生逃逸的对象则可以分配到栈上，随着方法执行的结束占空间就被移除）</li>
<li>当一个方法在方法中被定义后，他被外部方法所引用，则认为发生逃逸，例如作为调用参数传递到其他地方中</li>
</ul>
</li>
<li>代码优化：<strong>开发中能使用局部变量的，就不要使用在方法外定义的变量</strong><ol>
<li>栈上分配：经过逃逸分析如果发现一个对象并没有逃逸出方法，就可以将堆分配转化为栈分配</li>
<li>同步省略（锁消除）：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li>分离对象或标量替换：如果对象不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以不存储在内存，而是存储在CPU寄存器中</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="2-6-方法区-元空间（重点）"><a href="#2-6-方法区-元空间（重点）" class="headerlink" title="2.6 方法区 / 元空间（重点）"></a>2.6 方法区 / 元空间（重点）</h4><h5 id="2-6-1-栈、堆和方法区的交互关系"><a href="#2-6-1-栈、堆和方法区的交互关系" class="headerlink" title="2.6.1 栈、堆和方法区的交互关系"></a>2.6.1 栈、堆和方法区的交互关系</h5><p>以一行代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p><code>person</code>是<strong>方法的局部变量</strong>，存放在Java虚拟机栈的本地变量表中，指向在堆空间中<code>new Person()</code>创建的<strong>对象实例数据</strong>，在对象实例数据中有到对象数据类型的指针，指向在方法区中的<strong>对象类型数据</strong><code>Person</code></p>
<h5 id="2-6-2-方法区的理解"><a href="#2-6-2-方法区的理解" class="headerlink" title="2.6.2 方法区的理解"></a>2.6.2 方法区的理解</h5><ul>
<li>方法区可以看作是一块独立于Java堆的内存空间，与堆一样是各个线程共享的内存区域</li>
<li>方法去的大小决定了系统可以保存多少个类，如果定义了太多的类导致方法区溢出，同样会抛出内存溢出错误OOM（例如加载大量的第三方jar包、Tomcat部署的工程过多，大量的动态生成反射类）</li>
<li>元空间与JDK 7以前的永久代都是对JVM规范中方法去的实现，不过元空间与永久代区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></li>
</ul>
<h5 id="2-6-3-设置方法区大小"><a href="#2-6-3-设置方法区大小" class="headerlink" title="2.6.3 设置方法区大小"></a>2.6.3 设置方法区大小</h5><ul>
<li>元空间大小可以使用参数-XX：MetaspaceSize和-XX：MaxMetaspaceSize指定</li>
<li>如果不指定大小，默认情况下虚拟机会耗尽所有的可用系统内容，如果元数据区发生溢出虚拟机会抛出OOM异常</li>
</ul>
<h5 id="2-6-4-方法区的内部结构"><a href="#2-6-4-方法区的内部结构" class="headerlink" title="2.6.4 方法区的内部结构"></a>2.6.4 方法区的内部结构</h5><ul>
<li><p>方法区作用：<strong>用于存储已被虚拟机加载的类型信息（包括域信息、方法信息）、常量（存放在运行时常量池中）、即时编译器编译后的JIT代码缓存等</strong></p>
</li>
<li><p><strong>运行时常量池</strong></p>
<ul>
<li>常量池表是Class文件的一部分，<strong>用于存放编译期生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
<li>在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li>
<li>JVM为每个已加载的类型都维护一个常量池，池中的数据项通过索引访问</li>
</ul>
</li>
<li><p>JDK 7后<strong>字符串常量池</strong>和<strong>静态变量</strong>从方法区放到了堆空间中</p>
<ul>
<li><p><strong>为什么要调整字符串常量池位置呢？</strong></p>
<p>因为JDK 7 以前方法区是永久代，而永久代回收效率很低，只在Full GC时才触发回收，Ful GC只在堆的老年代空间不足，或永久代不足十才会触发，导致字符串常量池回收效率不高，而开发会创建大量字符串容易导致永久代内存不足，放在堆里回收效率能提高</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-6-5-对于方法区的GC垃圾回收概述"><a href="#2-6-5-对于方法区的GC垃圾回收概述" class="headerlink" title="2.6.5 对于方法区的GC垃圾回收概述"></a>2.6.5 对于方法区的GC垃圾回收概述</h5><p>方法区垃圾回收主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong></p>
<h4 id="2-7-对象的实例化、布局与访问定位"><a href="#2-7-对象的实例化、布局与访问定位" class="headerlink" title="2.7 对象的实例化、布局与访问定位"></a>2.7 对象的实例化、布局与访问定位</h4><h5 id="2-7-1-对象的实例化"><a href="#2-7-1-对象的实例化" class="headerlink" title="2.7.1 对象的实例化"></a>2.7.1 对象的实例化</h5><ul>
<li>创建对象的方式：使用new调用构造器、反射方式（Class的newInstance()、Constructor的newInstance(xxx)）、使用clone()、使用反序列化；</li>
<li>创建对象的步骤：<ol>
<li>判断对象对应的类是否加载、链接、初始化</li>
<li>为对象分配内存，如果内存规整指针碰撞，如果内存不规整虚拟机需要维护一个列表，空闲列表分配</li>
<li>处理并发安全问题，采用CAS失败重试，区域加锁保证更新的原子性，并且每个线程预先分配一块TLAB</li>
<li>初始化分配到的空间，所有属性设置默认初始值，保证对象实例字段再不复置时可以直接使用</li>
<li>设置对象的对象头</li>
<li>执行init方法进行初始化</li>
</ol>
</li>
</ul>
<h5 id="2-7-2-对象访问定位"><a href="#2-7-2-对象访问定位" class="headerlink" title="2.7.2 对象访问定位"></a>2.7.2 对象访问定位</h5><p>对象访问方式有两种：</p>
<ol>
<li>句柄访问（将到对象实例数据的指针保存在句柄池，指针指向栈中实例池中的对应对象实例数据）</li>
<li>直接指针（如2.6.1方式所示，Hotspot采用）</li>
</ol>
<h3 id="3-本地方法接口与本地库"><a href="#3-本地方法接口与本地库" class="headerlink" title="3 本地方法接口与本地库"></a>3 本地方法接口与本地库</h3><ul>
<li>一个本地方法（Native Method）就是一个Java调用非Java代码的接口，本地方法接口的作用是为了<strong>融合不同的编程语言为Java所用</strong>，在定义一个Native Method时并不提供实现体，其实现体由非Java语言在外面实现</li>
<li>使用标识符native定义本地方法，可以与除了abstract之外的所有java标识符连用</li>
</ul>
<h3 id="4-执行引擎"><a href="#4-执行引擎" class="headerlink" title="4. 执行引擎"></a>4. 执行引擎</h3><h4 id="4-1-执行引擎概述"><a href="#4-1-执行引擎概述" class="headerlink" title="4.1 执行引擎概述"></a>4.1 执行引擎概述</h4><h5 id="4-1-1-执行引擎作用"><a href="#4-1-1-执行引擎作用" class="headerlink" title="4.1.1 执行引擎作用"></a>4.1.1 执行引擎作用</h5><p>将字节码指令解释编译为对应平台上的本地机器指令（即<strong>将高级语言翻译为机器语言</strong>）</p>
<h5 id="4-1-2-执行引擎工作过程"><a href="#4-1-2-执行引擎工作过程" class="headerlink" title="4.1.2 执行引擎工作过程"></a>4.1.2 执行引擎工作过程</h5><p>输入字节码二进制流，处理过程是字节码解析执行的等效过程，输出执行结果，每当执行完一项指令后PC寄存器就会更新下一条需要被执行的指令地址</p>
<h4 id="4-2-Java代码编译和执行过程"><a href="#4-2-Java代码编译和执行过程" class="headerlink" title="4.2 Java代码编译和执行过程"></a>4.2 Java代码编译和执行过程</h4><p>程序源码→词法分析→单词流→语法分析→抽象语法树→（解释过程）指令流→解释器→解释执行</p>
<p>​                                                                                                 （编译过程）优化器→中间代码→编译生成器→目标代码</p>
<h4 id="4-3-机器码、指令、汇编语言"><a href="#4-3-机器码、指令、汇编语言" class="headerlink" title="4.3 机器码、指令、汇编语言"></a>4.3 机器码、指令、汇编语言</h4><p>机器指令码（机器语言）：用二进制编码方式表示的指令</p>
<p>指令：把机器码中特定的0和1序列简化为相应的命令</p>
<p>汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址</p>
<h4 id="4-4-解释器"><a href="#4-4-解释器" class="headerlink" title="4.4 解释器"></a>4.4 解释器</h4><h5 id="4-4-1-解释器作用"><a href="#4-4-1-解释器作用" class="headerlink" title="4.4.1 解释器作用"></a>4.4.1 解释器作用</h5><p>根据预定义的规范对字节码采用<strong>逐行解释</strong>的方式执行，将字节码文件中的内容翻译为对应平台的本地机器指令执行</p>
<h4 id="4-5-JIT编译器"><a href="#4-5-JIT编译器" class="headerlink" title="4.5 JIT编译器"></a>4.5 JIT编译器</h4><h5 id="4-5-1-JIT编译器作用"><a href="#4-5-1-JIT编译器作用" class="headerlink" title="4.5.1 JIT编译器作用"></a>4.5.1 JIT编译器作用</h5><p>将源代码直接<strong>编译</strong>成和本地机器平台相关的机器语言</p>
<h5 id="4-5-2-HotSpot-VM中JIT分类"><a href="#4-5-2-HotSpot-VM中JIT分类" class="headerlink" title="4.5.2 HotSpot VM中JIT分类"></a>4.5.2 HotSpot VM中JIT分类</h5><p>HotSpot VM有两个JIT编译器，分别为Client Compiler和Server Compiler，简称为C1编译器和C2编译器，C1会对字节码进行简单和可靠的优化，耗时短能达到更快的编译速度，C2进行耗时较长的优化以及激进优化，但优化的代码执行效率更高</p>
<h3 id="5-String-Table"><a href="#5-String-Table" class="headerlink" title="5. String Table"></a>5. String Table</h3><h4 id="5-1-String基本概述"><a href="#5-1-String基本概述" class="headerlink" title="5.1 String基本概述"></a>5.1 String基本概述</h4><ul>
<li>字符串常量池中不会存储相同内容的字符串</li>
<li>String的字符串常量池是一个固定大小的Hashtable（数组+链表）</li>
</ul>
<h4 id="5-2-String的内存分配"><a href="#5-2-String的内存分配" class="headerlink" title="5.2 String的内存分配"></a>5.2 String的内存分配</h4><ul>
<li>直接使用双引号声明的String对象会直接存储在常量池中，如果不是双引号声明的String对象，可以使用String提供的<code>intern()</code>方法</li>
<li>JDK 7以前字符串常量池存放在永久代，JDK 7后字符串常量池的位置调整到Java堆空间中，可以是在进行调优时仅需调整堆大小就可以</li>
</ul>
<h4 id="5-3-字符串拼接操作"><a href="#5-3-字符串拼接操作" class="headerlink" title="5.3 字符串拼接操作"></a>5.3 字符串拼接操作</h4><ul>
<li><strong>常量与常量</strong>，或者<strong>两者都是常量引用</strong>的拼接结果在常量池，原理是编译器优化，常量池中不存在相同内容的常量（注意使用<strong>final修饰的变量</strong>也算是常量）</li>
<li>只要<strong>其中有一个是变量</strong>，拼接结果就直接在堆中而不在常量池，原理是StringBuilder</li>
<li>如果拼接对象的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中并返回此对象地址</li>
<li>通过StringBuilder的append()方式添加字符串的效率要远高于使用String的字符串拼接方式，StringBuilder的<code>append()</code>方式自始至终只创建过一个StringBuilder对象，在实际开发中建议使用构造器<code>new StringBuilder(highLevel)</code>指定数组长度优化执行效果</li>
</ul>
<h4 id="5-4-intern-的使用（重点）"><a href="#5-4-intern-的使用（重点）" class="headerlink" title="5.4 intern()的使用（重点）"></a>5.4 intern()的使用（重点）</h4><ul>
<li><p>作用：<strong>判断字符串常量池中是否存在该字符串，如果存在则返回常量池中该字符串地址，如果不存在则将此字符串放入常量池中并返回此对象的地址</strong></p>
</li>
<li><p>如果在任意字符串上调用String.intern()方法，那么其返回结果所指向的那个类实例必须和直接以常量形式出现的字符串实例完全相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern() == <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>拓展题目</strong>：</p>
<ol>
<li>new String(“ab”)会创建几个对象？</li>
</ol>
<p>答：创建了两个对象，一个对象是new关键字在堆空间创建的，另一个对象是字符串常量池中的对象</p>
<ol start="2">
<li>new String(“a”) + new String(“b”)又会创建几个对象？</li>
</ol>
<p>答：创建了六个对象，对象1是new StringBuilder()，对象2是new String(“a”)，对象3是字符串常量池中的“a”，对象4是new String(“b”)，对象5是字符串常量池中的“b”，对象6是StringBuilder.toString()的new String(“ab”)<strong>(注意toString()的调用，在字符串常量池中没有生成“ab”)</strong></p>
<ul>
<li>String的intern()使用总结：<ul>
<li>JDK 6时将字符串对象尝试放入字符串常量池，如果字符串常量池有则不会放入，返回已有的字符串常量池中的对象的地址；<strong>如果没有，则把此对象复制一份放入字符串常量池并返回字符串常量池中的对象地址</strong></li>
<li>JDK 7以后将字符串对象尝试放入字符串常量池，如果字符串常量池有则不会放入，返回已有的字符串常量池中的对象的地址；<strong>如果没有，则把对象的引用地址复制一份放入字符串常量池并返回字符串常量池中的引用地址</strong></li>
</ul>
</li>
</ul>
<h3 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6. 垃圾回收"></a>6. 垃圾回收</h3><h4 id="6-1-垃圾回收概述"><a href="#6-1-垃圾回收概述" class="headerlink" title="6.1 垃圾回收概述"></a>6.1 垃圾回收概述</h4><ul>
<li><p>什么是垃圾？</p>
<p>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</p>
</li>
<li><p>为什么需要GC？</p>
<p>如果不进行垃圾，内存迟早都会被消耗完，而垃圾回收除了可以释放没用的对象，还可以清除内存中的记录碎片，以便JVM将清理出的内存分配给新的对象，可以说GC保证了应用程序的正常进行</p>
</li>
</ul>
<h4 id="6-2-垃圾回收相关算法（重点）"><a href="#6-2-垃圾回收相关算法（重点）" class="headerlink" title="6.2 垃圾回收相关算法（重点）"></a>6.2 垃圾回收相关算法（重点）</h4><h5 id="6-2-1-引用计数算法（用于标记阶段，Java没有采用）"><a href="#6-2-1-引用计数算法（用于标记阶段，Java没有采用）" class="headerlink" title="6.2.1 引用计数算法（用于标记阶段，Java没有采用）"></a>6.2.1 引用计数算法（用于标记阶段，Java没有采用）</h5><p><strong>垃圾标记阶段：</strong>在GC执行垃圾回收之前，首先需要区分内存中哪些是存活对象，哪些是已经死亡的对象，只有被标记为死亡的对象（其不再被任何存活对象继续引用）在执行垃圾回收是才会释放掉其所占用的内存空间</p>
<p><strong>引用计数算法概念</strong>：对每个对象保存一个整型的引用计数器属性用于记录对象被引用的情况</p>
<p><strong>引用计数算法的优缺点：</strong></p>
<ul>
<li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性；</li>
<li>缺点<ul>
<li>需要单独的字段存储计数器，增加了存储空间开销</li>
<li>每次赋值都需要更新计数器，增加了时间开销</li>
<li><strong>无法处理循环引用的情况</strong>（基于此Java的垃圾回收器没有使用这种算法）</li>
</ul>
</li>
</ul>
<h5 id="6-2-2-可达性分析算法（用于标记阶段）"><a href="#6-2-2-可达性分析算法（用于标记阶段）" class="headerlink" title="6.2.2 可达性分析算法（用于标记阶段）"></a>6.2.2 可达性分析算法（用于标记阶段）</h5><p><strong>可达性分析算法概念：</strong>也叫做追踪性垃圾收集，以根对象集合（GC Roots）为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达；</p>
<ul>
<li>内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径成为引用链，如果目标对象没有任何引用链相连则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象</li>
<li>GC Roots包括以下几类元素：<ul>
<li>虚拟机栈中引用的对象（如各线程被调用的方法中使用到的参数、局部变量等）</li>
<li>本地方法引用的对象</li>
<li>方法区中类静态属性引用的对象（如Java类的引用类型静态变量）</li>
<li>方法区中常量引用的对象（如字符串常量池里的引用）</li>
<li>所有被同步锁synchronized持有的对象…</li>
</ul>
</li>
</ul>
<h5 id="6-2-3-对象终止finalization机制"><a href="#6-2-3-对象终止finalization机制" class="headerlink" title="6.2.3 对象终止finalization机制"></a>6.2.3 对象终止finalization机制</h5><p><strong>对象终止机制概念：</strong>在对象被销毁之前的自定义处理逻辑，在垃圾回收此对象之前总会先调用这个对象的finalize()方法</p>
<ul>
<li>有序finalize()的存在，虚拟机中的对象一般处于三种可能的状态：<ul>
<li>可触及的：从根节点开始可以到达这个对象</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活</li>
<li>不可触及的：对象的finalize()已被调用，并且没有复活，那么就进入不可触及状态，只有不可触及才可以被回收</li>
</ul>
</li>
</ul>
<h5 id="6-2-4-标记-清除-Mark-Sweep-算法（用于清除阶段）"><a href="#6-2-4-标记-清除-Mark-Sweep-算法（用于清除阶段）" class="headerlink" title="6.2.4 标记-清除(Mark-Sweep)算法（用于清除阶段）"></a>6.2.4 标记-清除(Mark-Sweep)算法（用于清除阶段）</h5><p><strong>标记清除算法执行过程：</strong></p>
<ul>
<li>标记：收集器从引用根节点开始遍历，标记所有被引用的对象，一般是在对象头中记录为可达对象</li>
<li>清除：收集器对堆内存从头到尾进行线性遍历，如果发现某个对象在其对象头中没有标记为可达对象时则将其回收<strong>（清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表中，当有新对象需要加载时，判断被定位垃圾的位置空间是否足够，如果够就覆盖存放）</strong></li>
</ul>
<p><strong>标记清除算法缺点：</strong></p>
<p>效率不算高，而且在进行GC时需要停止整个应用程序；清除出来的空闲空间是不连续的，会产生内存碎片，需要维护一个空闲列表</p>
<h5 id="6-2-5-复制算法（用于清除阶段）"><a href="#6-2-5-复制算法（用于清除阶段）" class="headerlink" title="6.2.5 复制算法（用于清除阶段）"></a>6.2.5 复制算法（用于清除阶段）</h5><p><strong>复制算法思路：</strong>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存块中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色完成垃圾回收</p>
<p><strong>复制算法优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>没有标记和清除过程运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现碎片问题</li>
</ul>
</li>
<li>缺点：<ul>
<li>内存和时间花销极大，并且要使用该算法，要求需要复制的存活对象的数量不能太大，或者说要非常少才行</li>
</ul>
</li>
</ul>
<p><strong>复制算法应用场景：</strong>用于回收年轻代中的垃圾，如两个Survivor区(from和to区)</p>
<ul>
<li>这是因为年轻代中的存活对象时间短，所以存活对象少且垃圾对象多，所以适合使用复制算法回收；</li>
</ul>
<h5 id="6-2-6-标记-压缩-Mark-Conpact-算法（用于清除阶段）"><a href="#6-2-6-标记-压缩-Mark-Conpact-算法（用于清除阶段）" class="headerlink" title="6.2.6 标记-压缩(Mark-Conpact)算法（用于清除阶段）"></a>6.2.6 标记-压缩(Mark-Conpact)算法（用于清除阶段）</h5><p><strong>标记压缩算法执行过程：</strong></p>
<ul>
<li>标记：标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>压缩-清除：将所有的存活对象压缩到内存的一端并按顺序排放，之后清除边界外所有的空间</li>
</ul>
<p><strong>标记压缩算法优缺点：</strong></p>
<ul>
<li>优点：<ul>
<li>消除了标记清除算法中内存区域分散的缺点，需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li>
<li>消除了复制算法内存减半的代价</li>
</ul>
</li>
<li>缺点：<ul>
<li>效率低于复制算法</li>
<li>移动对象的同时如果对象被其他对象引用则还需要调整引用的地址；并且移动过程中需要全程暂停用户应用程序</li>
</ul>
</li>
</ul>
<h5 id="6-2-7-分代收集算法"><a href="#6-2-7-分代收集算法" class="headerlink" title="6.2.7 分代收集算法"></a>6.2.7 分代收集算法</h5><ul>
<li><p><strong>年轻代</strong></p>
<p>特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁</p>
<ul>
<li>基于这种情况使用<strong>复制算法</strong>回收整理速度最快，因为复制算法的效率只和当前存活对象多少有关，因此适用于年轻代回收；内存利用率不高的问题也可以通过两个Survivor的设计缓解</li>
</ul>
</li>
<li><p>老年代</p>
<p>特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p>
<ul>
<li>由于存在大量存活率高的对象，不适合使用复制算法，一般使用<strong>标记清除算法</strong>，或者<strong>标记清除与标记压缩算法混合实现</strong></li>
<li>标记阶段、压缩阶段的开销都与存活对象的数据成正比，清除阶段的开销与所管理区域的大小成正比</li>
</ul>
</li>
</ul>
<h5 id="6-2-8-增量收集算法"><a href="#6-2-8-增量收集算法" class="headerlink" title="6.2.8 增量收集算法"></a>6.2.8 增量收集算法</h5><p><strong>增量收集算法基本思想：</strong></p>
<p>如果一次性将所有的垃圾进行处理需要造成系统长时间的停顿（即处于STW状态），那么可以<strong>让垃圾收集线程和应用程序线程交替执行，垃圾收集线程每次只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复知道垃圾收集完成</strong></p>
<p><strong>增量收集算法缺点：</strong></p>
<p>虽然交替执行能减少系统的停顿时间，但线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，造成系统吞吐量下降</p>
<h5 id="6-2-9-分区算法"><a href="#6-2-9-分区算法" class="headerlink" title="6.2.9 分区算法"></a>6.2.9 分区算法</h5><p><strong>分区算法基本思想：</strong></p>
<p><strong>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间而不是整个堆空间</strong>，从而减少依次GC所产生的停顿（每个小区都独立使用和独立回收）</p>
<h4 id="6-3-垃圾回收相关概念补充"><a href="#6-3-垃圾回收相关概念补充" class="headerlink" title="6.3 垃圾回收相关概念补充"></a>6.3 垃圾回收相关概念补充</h4><h5 id="6-3-1-内存溢出与内存泄漏"><a href="#6-3-1-内存溢出与内存泄漏" class="headerlink" title="6.3.1 内存溢出与内存泄漏"></a>6.3.1 内存溢出与内存泄漏</h5><ul>
<li><p><strong>内存溢出（OOM）</strong>：指没有空闲内存，并且垃圾收集器也无法提供更多的内存的情况</p>
<p><strong>内存溢出产生原因：</strong></p>
<ul>
<li>Java虚拟机的对内存设置不够</li>
<li>代码中创建了大量大对象，并且存在被引用长时间不能被垃圾收集器收集</li>
</ul>
</li>
<li><p><strong>内存泄漏（Memory Leak）</strong>：指对象不会再被程序使用，但是垃圾收集器又不能回收它们的情况（内存泄漏可能会导致内存溢出，但不是必然的）</p>
<p><strong>内存泄漏例子：</strong></p>
<ol>
<li><p>单例模式</p>
<p>单例的生命周期和应用程序等长，所有单例程序中如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存溢出的产生</p>
</li>
<li><p>提供close()的资源未及时关闭</p>
<p>数据库连接（dataSource.getConnection()）、网络连接（Socket）和IO流必须手动close，否则是不能被回收的</p>
</li>
</ol>
</li>
</ul>
<h5 id="6-3-2-STW（Stop-The-World）"><a href="#6-3-2-STW（Stop-The-World）" class="headerlink" title="6.3.2 STW（Stop The World）"></a>6.3.2 STW（Stop The World）</h5><ul>
<li>概念：指的是GC发生过程中会产生应用程序的停顿，导致整个应用程序线程都会被暂停没有任何响应</li>
<li>STW是JVM在<strong>后台自动发起和自动完成</strong>的，在用户不可见的情况下把用户正常的工作线程全部停掉</li>
</ul>
<h5 id="6-3-3-垃圾回收的并行与并发"><a href="#6-3-3-垃圾回收的并行与并发" class="headerlink" title="6.3.3 垃圾回收的并行与并发"></a>6.3.3 垃圾回收的并行与并发</h5><ul>
<li><strong>并行</strong>：多条垃圾回收线程同时工作，此时<strong>用户线程处于等待状态</strong></li>
<li>串行：先暂停用户程序，启动JVM垃圾回收线程进行垃圾回收，回收完再启动用户程序线程</li>
<li><strong>并发</strong>：用户线程和垃圾回收线程交替执行，<strong>垃圾回收线程在执行时不会停顿用户程序的运行</strong></li>
</ul>
<h5 id="6-3-4-安全点与安全区域"><a href="#6-3-4-安全点与安全区域" class="headerlink" title="6.3.4 安全点与安全区域"></a>6.3.4 安全点与安全区域</h5><p><strong>安全点：</strong>指程序能够停顿下来开始GC的特定位置</p>
<p><strong>安全位置：</strong>指在一段代码片段中对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</p>
<h5 id="6-3-5-引用类型"><a href="#6-3-5-引用类型" class="headerlink" title="6.3.5 引用类型"></a>6.3.5 引用类型</h5><ul>
<li><p><strong>强引用：不回收</strong></p>
<p>指在程序代码之中普遍存在的引用赋值，任何情况下只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象</p>
</li>
<li><p><strong>软引用：内存不足即回收</strong></p>
<p>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常</p>
</li>
<li><p><strong>弱引用：发现即回收</strong></p>
<p>当垃圾收集器开始工作时，无论内存空间是否足够都会回收掉被弱引用关联的对象，即只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</p>
<p><strong>参考使用：WeakHashMap</strong></p>
</li>
<li><p><strong>虚引用：对象回收跟踪</strong></p>
<p>虚引用不会对对象的生存时间构成影响，也无法通过虚引用来获得一个对象的实例；为对象设置虚引用关联的目的是能够在这个对象被收集器回收时收到一个系统通知（虚引用必须和引用队列一起使用）</p>
</li>
</ul>
<h4 id="6-4-垃圾收集器"><a href="#6-4-垃圾收集器" class="headerlink" title="6.4 垃圾收集器"></a>6.4 垃圾收集器</h4><h5 id="6-4-1-GC性能指标"><a href="#6-4-1-GC性能指标" class="headerlink" title="6.4.1 GC性能指标"></a>6.4.1 GC性能指标</h5><ul>
<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间=程序运行时间+内存回收时间）</li>
<li>垃圾收集开销：垃圾收集所用时间与总运行时间的比例</li>
<li><strong>停顿时间</strong>：执行垃圾收集时程序的工作线程被暂停的时间</li>
<li>收集频率：收集操作发生的频率</li>
<li><strong>内存占用</strong>：堆区所占的内存大小</li>
</ul>
<p>标准：在最大吞吐量优先的情况下，降低停顿时间</p>
<h5 id="6-5-2-Serial回收器：串行回收"><a href="#6-5-2-Serial回收器：串行回收" class="headerlink" title="6.5.2 Serial回收器：串行回收"></a>6.5.2 Serial回收器：串行回收</h5><p>串行回收即只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时必须暂停其他所有的工作线程；</p>
<ul>
<li>Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收，作为HotSpot中Client模式下的默认新生代垃圾回收器</li>
<li>Serial Old收集器面向老年代垃圾回收，同样采用串行回收和STW机制，但内存回收算法使用标记-压缩算法</li>
<li>Serial Old收集器是Client模式下默认的老年代的垃圾回收器；在Server模式下有以下两个用途：<ul>
<li>与新生代的Parallel Scavenge收集器配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
<li>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器</li>
</ul>
<h5 id="6-5-3-ParNew回收器：并行回收（很少使用）"><a href="#6-5-3-ParNew回收器：并行回收（很少使用）" class="headerlink" title="6.5.3 ParNew回收器：并行回收（很少使用）"></a>6.5.3 ParNew回收器：并行回收（很少使用）</h5><ul>
<li>ParNew收集器采用复制算法、并行回收和STW机制的方式执行内存回收，可以看作是Serial收集器的多线程版本，作为Server模式下新生代的默认垃圾回收器</li>
<li>在单个CPU的环境下，ParNew收集器不必Serial收集器高效</li>
</ul>
<h5 id="6-5-4-Parallel-Scavenge回收器：吞吐量优先（使用频率高）"><a href="#6-5-4-Parallel-Scavenge回收器：吞吐量优先（使用频率高）" class="headerlink" title="6.5.4 Parallel Scavenge回收器：吞吐量优先（使用频率高）"></a>6.5.4 Parallel Scavenge回收器：吞吐量优先（使用频率高）</h5><ul>
<li>Parallel Scavenge收集器采用复制算法、并行回收和STW机制的方式执行内存回收，同样用于回收新生代，但与ParNew收集器不同，其目的是达到一个<strong>可控制的吞吐量</strong></li>
<li>适合在后台运算而不需要太多交互的任务，常见在服务器环境中使用（批量处理、订单处理等）</li>
<li>Parallel Old收集器采用并行回收和STW机制，但内存回收算法使用标记-压缩算法，用于执行老年代垃圾回收，在JDK1.6后用于替代Serial Old收集器</li>
</ul>
<h5 id="6-5-5-CMS回收器：低延迟（已废弃）"><a href="#6-5-5-CMS回收器：低延迟（已废弃）" class="headerlink" title="6.5.5 CMS回收器：低延迟（已废弃）"></a>6.5.5 CMS回收器：低延迟（已废弃）</h5><ul>
<li>CMS收集器采用<strong>标记清除算法</strong>、并行回收和STW机制的方式执行内存回收，其关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong></li>
<li>CMS作为老年代的垃圾收集器，无法与Parallel Scavenge回收器配合工作，当使用CMS来收集老年代时，新生代只能选择ParNew或者Serial收集器中的一个</li>
<li>CMS在进行多次GC后才进行一次碎片整理</li>
</ul>
<p><strong>CMS工作原理：</strong></p>
<p>CMS垃圾回收分为初始标记、并发标记、重新标记和并发清除4个主要阶段：</p>
<ol>
<li><strong>初始标记</strong>：<strong>仅仅只是标记出GC Roots能直接关联到的对象</strong>，需要停顿用户线程，一旦标记完成后就会恢复之前被暂停的所有应用线程，此阶段速度非常快；</li>
<li><strong>并发标记</strong>：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，此阶段耗时较长但不需要停顿用户线程；</li>
<li><strong>重新标记</strong>：<strong>修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录</strong>；</li>
<li><strong>并发清除</strong>：<strong>清理删除掉标记阶段判断已经死亡的对象，释放内存空间</strong>；</li>
</ol>
<p><strong>CMS回收器优缺点：</strong></p>
<ul>
<li>优点：并发收集、低延迟</li>
<li>缺点：<ul>
<li>由于使用标记清除算法因此会产生内存碎片，导致无法分配大对象的情况下触发Full GC</li>
<li>对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿但是会占用一部分线程导致应用程序变慢</li>
<li>无法处理浮动垃圾，<strong>如果在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记</strong>，导致这些新产生的垃圾对象没有被及时回收</li>
</ul>
</li>
</ul>
<h5 id="6-5-6-G1回收器：分区分代（JDK-9后默认垃圾回收器）"><a href="#6-5-6-G1回收器：分区分代（JDK-9后默认垃圾回收器）" class="headerlink" title="6.5.6 G1回收器：分区分代（JDK 9后默认垃圾回收器）"></a>6.5.6 G1回收器：分区分代（JDK 9后默认垃圾回收器）</h5><ul>
<li>Carbage First是一个并行回收器，把堆内存分割为很多不相关的区域，有计划地避免在堆中进行全区域的垃圾回收</li>
<li>工作原理：跟踪各个区域李的垃圾堆积的价值大小（指回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表，根据允许的收集时间，优先回收价值最大即垃圾最大量的区域</strong></li>
</ul>
<p><strong>G1回收器特点：</strong></p>
<ol>
<li><strong>并行与并发</strong><ul>
<li>并行性：回收期间可以有多个GC线程同时工作，此时用户线程STW</li>
<li>并发性：可以与用户线程交替执行，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><strong>分代收集</strong><ul>
<li>G1<strong>将堆空间分为若干个区域</strong>，这些区域包含了逻辑上的年轻代和老年代，不再要求年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量；与之前的各类回收器不同，它<strong>同时兼顾了年轻代和老年代的收集</strong></li>
</ul>
</li>
<li><strong>空间整合</strong><ul>
<li>内存的回收一区域作为基本单位，每个区域（Region）内部使用复制算法，但整体上可看作是标记压缩算法，这两种算法都可以进行碎片整理</li>
</ul>
</li>
<li><strong>可预测的停顿时间（软实时）</strong><ul>
<li><strong>能让使用者明确指定一个特定长度的时间片段内消耗在垃圾回收上的时间</strong>，每次根据允许的收集时间，优先回收价值最大的区域，保证在有限时间内获取尽可能高的收集效率</li>
</ul>
</li>
</ol>
<p>G1回收器缺点：在垃圾收集产生的内存占用、程序运行时的额外执行负担都要比其他回收器要高</p>
<p><strong>G1回收器垃圾回收过程：</strong></p>
<ul>
<li>年轻代GC<ul>
<li>当年轻代的Eden区用尽时开始年轻代回收过程，暂停所有应用程序线程执行年轻代回收，然后从Eden区移动存活对象到Survivor区，或者大对象移动到老年代区</li>
</ul>
</li>
<li>老年代并发标记过程<ul>
<li>当堆内存使用达到一定值（默认为45%）时开始老年代并发标记过程，标记完成后开始混合回收过程</li>
</ul>
</li>
<li>混合回收<ul>
<li>从老年区移动存活对象到空闲区间，这些空闲区间也成为老年代的一部分，要注意的是老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的区域即可；同时这个老年代区域是和年秦代一起被回收的</li>
</ul>
</li>
</ul>
<h5 id="6-5-7-ZGC（The-Z-Garbage-Collector）"><a href="#6-5-7-ZGC（The-Z-Garbage-Collector）" class="headerlink" title="6.5.7 ZGC（The Z Garbage Collector）"></a>6.5.7 ZGC（The Z Garbage Collector）</h5><p><strong>ZGC定义：</strong></p>
<p>基于Region内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射技术实现的，运用<strong>标记压缩算法</strong>，以低延迟为首要目标的垃圾收集器</p>
<p><strong>ZGC工作过程：</strong></p>
<p>ZGC的工作过程可分为4个阶段：<strong>并发标记、并发预备重分配、并发重分配、并发重映射</strong>，停顿时间几乎耗费在初始标记上因为初始标记是STW的</p>
<h5 id="6-5-8-GC日志分析"><a href="#6-5-8-GC日志分析" class="headerlink" title="6.5.8 GC日志分析"></a>6.5.8 GC日志分析</h5><ul>
<li>打开GC日志：-verbose：gc或者-XX：PrintGC</li>
<li>输出GC详细日志：-XX：PrintGCDetails</li>
<li>输出GC的时间戳：-XX：PrintGCTimeStamps（以基准时间形式）或者-XX：PrintGCDateStamps（以日期形式）</li>
<li>在进行GC的前后打印出堆的信息：-XX：PrintHeapAtGC</li>
<li>日志文件的输出路径：-Xloggc：../logs/gc.log</li>
</ul>
<h2 id="二、性能监控与调优"><a href="#二、性能监控与调优" class="headerlink" title="二、性能监控与调优"></a>二、性能监控与调优</h2><h3 id="1-JVM监控及诊断工具（命令行）"><a href="#1-JVM监控及诊断工具（命令行）" class="headerlink" title="1. JVM监控及诊断工具（命令行）"></a>1. JVM监控及诊断工具（命令行）</h3><h4 id="1-1-jps：查看正在运行的Java进程"><a href="#1-1-jps：查看正在运行的Java进程" class="headerlink" title="1.1 jps：查看正在运行的Java进程"></a>1.1 jps：查看正在运行的Java进程</h4><ul>
<li>-q：仅仅显示本地虚拟机唯一id，不显示主类的名称</li>
<li>-l：输出应用程序主类的全类名</li>
<li>-m：输出虚拟机进程启动时传递给主类main()的参数</li>
<li>-v：列出虚拟机进程启动时的JVM参数</li>
</ul>
<h4 id="1-2-jstat：查看JVM统计信息"><a href="#1-2-jstat：查看JVM统计信息" class="headerlink" title="1.2 jstat：查看JVM统计信息"></a>1.2 jstat：查看JVM统计信息</h4><p><strong>类装载相关的：</strong></p>
<ul>
<li>-class：显示ClassLoader的相关信息，如类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p><strong>垃圾回收相关的：</strong></p>
<ul>
<li>-gc：显示GC相关的堆信息</li>
<li>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆整个区域使用到的最大和最小空间</li>
<li>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</li>
<li>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因</li>
<li>-gcnew：显示新生代GC状况</li>
<li>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间</li>
<li>-gcold：显示老年代GC状况</li>
</ul>
<h4 id="1-3-jinfo：实时查看JVM配置参数"><a href="#1-3-jinfo：实时查看JVM配置参数" class="headerlink" title="1.3 jinfo：实时查看JVM配置参数"></a>1.3 jinfo：实时查看JVM配置参数</h4><ul>
<li>-flag 具体参数 PID：查看某个java进程的具体参数的值（PID即进程号）</li>
<li>-flags PID：查看曾经赋过值的一些参数</li>
<li>-sysprops PID：可以查看由System.getProperties()取得的参数</li>
</ul>
<h4 id="1-4-jmap：导出内存映像文件和内存使用情况"><a href="#1-4-jmap：导出内存映像文件和内存使用情况" class="headerlink" title="1.4 jmap：导出内存映像文件和内存使用情况"></a>1.4 jmap：导出内存映像文件和内存使用情况</h4><ul>
<li>-dump：生成Java堆转储快照dump文件</li>
<li>-heap：输出整个堆空间的详细信息，包括整个堆空间的详细信息，包括GC的使用、对配置信息以及内存的使用信息等</li>
<li>-histo：输出堆中对象的统计信息，包括类、实例数量和合计容量</li>
</ul>
<h4 id="1-5-jhat：JDK堆分析工具"><a href="#1-5-jhat：JDK堆分析工具" class="headerlink" title="1.5 jhat：JDK堆分析工具"></a>1.5 jhat：JDK堆分析工具</h4><h4 id="1-6-jstack：打印JVM中线程快照"><a href="#1-6-jstack：打印JVM中线程快照" class="headerlink" title="1.6 jstack：打印JVM中线程快照"></a>1.6 jstack：打印JVM中线程快照</h4><h4 id="1-7-jcmd：可用来实现前面除了jstat之外所有命令的功能"><a href="#1-7-jcmd：可用来实现前面除了jstat之外所有命令的功能" class="headerlink" title="1.7 jcmd：可用来实现前面除了jstat之外所有命令的功能"></a>1.7 jcmd：可用来实现前面除了jstat之外所有命令的功能</h4><h4 id="1-8-jstatd：远程主机信息收集"><a href="#1-8-jstatd：远程主机信息收集" class="headerlink" title="1.8 jstatd：远程主机信息收集"></a>1.8 jstatd：远程主机信息收集</h4><h3 id="2-JVM运行时参数"><a href="#2-JVM运行时参数" class="headerlink" title="2. JVM运行时参数"></a>2. JVM运行时参数</h3><h4 id="2-1-JVM参数选项类型"><a href="#2-1-JVM参数选项类型" class="headerlink" title="2.1 JVM参数选项类型"></a>2.1 JVM参数选项类型</h4><h5 id="2-1-1-类型一：标准参数选项"><a href="#2-1-1-类型一：标准参数选项" class="headerlink" title="2.1.1 类型一：标准参数选项"></a>2.1.1 类型一：标准参数选项</h5><p>特点：以-开头</p>
<h5 id="2-1-2-类型二：-X参数选项"><a href="#2-1-2-类型二：-X参数选项" class="headerlink" title="2.1.2 类型二：-X参数选项"></a>2.1.2 类型二：-X参数选项</h5><p><strong>注意：</strong>以下几个参数不属于-X参数</p>
<ul>
<li>-Xms<size>：设置初始Java堆大小，等价于-XX:InitialHeapSize</li>
<li>-Xmx<size>：设置最大Java堆大小，等价于-XX:MaxHeapSize</li>
<li>-Xss<size>：设置Java线程堆栈大小，等价于-XX:ThreadStackSize</li>
</ul>
<h5 id="2-1-3-类型三：-XX参数选项"><a href="#2-1-3-类型三：-XX参数选项" class="headerlink" title="2.1.3 类型三：-XX参数选项"></a>2.1.3 类型三：-XX参数选项</h5><p>作用：用于开发和调试JVM</p>
<p>分类：</p>
<ul>
<li>对于Boolean类型格式：<ul>
<li>-XX:+<option>表示启用option属性</li>
<li>-XX:-<option>表示禁用option属性</li>
</ul>
</li>
<li>对于非Boolean类型格式（key-value类型）：<ul>
<li>数值型格式：-XX:<option>=<number></li>
<li>非数值型格式：-XX<name>=<String></li>
</ul>
</li>
</ul>
<h4 id="2-2-常用的JVM参数选项"><a href="#2-2-常用的JVM参数选项" class="headerlink" title="2.2 常用的JVM参数选项"></a>2.2 常用的JVM参数选项</h4><h5 id="2-2-1-打印设置的XX选项及值"><a href="#2-2-1-打印设置的XX选项及值" class="headerlink" title="2.2.1 打印设置的XX选项及值"></a>2.2.1 打印设置的XX选项及值</h5><ul>
<li>-XX:+PrintCommandLineFlags：让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</li>
<li>-XX:+PrintFlagsInitial：表示打印出所有XX选项的默认值</li>
<li>-XX:+PrintFlagsFinal：表示打印出XX选项在运行程序时生效的值</li>
<li>-XX:+PrintVMOptions：打印JVM的参数</li>
</ul>
<h5 id="2-2-2-堆、栈、方法区等内存大小设置"><a href="#2-2-2-堆、栈、方法区等内存大小设置" class="headerlink" title="2.2.2 堆、栈、方法区等内存大小设置"></a>2.2.2 堆、栈、方法区等内存大小设置</h5><p><strong>对于栈内存：</strong></p>
<ul>
<li>-Xss<size>：设置Java线程堆栈大小，等价于-XX:ThreadStackSize=size</li>
</ul>
<p><strong>对于堆内存：</strong></p>
<ul>
<li>-Xms<size>：设置初始Java堆大小，等价于-XX:InitialHeapSize=size</li>
<li>-Xmx<size>：设置最大Java堆大小，等价于-XX:MaxHeapSize=size</li>
<li>-Xmn<size>：设置年轻代大小，官方推荐设置为整个堆大小的3/8</li>
<li>-XX:NewSize=size：设置年轻代初始值</li>
<li>-XX:MaxNewSize=<size>：设置年轻代最大值</li>
<li>-XX:SurvivorRatio=<ratio>：设置年轻代中Eden区和一个Survivor区的比值，默认值是8</li>
<li>-XX:+UseAdaptiveSizePolicy：自动选择各区大小比例</li>
<li>-XX:NewRatio=<ratio>：设置老年代与年轻代（1个Eden区和2个Survivor区）的比值，默认值是2</li>
<li>-XX:PretenureSizeThreadshold=<size>：设置让大于此阈值的对象直接分配在老年代，单位为字节（注意只对Serial、ParNew收集器有效）</li>
<li>-XX:MaxTenuringThreshold=<time>：最大记录年龄，默认值是15，新生代每次MinorGC后还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代</li>
<li>-XX:+PrintTenuringDistribution：让JVM在每次MinorGC后打印出当前Survivor中对象的年龄分布</li>
<li>-XX:TargetSurvivorRatio=<ratio>：表示MinorGC结束后Survivor区域中占用空间的期望比例</li>
</ul>
<p><strong>对于方法区/元空间：</strong></p>
<ul>
<li>-XX:MetaspaceSize：设置初始空间大小</li>
<li>-XX:MaxMetaspaceSize：设置最大空间，默认没有限制</li>
<li>-XX:+UseCompressedOops：压缩对象指针</li>
<li>-XX:+UseCompressedClassPointers：压缩类指针</li>
<li>-XX:CompressedClassSpaceSize：设置Class Metaspace的大小，默认是1G</li>
<li>-XX:MaxDirectMemorySize：指定直接内存容量，若未指定默认与堆最大值一样</li>
</ul>
<h5 id="2-2-3-OutofMemory相关选项"><a href="#2-2-3-OutofMemory相关选项" class="headerlink" title="2.2.3 OutofMemory相关选项"></a>2.2.3 OutofMemory相关选项</h5><ul>
<li><p>-XX:+HeapDumpOnOutOfMemoryError：表示在内存出现OOM的时候，把Heap转储到文件（Dump文件）以便后续分析</p>
</li>
<li><p>-XX:+HeapDumpBeforeFullGC：表示在出现FullGC之前，生成Heap转储文件</p>
</li>
<li><p>-XX:HeapDumpPath=<path>：指定Heap转储文件的存储路径</p>
</li>
<li><p>-XX:OnOutOfMemoryError：指定一个可行性程序或者脚本的路径，当发生OOM时去执行这个脚本</p>
</li>
</ul>
<h5 id="2-2-4-垃圾回收器相关选项"><a href="#2-2-4-垃圾回收器相关选项" class="headerlink" title="2.2.4 垃圾回收器相关选项"></a>2.2.4 垃圾回收器相关选项</h5><p><strong>对于Parallel回收器：</strong></p>
<ul>
<li>-XX:ParallelGCThreads：设置年轻代并行回收器的线程数，一般最好与CPU数量相等</li>
<li>-XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间，单位是毫秒</li>
<li>-XX:GCTimeRatio：垃圾收集时间占总时间的比例，，默认垃圾回收时间不超过1%，用于衡量吞吐量的大小</li>
<li>-XX:+UseAdaptiveSizePolicy：设置Parallel收集器具有<strong>自适应调节策略</strong></li>
</ul>
<p><strong>对于G1回收器：</strong></p>
<ul>
<li>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，默认值是200ms</li>
<li>-XX:ParallelGCThread：设置STW时GC线程数的值，最多设置为8</li>
<li>-XX:ConcGCThreads：设置并发标记的线程数</li>
<li>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值，超过此值就触发GC，默认值是45</li>
<li>-XX:G1NewSizePercent、-XX:G1MaxNewSizePercent：新生代占用整个对内存的最小百分比（默认5%）、最大百分比（默认60%）</li>
<li>-XX:G1ReservePercent=<percent>：保留内存区域，防止Survivor中的to区溢出</li>
</ul>
<h5 id="2-2-5-GC日志相关选项"><a href="#2-2-5-GC日志相关选项" class="headerlink" title="2.2.5 GC日志相关选项"></a>2.2.5 GC日志相关选项</h5><ul>
<li>-verbose:gc：输出gc日志信息，默认输出到标准输出</li>
<li>-XX:+PrintGC：表示打开简化的GC日志</li>
<li>XX:+PrintGCDetails：打印内存回收详细日志并在进程退出时输出当前内存各区域分配情况</li>
<li>XX:+PrintGCTimeStamps：输出GC发生时的时间戳</li>
<li>XX:+PrintGCDataStamps：以日期格式输出GC发生时的时间戳</li>
<li>-XX:+PrintHeapAtGC：每一次GC前和GC后都打印堆信息</li>
<li>-Xloggc:<file>：把GC日志写入到一个文件中，而不是打印到标准输出中</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程和JUC并发编程学习笔记</title>
    <url>/2021/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习多线程和并发编程时记录的笔记，仅涉及并发编程的基础知识</p>
<span id="more"></span>

<h2 id="1-JUC概述"><a href="#1-JUC概述" class="headerlink" title="1. JUC概述"></a>1. JUC概述</h2><h3 id="1-1-什么是JUC"><a href="#1-1-什么是JUC" class="headerlink" title="1.1 什么是JUC"></a>1.1 什么是JUC</h3><p>JUC就是java.util.concurrent工具包的简称，是Java中一个处理线程的工具包；</p>
<h3 id="1-2-线程和进程相关概念"><a href="#1-2-线程和进程相关概念" class="headerlink" title="1.2 线程和进程相关概念"></a>1.2 线程和进程相关概念</h3><h4 id="1-2-1-线程和进程"><a href="#1-2-1-线程和进程" class="headerlink" title="1.2.1 线程和进程"></a>1.2.1 线程和进程</h4><ul>
<li>进程：是系统进行资源分配和调度的基本单位，进程是程序的实体，同时也是线程的容器；</li>
<li>线程：是操作系统能够进行运算调度的最小单位，被包含在进程中，是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流，在一个进程中可以并发多个线程，每条线程并行执行不同的任务；</li>
</ul>
<h4 id="1-2-2-wait-和sleep-的区别"><a href="#1-2-2-wait-和sleep-的区别" class="headerlink" title="1.2.2 wait()和sleep()的区别"></a>1.2.2 wait()和sleep()的区别</h4><ul>
<li>相同点：一旦执行方法，都可以使得当前的进程进入阻塞状态；</li>
<li>不同点：<ol>
<li>两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()；</li>
<li>调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须在同步代码块或同步方法中调用；</li>
<li>关于是否释放同步监视器：如果两个方法都是用在同步代码块或同步方法中，sleep()不会释放，wait()会释放；</li>
</ol>
</li>
</ul>
<h4 id="1-2-3-notify-和notifyAll-区别"><a href="#1-2-3-notify-和notifyAll-区别" class="headerlink" title="1.2.3 notify()和notifyAll()区别"></a>1.2.3 notify()和notifyAll()区别</h4><ul>
<li>notify( )：一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的那个；</li>
<li>notifyAll( )：一旦执行此方法，就会唤醒所有被wait的线程；</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>这两个方法必须使用在同步代码块或同步方法中；</li>
<li>这两个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现异常；</li>
</ol>
<h4 id="1-2-4-线程状态"><a href="#1-2-4-线程状态" class="headerlink" title="1.2.4 线程状态"></a>1.2.4 线程状态</h4><p>线程在一定条件下状态会发生变化。线程一共有以下几种状态：</p>
<ol>
<li>**新建状态(New)**：新创建线程对象，如Thread thread = new Thread()。</li>
<li><strong>就绪状态(Runnable)<strong>：线程对象创建后，其他线程调用了thread.start()。该状态的线程位于“</strong>可运行线程池</strong>”中，变得可运行，只等待获取CPU的使用权<strong>。</strong>即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</li>
<li>**运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。</li>
<li>**阻塞状态(Blocked)**：线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</li>
</ol>
<ul>
<li><strong>阻塞的情况分三种：</strong><ul>
<li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“<strong>等待池”</strong>中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</li>
<li>同步阻塞：运行的线程在获取对象的synchronized同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入<strong>“锁池”</strong>中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>**死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h3 id="1-3-并发与并行"><a href="#1-3-并发与并行" class="headerlink" title="1.3 并发与并行"></a>1.3 并发与并行</h3><ul>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
</ul>
<h3 id="1-4-同步和异步"><a href="#1-4-同步和异步" class="headerlink" title="1.4 同步和异步"></a>1.4 同步和异步</h3><ul>
<li>同步：指发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 </li>
<li>异步：指发送方发出数据后，不等接收方发回响应，就直接接着发送下个数据包的通讯方式。</li>
</ul>
<h3 id="1-5-管程"><a href="#1-5-管程" class="headerlink" title="1.5 管程"></a>1.5 管程</h3><p>管程（Monitor，又称为监视器）即所说的锁，是一种同步机制，保证在同一个时间只有一个线程能去访问被保护的数据或者代码，JVM同步基于进入和退出，使用管程对象实现的，即加锁和解锁操作；</p>
<h3 id="1-6-用户线程和守护线程"><a href="#1-6-用户线程和守护线程" class="headerlink" title="1.6 用户线程和守护线程"></a>1.6 用户线程和守护线程</h3><ul>
<li><p>如果JVM中所有的线程都是守护线程，那么JVM就会退出，进而守护线程也会退出；如果JVM中还存在用户线程，那么JVM就会一直存活，不会退出。</p>
<ul>
<li>守护线程：依赖于用户线程，用户线程退出了，守护线程也就会退出，典型的守护线程如垃圾回收线程。</li>
<li>用户线程：是独立存在的，不会因为其他用户线程退出而退出。</li>
</ul>
</li>
</ul>
<h2 id="2-Lock接口（Lock锁）"><a href="#2-Lock接口（Lock锁）" class="headerlink" title="2. Lock接口（Lock锁）"></a>2. Lock接口（Lock锁）</h2><h3 id="2-1-Synchronized关键字"><a href="#2-1-Synchronized关键字" class="headerlink" title="2.1 Synchronized关键字"></a>2.1 Synchronized关键字</h3><ol>
<li><p>修饰一个代码块时，被修饰的代码块称为同步代码块，其作用的范围是大括号{}中的代码，作用的对象是这个代码块的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">synchronized</span> (同步监视器) &#123;</span><br><span class="line"> 	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：<span class="number">1.</span>操作共享数据的代码，即为需要被同步的代码；</span><br><span class="line">     <span class="number">2.</span>共享数据：多个线程共同操作的变量；</span><br><span class="line">     <span class="number">3.</span>同步监视器，俗称：锁，任何一个类的对象都能充当锁，但要求多个线程必须要共用同一把锁；</span><br><span class="line">补充：实现Runnable接口创建方式，锁可以考虑用实现类对象<span class="built_in">this</span>表示，此时的<span class="built_in">this</span>必须是唯一的实现类的对象；</span><br><span class="line">     在继承Thread类创建多线程的方式中，慎用<span class="built_in">this</span>充当同步监视器，考虑使用当前类充当同步监视器；  </span><br></pre></td></tr></table></figure></li>
<li><p>修饰一个方法时，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">权限修饰符 <span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名() &#123;</span><br><span class="line">    <span class="comment">//操作共享数据的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"><span class="number">1.</span>同步方法仍然涉及到同步监视器，只是不需要显式声明；</span><br><span class="line"><span class="number">2.</span>非静态同步方法，同步监视器是实现类对象：<span class="built_in">this</span></span><br><span class="line">  静态同步方法，同步监视器是当前类本身：类名.class</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-多线程编程步骤"><a href="#2-2-多线程编程步骤" class="headerlink" title="2.2 多线程编程步骤"></a>2.2 多线程编程步骤</h3><p>第一步：创建资源类，在资源类创建属性和操作方法；</p>
<p>第二步：在资源类操作方法</p>
<p>第三步：创建多个线程，调用资源类的操作方法；</p>
<p>第四步：判断条件写到while中防止虚假唤醒问题；</p>
<h3 id="2-3-Lock接口概述"><a href="#2-3-Lock接口概述" class="headerlink" title="2.3 Lock接口概述"></a>2.3 Lock接口概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="number">1.</span>实现类实例化可重入锁ReentrantLock属性：<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>( )</span><br><span class="line"><span class="number">2.</span>重写的run( )中调用锁定方法Lock( )，使后续的代码单线程实现</span><br><span class="line"><span class="number">3.</span>调用解锁方法unlock( )</span><br></pre></td></tr></table></figure>

<p><strong>Synchronized和Lock的区别：</strong></p>
<ul>
<li>相同点：二者都可以解决线程安全问题；</li>
<li>不同点：<ol>
<li>synchronized机制在执行完相应的同步代码后，自动地释放同步监视器，而Lock需要手动的启动同步（Lock( )），同时结束同步也需要手动的实现（unlock( )，建议在finally块中释放锁避免出现死锁；</li>
<li>synchronized是Java的关键字，而Lock是一个类，通过这个类可以实现同步访问；</li>
</ol>
</li>
</ul>
<h3 id="2-4-创建线程的多种方式"><a href="#2-4-创建线程的多种方式" class="headerlink" title="2.4 创建线程的多种方式"></a>2.4 创建线程的多种方式</h3><h4 id="2-4-1-继承Thread类"><a href="#2-4-1-继承Thread类" class="headerlink" title="2.4.1 继承Thread类"></a>2.4.1 继承Thread类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个继承于Thread类的子类；</span><br><span class="line"><span class="number">2.</span>重写Thread类的run( )，将此线程执行的操作声明在run( )中;</span><br><span class="line"><span class="number">3.</span>创建Thread类的子类的对象;</span><br><span class="line"><span class="number">4.</span>通过此对象调用start( );</span><br><span class="line">	① 启动当前线程；</span><br><span class="line">	② 调用当前线程的run( )方法 ;</span><br><span class="line"></span><br><span class="line">注意点：</span><br><span class="line"><span class="number">1.</span>我们不能通过直接调用run( )的方式启动线程，必须通过对象.start( )的方式；</span><br><span class="line"><span class="number">2.</span>再启动一个线程时，需要重新创建一个线程的对象去start( )执行；</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-实现Runnable接口"><a href="#2-4-2-实现Runnable接口" class="headerlink" title="2.4.2 实现Runnable接口"></a>2.4.2 实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个实现了Runnable接口的类；</span><br><span class="line"><span class="number">2.</span>实现类去实现Runnable中的抽象方法：run( )</span><br><span class="line"><span class="number">3.</span>创建实现类的对象；</span><br><span class="line"><span class="number">4.</span>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象；</span><br><span class="line"><span class="number">5.</span>通过Thread类的对象调用start( )，在start( )中调用了Runnable类型target的run( )</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用匿名内部类方式进行实现：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//大括号中调用具体方法</span></span><br><span class="line">&#125;).start(); </span><br></pre></td></tr></table></figure>

<p><strong>比较继承Thread类和实现Runnable接口这两种创建方式：</strong>两种方式都需要重写run( )，但开发中优先选择实现Runnable接口的方式<br><strong>原因：</strong></p>
<ol>
<li>实现的方式没有类的单继承性的局限性；</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况；</li>
</ol>
<h4 id="2-4-3-使用Callable接口（详情后续章节讲解）"><a href="#2-4-3-使用Callable接口（详情后续章节讲解）" class="headerlink" title="2.4.3 使用Callable接口（详情后续章节讲解）"></a>2.4.3 使用Callable接口（详情后续章节讲解）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个实现Callable的实现类；</span><br><span class="line"><span class="number">2.</span>实现call( )方法，将此线程需要执行的操作声明在call( )中，可以有返回值；</span><br><span class="line"><span class="number">3.</span>创建Callable接口实现类的对象；</span><br><span class="line"><span class="number">4.</span>将此Callable接口实现类的对象作为参数传递到FutureTask的构造器中，创建FutureTask的对象；</span><br><span class="line"><span class="number">5.</span>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start( )方法；</span><br><span class="line"><span class="number">6.</span>获取Callable中call方法的返回值，get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用匿名实现类方式进行实现：</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>(</span><br><span class="line">        () -&gt; <span class="keyword">return</span> 返回值</span><br><span class="line">    )).start(); </span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-使用ThreadPool线程池（详情后续章节讲解）"><a href="#2-4-4-使用ThreadPool线程池（详情后续章节讲解）" class="headerlink" title="2.4.4 使用ThreadPool线程池（详情后续章节讲解）"></a>2.4.4 使用ThreadPool线程池（详情后续章节讲解）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤</span><br><span class="line"><span class="number">1.</span>提供指定线程数量的线程池</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(线程数量)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象；</span><br><span class="line">executorService.execute(实现类对象)：适用于Runnable接口</span><br><span class="line">executorService.submit(实现类对象)：适用于Callable接口</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭连接池</span><br><span class="line">executorService.shutdown( )；</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">使用线程池方法的好处：</span><br><span class="line"><span class="comment">//提前创建多个线程放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁，实现重复利用；</span></span><br><span class="line"><span class="number">1.</span>提高响应速度，减少创建新线程的时间</span><br><span class="line"><span class="number">2.</span>降低资源消耗（重读利用线程池中的线程，不需要每次都创建）</span><br><span class="line"><span class="number">3.</span>便于线程管理</span><br></pre></td></tr></table></figure>



<h2 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h2><p>线程间通信定义：当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。</p>
<h3 id="3-1-虚假唤醒问题"><a href="#3-1-虚假唤醒问题" class="headerlink" title="3.1 虚假唤醒问题"></a>3.1 虚假唤醒问题</h3><p><strong>概念：</strong>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功；</p>
<p><strong>解决方法：</strong>当有两个线程调用相同的方法时，线程唤醒调用了<code>notifyAll()</code>方法，会唤醒所有线程，这两条线程都会被唤醒，如果用<code>if</code>，因为<code>if</code>只会执行一次，这就会不进行条件判断直接执行下一步的代码，造成了线程虚假唤醒问题；如果用<code>while</code>，线程虽然被唤醒，但还是会进行循环判断直到满足才执行，就避免了线程虚假唤醒的问题；</p>
<h3 id="3-2-线程间通信方式"><a href="#3-2-线程间通信方式" class="headerlink" title="3.2 线程间通信方式"></a>3.2 线程间通信方式</h3><p>首先线程通信的模型主要可以分为两种，分别为<strong>共享内存</strong>和<strong>消息传递</strong>，以下方式都是基于这两种模型来实现的：</p>
<p>以一道实际题目为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">有两个线程A、B，A线程向一个集合里面依次添加元素&quot;abc&quot;字符串，一共添加十次，当添加到第五次的时候，希望B线程能够收到A线程的通知，然后B线程执行相关的业务操作。</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-共享内存"><a href="#3-2-1-共享内存" class="headerlink" title="3.2.1 共享内存"></a>3.2.1 共享内存</h4><p><strong>思路：</strong>线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信；</p>
<h5 id="方式一：使用volatile关键字"><a href="#方式一：使用volatile关键字" class="headerlink" title="方式一：使用volatile关键字"></a>方式一：使用volatile关键字</h5><p>基于<strong>volatile</strong> 关键字来实现线程间相互通信是使用<strong>共享内存</strong>的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个共享变量来实现通信，必须是volatile修饰的，否则线程不能及时感知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">notice</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//修改共享变量值</span></span><br><span class="line">                    notice = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (notice) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方式二：使用JUC中的类-CountDownLatch（详情后续章节讲解）"><a href="#方式二：使用JUC中的类-CountDownLatch（详情后续章节讲解）" class="headerlink" title="方式二：使用JUC中的类 CountDownLatch（详情后续章节讲解）"></a>方式二：使用JUC中的类 CountDownLatch（详情后续章节讲解）</h5><p>CountDownLatch基于AQS框架，相当于也是维护了一个线程间共享变量state。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建countDownLatch对象并设置计数器初始值</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//计数器减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	countDownLatch.await();</span><br><span class="line">                	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    	e.printStackTrace();</span><br><span class="line">                	&#125; </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-消息传递"><a href="#3-2-2-消息传递" class="headerlink" title="3.2.2 消息传递"></a>3.2.2 消息传递</h4><h5 id="方式三：wait-notify-结合synchronized等待通知方式"><a href="#方式三：wait-notify-结合synchronized等待通知方式" class="headerlink" title="方式三：wait()/notify()结合synchronized等待通知方式"></a>方式三：wait()/notify()结合synchronized等待通知方式</h5><p>使用Object类的wait() 和 notify() 方法基于线程间消息传递的思想，但要注意wait()和 notify()必须配合synchronized使用，wait())释放锁，而notify()不释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestSync.class) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                	list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                	System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                	<span class="keyword">try</span> &#123;</span><br><span class="line">                    	Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    	e.printStackTrace();</span><br><span class="line">                	&#125;</span><br><span class="line">                	<span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    	<span class="comment">//唤醒线程B</span></span><br><span class="line">                        lock.notify();</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestSync.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    	<span class="keyword">try</span> &#123;</span><br><span class="line">                    		lock.wait();</span><br><span class="line">                		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    		e.printStackTrace();</span><br><span class="line">                		&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方式四：使用-Lock接口中的ReentrantLock结合-Condition"><a href="#方式四：使用-Lock接口中的ReentrantLock结合-Condition" class="headerlink" title="方式四：使用 Lock接口中的ReentrantLock结合 Condition"></a>方式四：使用 Lock接口中的ReentrantLock结合 Condition</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    condition.singal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="4-集合的线程安全"><a href="#4-集合的线程安全" class="headerlink" title="4. 集合的线程安全"></a>4. 集合的线程安全</h2><h4 id="4-1-线程安全问题"><a href="#4-1-线程安全问题" class="headerlink" title="4.1 线程安全问题"></a>4.1 线程安全问题</h4><p><strong>问题出现原因：</strong>当某个线程操作共享数据的过程中，尚未操作完成时，其他线程也参与进来操作同一份共享数据；</p>
<p><strong>解决思路：</strong>当一个线程a在操作共享数据时，其他进程不能参与进来，直到线程a操作完共享数据时线程才可以操作共享数据，这种情况即使线程a出现了阻塞也不能被改变；</p>
<h4 id="4-2-ArrayList集合线程不安全和解决方案"><a href="#4-2-ArrayList集合线程不安全和解决方案" class="headerlink" title="4.2 ArrayList集合线程不安全和解决方案"></a>4.2 ArrayList集合线程不安全和解决方案</h4><p>ArrayList在向集合添加内容的同时从集合中获取内容可能会产生并发修改问题（ConcurrentModificationException），可见ArrayList是线程不安全的；</p>
<p><strong>解决方案：</strong></p>
<h5 id="方案一：将ArrayList替换成Vector（现在基本不用）"><a href="#方案一：将ArrayList替换成Vector（现在基本不用）" class="headerlink" title="方案一：将ArrayList替换成Vector（现在基本不用）"></a>方案一：将ArrayList替换成Vector（现在基本不用）</h5><h5 id="方案二：套用Collections工具类中的synchronizedList（现在很少使用）"><a href="#方案二：套用Collections工具类中的synchronizedList（现在很少使用）" class="headerlink" title="方案二：套用Collections工具类中的synchronizedList（现在很少使用）"></a>方案二：套用Collections工具类中的synchronizedList（现在很少使用）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h5 id="方案三：使用JUC中的类CopyOnWriteArrayList"><a href="#方案三：使用JUC中的类CopyOnWriteArrayList" class="headerlink" title="方案三：使用JUC中的类CopyOnWriteArrayList"></a>方案三：使用JUC中的类CopyOnWriteArrayList</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList实现了写时复制技术，读的过程是并发读，写的过程是先复制一份与原本集合相同的新集合后，往新集合中写入新内容，写入新内容结束后新集合再与原本集合合并，之后读的过程就读取合并的新集合。</p>
<h4 id="4-3-HashSet集合线程不安全和解决方案"><a href="#4-3-HashSet集合线程不安全和解决方案" class="headerlink" title="4.3 HashSet集合线程不安全和解决方案"></a>4.3 HashSet集合线程不安全和解决方案</h4><h5 id="解决方案：使用JUC中的类CopyOnWriteArraySet"><a href="#解决方案：使用JUC中的类CopyOnWriteArraySet" class="headerlink" title="解决方案：使用JUC中的类CopyOnWriteArraySet"></a>解决方案：使用JUC中的类CopyOnWriteArraySet</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="4-4-HashMap集合线程不安全和解决方案"><a href="#4-4-HashMap集合线程不安全和解决方案" class="headerlink" title="4.4 HashMap集合线程不安全和解决方案"></a>4.4 HashMap集合线程不安全和解决方案</h4><h5 id="解决方案：使用JUC中的类ConcurrentHashMap"><a href="#解决方案：使用JUC中的类ConcurrentHashMap" class="headerlink" title="解决方案：使用JUC中的类ConcurrentHashMap"></a>解决方案：使用JUC中的类ConcurrentHashMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h2 id="5-多线程锁"><a href="#5-多线程锁" class="headerlink" title="5. 多线程锁"></a>5. 多线程锁</h2><h4 id="5-1-synchronized锁的情况"><a href="#5-1-synchronized锁的情况" class="headerlink" title="5.1 synchronized锁的情况"></a>5.1 synchronized锁的情况</h4><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为以下三种方式：</p>
<ul>
<li>对于普通同步方法，所示当前实例对象；</li>
<li>对于静态同步方法，锁是当前类的Class对象；</li>
<li>对于同步代码块，锁是Synchonized()括号中配置的对象；</li>
</ul>
<h4 id="5-2-锁的分类"><a href="#5-2-锁的分类" class="headerlink" title="5.2 锁的分类"></a>5.2 锁的分类</h4><h5 id="一、公平锁与非公平锁"><a href="#一、公平锁与非公平锁" class="headerlink" title="一、公平锁与非公平锁"></a>一、公平锁与非公平锁</h5><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁，效率比非公平锁低。</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。其执行效率高，但可能会造成优先级反转或者饥饿现象。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言：</strong></p>
<p>　　对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p>
<p>　　对于Synchronized而言，也是一种非公平锁，但由于其并不像ReentrantLock是通过AQS来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h5 id="二、可重入锁"><a href="#二、可重入锁" class="headerlink" title="二、可重入锁"></a>二、可重入锁</h5><ul>
<li>可重入锁又名<strong>递归锁</strong>，是指在同一个线程中，在外层方法获取锁的时候，进入内层方法会自动获取锁。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言</strong>：它们都是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>
<h5 id="三、独占锁和共享锁（详情后续章节讲解）"><a href="#三、独占锁和共享锁（详情后续章节讲解）" class="headerlink" title="三、独占锁和共享锁（详情后续章节讲解）"></a>三、独占锁和共享锁（详情后续章节讲解）</h5><p><strong>AQS</strong>：抽象队列同步器，简单来说AQS就是一个抽象类AbstractQueuedSynchronizer，没有实现任何的接口，仅仅定义了同步状态state的获取和释放的方法。它还提供了一个FIFO队列（先进先出），多线程竞争资源的时候，没有竞争到的线程就会进入队列中进行等待，并且定义了一套多线程访问共享资源的同步框架。</p>
<p>在AQS中的锁类型有两种：分别是Exclusive(独占锁)和Share(共享锁)。</p>
<ul>
<li>独占锁是指该锁一次只能被一个线程所持有。</li>
<li>共享锁是指该锁可被多个线程所持有。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言：</strong></p>
<p>　　对于Java ReentrantLock而言其是独占锁。但是对于Lock接口的另一个实现类ReadWriteLock而言，其读锁是共享锁，其写锁是独占锁。读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。独占锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>　　对于Synchronized而言其是独占锁。</p>
<h4 id="5-3-一些锁的概念"><a href="#5-3-一些锁的概念" class="headerlink" title="5.3 一些锁的概念"></a>5.3 一些锁的概念</h4><h5 id="一、偏向锁、轻量级锁和重量级锁"><a href="#一、偏向锁、轻量级锁和重量级锁" class="headerlink" title="一、偏向锁、轻量级锁和重量级锁"></a>一、偏向锁、轻量级锁和重量级锁</h5><p>这三种锁是指锁的状态，并且是<strong>只针对Synchronized</strong>而言的。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>
<ul>
<li><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
</li>
<li><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
</li>
<li><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p>
</li>
</ul>
<h5 id="二、乐观锁和悲观锁"><a href="#二、乐观锁和悲观锁" class="headerlink" title="二、乐观锁和悲观锁"></a>二、乐观锁和悲观锁</h5><p>乐观锁与悲观锁并不是特指某两种类型的锁，只是人们定义出来的概念或思想，主要是指如何看待并发同步的角度。</p>
<ul>
<li><p>乐观锁：乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。</p>
<ul>
<li><p>数据版本机制</p>
<p>实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 核心<span class="keyword">SQL</span>代码如下：</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> xxx<span class="operator">=</span>#&#123;xxx&#125;, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>CAS操作</strong></p>
<p>CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p>
</li>
</ul>
</li>
<li><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
</li>
</ul>
<p><strong>使用说明：</strong></p>
<ol>
<li>悲观锁适合<code>写操作非常多</code>的场景；乐观锁适合<code>读操作非常多</code>的场景，不加锁会带来大量的性能提升。</li>
<li>悲观锁在Java中的使用，就是利用各种锁，比如Java里面的同步原语synchronized关键字的实现就是悲观锁。；乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
</ol>
<h5 id="三、自旋锁"><a href="#三、自旋锁" class="headerlink" title="三、自旋锁"></a>三、自旋锁</h5><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<h4 id="5-4-死锁"><a href="#5-4-死锁" class="headerlink" title="5.4 死锁"></a>5.4 死锁</h4><ul>
<li>死锁：两个或两个以上进程分别占用对方的同步资源不放弃，都在互相等待对方放弃自己需要的同步资源，就形成了线程的死锁，死锁时线程处于阻塞状态；</li>
</ul>
<h5 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h5><ol>
<li><p>竞争资源</p>
<ul>
<li>竞争不可剥夺资源（指当系统资源分配给某进程后，不能强行收回，只能在进程用完后自行释放的资源，如打印机等。）</li>
<li>竞争临时资源（指由一个进程产生，被另一个进程使用，短时间后便无用的资源，故也称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等。）</li>
</ul>
</li>
<li><p>进程间推进顺序非法</p>
<p>若P1保持了资源R1，将因R2已被P2占用而阻塞；P2保持了资源R2，也将因R1已被P1占用而阻塞，于是发生进程死锁。</p>
</li>
</ol>
<h5 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h5><ol>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求与保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h5 id="一个死锁的实现例子"><a href="#一个死锁的实现例子" class="headerlink" title="一个死锁的实现例子"></a>一个死锁的实现例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(str1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str1&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span>(str2)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str2&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(str2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str2&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span>(str1)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str1&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码解释：</span></span><br><span class="line"><span class="comment">程序中有两个线程，分别是线程a和线程b，线程a锁住了str1,获得锁之后休眠1秒钟，同时线程b锁住了str2后,也进行休眠操作。当线程a休眠完了之后去锁str2，但是str2已经被线程b给锁住了，这边只能等待，同样的线程b休眠完之后也要去锁str1，但是str1已经被线程a给锁住了，同样也只能等待，处于永远互相等待的状态这样就产生了死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><p><strong>一、预防死锁：破坏必要条件之一</strong></p>
<ol>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不剥夺条件）</li>
<li>资源有序分配：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏循环等待条件）</li>
</ol>
<p><strong>二、避免死锁</strong></p>
<ol>
<li><p>以确定的顺序获得锁</p>
<p>如果必须获取多个锁，可以使用<code>银行家算法</code>进行解决，所有的锁都按照特定的顺序获取。</p>
</li>
<li><p>超时放弃锁</p>
<p>Lock接口提供了<code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁，通过这种方式，也可以很有效地避免死锁。 </p>
</li>
</ol>
<p><strong>三、解除死锁</strong></p>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ol>
<li>剥夺并赋予资源：从其它进程剥夺足够数量的资源给死锁进程以解除死锁状态。</li>
<li>撤消死锁进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用使死锁状态消除为止。</li>
</ol>
<p><strong>四、Java中死锁情况排查步骤</strong></p>
<ol>
<li><strong>jps -l：命令定位进程号</strong></li>
<li><strong>jstack 进程号：找到死锁并查看情况</strong></li>
</ol>
<h2 id="6-Callable接口"><a href="#6-Callable接口" class="headerlink" title="6. Callable接口"></a>6. Callable接口</h2><h4 id="6-1-Runnable接口与Callable接口对比"><a href="#6-1-Runnable接口与Callable接口对比" class="headerlink" title="6.1 Runnable接口与Callable接口对比"></a>6.1 Runnable接口与Callable接口对比</h4><ol>
<li>是否有返回值：Runnable接口没有返回值，Callable接口有返回值；</li>
<li>是否会抛出异常：Runnable接口如果无法实现不会抛出异常，而Callable接口会抛出异常；</li>
<li>实现方法不同。Runnable接口使用run()，Callable接口使用call()；</li>
<li>运行Callable可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ol>
<h4 id="6-2-Future接口"><a href="#6-2-Future接口" class="headerlink" title="6.2 Future接口"></a>6.2 Future接口</h4><p>Future是一个接口，代表了一个异步计算的结果，它定义了5个方法：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptInRunning)</code>：取消一个任务，并返回取消结果，参数表示是否中断线程。</li>
<li><code>boolean isCancelled()</code>：判断任务是否被取消。</li>
<li><code>Boolean isDone()</code>：判断当前任务是否执行完毕，包括正常执行完毕、执行异常或者任务取消。</li>
<li><code>V get()</code>：获取任务执行结果，任务结束之前会阻塞。</li>
<li><code>V get(long timeout, TimeUnit unit)</code>：在指定时间内尝试获取执行结果。若超时则抛出超时异常</li>
</ul>
<h4 id="6-3-FutureTask类"><a href="#6-3-FutureTask类" class="headerlink" title="6.3 FutureTask类"></a>6.3 FutureTask类</h4><p><strong>类继承结构</strong></p>
<ul>
<li><p>FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既可以作为Runnable被Thread执行，也可以获取Future异步执行的结果；</p>
</li>
<li><p>FutureTask有两个构造方法，一个接收Callable的参数实例，另一个接收Runnable的参数实例，当传入的参数是Runnable时，也会通过**<code>Executors.callable(runnable, result)</code>**方法将其转成Callable类型（即无论哪个构造方法最终都是执行Callable类型的任务），返回值类型为V（指定的泛型类型）；</p>
</li>
</ul>
<h2 id="7-JUC辅助类"><a href="#7-JUC辅助类" class="headerlink" title="7. JUC辅助类"></a>7. JUC辅助类</h2><h4 id="7-1-减少计数CountDownLatch"><a href="#7-1-减少计数CountDownLatch" class="headerlink" title="7.1 减少计数CountDownLatch"></a>7.1 减少计数CountDownLatch</h4><p>CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行减1操作，使await方法等待计数器不大于0，然后继续执行await方法之后的语句；</p>
<ul>
<li>CountDownLatch主要有两个方法countDown和await，当一个或多个线程调用<code>await()</code>方法时，这些方法会阻塞，其他线程调用<code>countDown()</code>方法会将计数器减1，调用countDown方法的线程不会阻塞，当计数器的值变为0时，因await方法阻塞的线程会被唤醒继续执行；</li>
</ul>
<h4 id="7-2-循环栅栏CyclicBarrier"><a href="#7-2-循环栅栏CyclicBarrier" class="headerlink" title="7.2 循环栅栏CyclicBarrier"></a>7.2 循环栅栏CyclicBarrier</h4><p>CyclicBarrier的构造方法**<code>CyclicBarrier(int parties, Runnable barrierAction)</code>**第一个参数是目标障碍数，每次执行CyclicBarrier障碍数会加1，只有达到了目标障碍数才会启动，执行cyclicBarrier.await()之后的语句。可以将CyclicBarrier理解为加1操作；</p>
<h4 id="7-3-信号灯Semaphore"><a href="#7-3-信号灯Semaphore" class="headerlink" title="7.3 信号灯Semaphore"></a>7.3 信号灯Semaphore</h4><p>Semaphore管理一系列许可证，每个acquire()方法阻塞，直到有一个许可证可以获得，然后拿走一个许可证；每个release()方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。</p>
<p><strong>Semaphore的主要方法如下：</strong></p>
<ul>
<li><p><code>void acquire()</code>：从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</p>
<ol>
<li><p>当调用semaphore.acquire() 方法时，当前线程会尝试去同步队列获取一个许可，获取许可的过程也就是使用原子的操作去修改同步队列的state ，获取一个许可则修改为state=state-1；</p>
</li>
<li><p>当计算出来的state&lt;0，则代表许可数量不足，此时会创建一个Node节点加入阻塞队列，挂起当前线程；</p>
</li>
<li><p>当计算出来的state&gt;=0，则代表获取许可成功。</p>
</li>
</ol>
</li>
<li><p><code>void release()</code>：释放一个许可，将其返回给信号量。</p>
<ol>
<li><p>当调用semaphore.release() 方法时，线程会尝试释放一个许可，释放许可的过程也就是把同步队列的state修改为state=state+1的过程</p>
</li>
<li><p>释放许可成功之后，同时会唤醒同步队列中的一个线程。</p>
</li>
<li><p>被唤醒的节点会重新尝试去修改state=state-1 的操作，如果state&gt;=0则获取许可成功，否则重新进入阻塞队列，挂起线程。</p>
</li>
</ol>
</li>
</ul>
<h2 id="8-ReentrantReadWriteLock读写锁"><a href="#8-ReentrantReadWriteLock读写锁" class="headerlink" title="8. ReentrantReadWriteLock读写锁"></a>8. ReentrantReadWriteLock读写锁</h2><h4 id="8-1-读写锁简介"><a href="#8-1-读写锁简介" class="headerlink" title="8.1 读写锁简介"></a>8.1 读写锁简介</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">场景分析：</span><br><span class="line">对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程可以同时读一个资源，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</span><br></pre></td></tr></table></figure>

<p>针对这种场景，JUC提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为<strong>共享锁</strong>；一个是写相关的锁，称为**排他锁(或独占锁)<strong>，分别采用其</strong><code>readLock()</code><strong>和</strong><code>writeLock()</code>**方法；</p>
<p><strong>注意：</strong>所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p>
<h4 id="8-2-线程进入读写锁的条件"><a href="#8-2-线程进入读写锁的条件" class="headerlink" title="8.2 线程进入读写锁的条件"></a>8.2 线程进入读写锁的条件</h4><ol>
<li><p>线程进入读锁的前提条件：</p>
<ul>
<li>没有其他线程的写锁；</li>
<li>没有写请求，或者<strong>有写请求，但调用线程和持有锁的线程是同一个</strong>；</li>
</ul>
</li>
<li><p>线程进入写锁的前提条件：</p>
<ul>
<li>没有其他线程的读锁；（读写互斥）</li>
<li>没有其他线程的写锁；（写写互斥）</li>
</ul>
</li>
</ol>
<h4 id="8-3-读写锁的特性"><a href="#8-3-读写锁的特性" class="headerlink" title="8.3 读写锁的特性"></a>8.3 读写锁的特性</h4><p>（1）公平选择性：支持非公平和公平的锁获取方式，默认为非公平锁。</p>
<p>（2）支持可重入：读锁和写锁都支持线程重进入，读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p>
<p>（3）锁降级：允许从写锁降级为读锁，实现方式：<strong>先获取写锁，然后获取读锁，最后释放写锁，释放读锁</strong>。但不允许读锁升级为写锁；</p>
<h2 id="9-BlockingQueue阻塞队列"><a href="#9-BlockingQueue阻塞队列" class="headerlink" title="9. BlockingQueue阻塞队列"></a>9. BlockingQueue阻塞队列</h2><h4 id="9-1-阻塞队列使用场景"><a href="#9-1-阻塞队列使用场景" class="headerlink" title="9.1 阻塞队列使用场景"></a>9.1 阻塞队列使用场景</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">场景分析：</span><br><span class="line">对于生产者和消费者模型，通过队列实现两者之间的数据共享。如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度必须要大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，生产者必须暂停生产（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕；</span><br></pre></td></tr></table></figure>

<p><strong>阻塞队列实现效果：</strong></p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</li>
</ul>
<h4 id="9-2-阻塞队列核心方法"><a href="#9-2-阻塞队列核心方法" class="headerlink" title="9.2 阻塞队列核心方法"></a>9.2 阻塞队列核心方法</h4><h5 id="一、放入数据"><a href="#一、放入数据" class="headerlink" title="一、放入数据"></a>一、放入数据</h5><ol>
<li><code>offer(E e)</code>：在不违反容量限制的情况下，可立即将指定元素插入此队列，成功返回true，当无可用空间时候，返回false。</li>
<li><code>offer(E o, long timeout, TimeUnit unit)</code>： 将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false。</li>
<li><code>put()</code>：直接在队列中插入元素，当无可用空间时阻塞当前线程等待。直到有空间才继续；<strong>（此方法会阻塞当前执行方法的线程）</strong></li>
<li><code>add(E e)</code>：在不违反容量限制的情况下，可立即将指定元素插入此队列，成功返回true，当无可用空间时，返回illegalStateException异常。<strong>（此方法会返回异常）</strong></li>
</ol>
<h5 id="二、获取数据"><a href="#二、获取数据" class="headerlink" title="二、获取数据"></a>二、获取数据</h5><ol>
<li><code>poll(time)</code>：取走BlockingQueue里队首的对象，若不能立即取出则可以等time参数规定的时间，若还是取不到时返回null;</li>
<li><code>take()</code>：获取并移除队列头部的元素，无元素时候阻塞当前线程等待。直到队列有新的数据被加入可获取; <strong>（此方法会阻塞当前执行方法的线程）</strong></li>
</ol>
<h4 id="9-3-阻塞队列分类"><a href="#9-3-阻塞队列分类" class="headerlink" title="9.3 阻塞队列分类"></a>9.3 阻塞队列分类</h4><h5 id="1-ArrayBlockingQueue-常用"><a href="#1-ArrayBlockingQueue-常用" class="headerlink" title="1. ArrayBlockingQueue(常用)"></a>1. ArrayBlockingQueue(常用)</h5><ul>
<li><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部维护了一个定长数组，以便缓存队列中的数据对象，还保存着两个整型变量，分别标识着队列的头部和尾部在数组中的位置；<strong>（由数组结构组成的有界阻塞队列）</strong></p>
</li>
<li><p><strong>ArrayBlockingQueue和LinkedBlockingQueue比较：</strong></p>
<ul>
<li>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；</li>
<li>ArrayBlockingQueue在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。</li>
</ul>
</li>
<li><p>创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
</li>
</ul>
<h5 id="2-LinkedBlockingQueue-常用"><a href="#2-LinkedBlockingQueue-常用" class="headerlink" title="2. LinkedBlockingQueue(常用)"></a>2. LinkedBlockingQueue(常用)</h5><ul>
<li>基于链表的阻塞队列实现，与ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程才会被唤醒，反之对于消费者这端的处理也基于同样的原理。<strong>（由链表结构组成的有界阻塞队列）</strong></li>
<li>LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li>
</ul>
<h5 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h5><ul>
<li>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素；</li>
<li>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<strong>（使用优先级队列实现的延迟无界阻塞队列）</strong></li>
</ul>
<h5 id="4-PriorityBlockingQueue"><a href="#4-PriorityBlockingQueue" class="headerlink" title="4. PriorityBlockingQueue"></a>4. PriorityBlockingQueue</h5><ul>
<li>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。<strong>（支持优先级排序的无界阻塞队列）</strong></li>
<li>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</li>
</ul>
<h5 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h5><p>一种无缓冲的等待队列<strong>（不存储元素的阻塞队列，即单个元素的队列）</strong></p>
<h2 id="10-ThreadPool线程池"><a href="#10-ThreadPool线程池" class="headerlink" title="10. ThreadPool线程池"></a>10. ThreadPool线程池</h2><h4 id="10-1-线程池架构"><a href="#10-1-线程池架构" class="headerlink" title="10.1 线程池架构"></a>10.1 线程池架构</h4><p>Java中的线程池是通过Executor框架实现的，该框架中使用了Executor、Executors、ExecutorService和ThreadPoolExecutor类；</p>
<h4 id="10-2-线程池基本结构"><a href="#10-2-线程池基本结构" class="headerlink" title="10.2 线程池基本结构"></a>10.2 线程池基本结构</h4><p>用户通过使用线程池的<code>execute()</code>方法创建线程，将Runnable提交到线程池中进行执行。当线程池中无空闲线程时，这个新加入的Runnable就会被放入等待队列。当有线程空闲下来的时候，就会去等待队列里查看是否还有排队等待的任务，如果有就会队列中取出任务并继续执行。如果没有线程就会进入休眠。</p>
<p><strong>当我们把一个Runnable交给线程池去执行的时候，这个线程池处理的流程如下：</strong></p>
<ol>
<li><p>先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务指派给某一个空闲线程去执行。如果没有空闲，<strong>判断核心线程池是否到达corePoolSize</strong>，当当前线程池中的核心线程数还小于 corePoolSize，那就再创建一个新的工作线程来执行任务。</p>
</li>
<li><p>如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，<strong>判断等待队列是否已满</strong>，没满就把这个新任务放到等待队列中。</p>
</li>
<li><p>如果等待队列又满了，<strong>判断当前线程数是否到达maximumPoolSize</strong>，如果还未到达，就继续创建工作线程。如果已经到达了，就执行饱和策略，交给RejectedExecutionHandler来决定怎么处理这个任务。</p>
</li>
</ol>
<h4 id="10-3-Executors类提供的四种线程池"><a href="#10-3-Executors类提供的四种线程池" class="headerlink" title="10.3 Executors类提供的四种线程池"></a>10.3 Executors类提供的四种线程池</h4><h5 id="1-newSingleThreadExecutor"><a href="#1-newSingleThreadExecutor" class="headerlink" title="1. newSingleThreadExecutor"></a>1. newSingleThreadExecutor</h5><ul>
<li>创建<strong>单线程的线程池</strong>。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
</ul>
<h5 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool"></a>2. newFixedThreadPool</h5><ul>
<li>创建<strong>指定线程数的线程池</strong>。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到队列中，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ul>
<h5 id="3-newCachedThreadPool"><a href="#3-newCachedThreadPool" class="headerlink" title="3. newCachedThreadPool"></a>3. newCachedThreadPool</h5><ul>
<li>创建<strong>可缓存的线程池</strong>。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，若无可回收，则添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 </li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为60秒)，则该工作线程将自动终止。终止后，如果又提交了新的任务，则线程池重新创建一个工作线程。</li>
</ul>
<h5 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4. newScheduledThreadPool"></a>4. newScheduledThreadPool</h5><ul>
<li>创建<strong>定长的线程池</strong>，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</li>
</ul>
<p><strong>总结：</strong>除了newScheduledThreadPool之外，其它线程池内部都是基于<code> ThreadPoolExecutor类</code>实现的，<strong>在实际开发时也通常继承ThreadPoolExecutor类自定义线程池</strong>；</p>
<h4 id="10-4-ThreadPoolExecutor类中的的七个参数解释："><a href="#10-4-ThreadPoolExecutor类中的的七个参数解释：" class="headerlink" title="10.4 ThreadPoolExecutor类中的的七个参数解释："></a>10.4 ThreadPoolExecutor类中的的七个参数解释：</h4><ol>
<li><p><strong>corePoolSize：线程池核心线程大小</strong></p>
<p>线程池中会维护一个常驻的最小线程数量，即使这些线程处理空闲状态也不会被销毁，这个最小线程数量即是corePoolSize；</p>
</li>
<li><p><strong>maximumPoolSize：线程池最大线程数量</strong></p>
<p>一个任务被提交到线程池后，首先会找是否有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定；</p>
</li>
<li><p><strong>keepAliveTime：空闲线程存活时间</strong></p>
<p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定；</p>
</li>
<li><p><strong>unit：空闲线程存活时间单位</strong></p>
<p>unit作为keepAliveTime的计量单位；</p>
</li>
<li><p><strong>workQueue：工作队列（采用阻塞队列）</strong></p>
<p>务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。阻塞队列的分类参考<strong>9.3 阻塞队列分类</strong>；</p>
</li>
<li><p><strong>threadFactory：线程工厂</strong></p>
<p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
</li>
<li><p><strong>handler：拒绝策略</strong></p>
<p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会根据拒绝策略进行处理，<strong>拒绝策略可分为以下4种：</strong></p>
<ul>
<li>CallerRunsPolicy：将某些任务回退给调用者线程，降低新任务的流量；</li>
<li>AbortPolicy(默认策略)：直接抛出RejectedExecutionException异常阻止系统正常运行；</li>
<li>DiscardPolicy：丢弃无法处理的任务，不予任何处理也不抛出异常；</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，并把当前任务加入队列中尝试再次提交当前任务；</li>
</ul>
</li>
</ol>
<h2 id="11-Fock-Join分支合并框架（后续补充）"><a href="#11-Fock-Join分支合并框架（后续补充）" class="headerlink" title="11. Fock/Join分支合并框架（后续补充）"></a>11. Fock/Join分支合并框架（后续补充）</h2><h4 id="11-1-Fork-Join框架简介"><a href="#11-1-Fork-Join框架简介" class="headerlink" title="11.1 Fork / Join框架简介"></a>11.1 Fork / Join框架简介</h4><p>Fork / Join将一个大的任务拆分成多个子任务进行并行处理，最后将子任务的结果合并成最终的计算结果；</p>
<ul>
<li>Fork：把一个复杂任务进行分拆；</li>
<li>Join：把分拆任务的结果进行合并；</li>
</ul>
<h4 id="11-2-Fork-Join框架与线程池区别"><a href="#11-2-Fork-Join框架与线程池区别" class="headerlink" title="11.2 Fork / Join框架与线程池区别"></a>11.2 Fork / Join框架与线程池区别</h4><p>Fork/Join框架采用“工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>
<p>相对于一般的线程池实现，Fork/Join框架的优势体现在对其中包含的任务的处理方式上。在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在Fork/Join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程的等待时间和提高了性能。</p>
<h2 id="12-CompleteableFuture异步回调（后续补充）"><a href="#12-CompleteableFuture异步回调（后续补充）" class="headerlink" title="12. CompleteableFuture异步回调（后续补充）"></a>12. CompleteableFuture异步回调（后续补充）</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门学习笔记</title>
    <url>/2020/02/03/MySQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是个人刚开始学习MySQL数据库时所记录的一些笔记，总结成十几章内容，包括基本增删改查操作语句，创建数据库，创建修改数据表，约束，视图，存储过程和函数，变量，流程控制和触发器等内容，适合刚开始接触数据库学习的小伙伴o(<em>￣▽￣</em>)ブ</p>
<span id="more"></span>

<h1 id="第-01-章-数据库概述"><a href="#第-01-章-数据库概述" class="headerlink" title="第 01 章 数据库概述"></a>第 01 章 数据库概述</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><ul>
<li>持久化(persistence)： 把数据保存到可掉电式存储设备中以供之后使用 。大多数情况下，特别是企</li>
</ul>
<p>业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以保存 ，而持久化的实现过程大多</p>
<p>通过各种关系数据库来完成。</p>
<ul>
<li>持久化的主要作用：将内存中的数据存储在关系型数据库中。</li>
</ul>
<h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2. 1 数据库的相关概念"></a>2. 1 数据库的相关概念</h3><ul>
<li><p>DB：数据库（Database），其本质是一个文件系统。它保存了一系列有组织的数据。</p>
</li>
<li><p>DBMS：数据库管理系统（Database Management System），是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</p>
</li>
<li><p>SQL：结构化查询语言（Structured Query Language）专门用来与数据库通信的语言。</p>
</li>
</ul>
<h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2. 2 数据库与数据库管理系统的关系"></a>2. 2 数据库与数据库管理系统的关系</h3><p>数据库管理系统(DBMS)可以管理多个数据库(DB)，为保存应用中实体的数据，在数据库创建会多个表以保存程序中实体用户的数据。</p>
<h2 id="3-RDBMS-与-非RDBMS"><a href="#3-RDBMS-与-非RDBMS" class="headerlink" title="3. RDBMS 与 非RDBMS"></a>3. RDBMS 与 非RDBMS</h2><h3 id="3-1-关系型数据库-RDBMS"><a href="#3-1-关系型数据库-RDBMS" class="headerlink" title="3.1 关系型数据库(RDBMS)"></a>3.1 关系型数据库(RDBMS)</h3><h4 id="3-1-1-实质"><a href="#3-1-1-实质" class="headerlink" title="3. 1. 1 实质"></a>3. 1. 1 实质</h4><ul>
<li><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。</p>
</li>
<li><p>关系型数据库以行(row)和列(column)的形式存储数据，这一系列的行和列被称为表(table)，一组表组成了一个库(database)。</p>
</li>
<li><p>关系型数据库，就是建立在关系模型基础上的数据库。</p>
</li>
<li><p>SQL 是关系型数据库的查询语言。</p>
</li>
</ul>
<h4 id="3-1-2-优势"><a href="#3-1-2-优势" class="headerlink" title="3. 1. 2 优势"></a>3. 1. 2 优势</h4><ul>
<li><p>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
</li>
<li><p>事务支持：使得对于安全性能很高的数据访问要求得以实现。</p>
</li>
</ul>
<h3 id="3-2-非关系型数据库-非RDBMS"><a href="#3-2-非关系型数据库-非RDBMS" class="headerlink" title="3. 2 非关系型数据库(非RDBMS)"></a>3. 2 非关系型数据库(非RDBMS)</h3><h4 id="非关系型数据库种类"><a href="#非关系型数据库种类" class="headerlink" title="非关系型数据库种类"></a>非关系型数据库种类</h4><ol>
<li><p>键值型数据库</p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，就会消耗大量的计算。键值型数据库典型的使用场景是作为内存缓存。Redis是最流行的键值型数据库。</p>
</li>
<li><p>文档型数据库</p>
<p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。</p>
</li>
<li><p>搜索引擎数据库</p>
<p>搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。典型产品有Solr、Elasticsearch、Splunk 等。</p>
</li>
<li><p>列式数据库</p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足之处在于功能相对有限。典型产品有HBase等。</p>
</li>
<li><p>图形数据库</p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。图形数据库就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。典型产品有Neo4J、InfoGrid等。</p>
</li>
</ol>
<h1 id="第-02-章-SELECT语句"><a href="#第-02-章-SELECT语句" class="headerlink" title="第 02 章 SELECT语句"></a>第 02 章 SELECT语句</h1><h2 id="1-基本SELECT语句"><a href="#1-基本SELECT语句" class="headerlink" title="1. 基本SELECT语句"></a>1. 基本SELECT语句</h2><h3 id="1-1-SELECT-…-FROM-…"><a href="#1-1-SELECT-…-FROM-…" class="headerlink" title="1. 1 SELECT … FROM …"></a>1. 1 SELECT … FROM …</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span> 标识从哪个表中选择</span><br></pre></td></tr></table></figure>
<p>选择全部列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<h3 id="1-2-列的别名"><a href="#1-2-列的别名" class="headerlink" title="1. 2 列的别名"></a>1. 2 列的别名</h3><p><strong>别名使用方法</strong>：紧跟列名，也可以 在列名和别名之间加入关键字<strong>AS</strong>，别名使用双引号 ，以便在别名中包含空格或特殊的字符并区分大小写。AS 可以省略，在实际使用时建议别名简短，见名知意；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> name, commission_pct comm</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-去除重复行"><a href="#1-3-去除重复行" class="headerlink" title="1. 3 去除重复行"></a>1. 3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行，在SELECT语句中使用关键字<strong>DISTINCT</strong>去除重复行；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>要注意的是：</p>
<ol>
<li><p>DISTINCT 需要放到所有列名的前面，否则会报错。</p>
</li>
<li><p>DISTINCT 其实是对后面所有列名的组合进行去重。</p>
</li>
</ol>
<h3 id="1-4-空值参与运算"><a href="#1-4-空值参与运算" class="headerlink" title="1. 4 空值参与运算"></a>1. 4 空值参与运算</h3><p>所有运算符或列值遇到null值，运算的结果都为null</p>
<p>值得注意的是，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0 ，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h3 id="1-5-查询常数"><a href="#1-5-查询常数" class="headerlink" title="1. 5 查询常数"></a>1. 5 查询常数</h3><ul>
<li><p>SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p>
</li>
<li><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
</li>
</ul>
<h2 id="2-过滤数据"><a href="#2-过滤数据" class="headerlink" title="2. 过滤数据"></a>2. 过滤数据</h2><p>语法：使用<strong>WHERE子句</strong>，将不满足条件的行过滤掉，WHERE子句紧随 FROM子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段 <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 过滤条件</span><br></pre></td></tr></table></figure>


<h1 id="第-03-章-运算符"><a href="#第-03-章-运算符" class="headerlink" title="第 03 章 运算符"></a>第 03 章 运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。</p>
<ol>
<li>加法与减法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</p>
</li>
<li><p>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</p>
</li>
<li><p>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</p>
</li>
<li><p>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按 0 计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</p>
</li>
</ul>
<ol start="2">
<li>乘法与除法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个数乘以整数 1 和除以整数 1 后仍得原数；</p>
</li>
<li><p>一个数乘以浮点数 1 和除以浮点数 1 后变成浮点数，数值与原数相等；</p>
</li>
<li><p>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</p>
</li>
<li><p>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后 4 位；</p>
</li>
<li><p>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</p>
</li>
<li><p>在数学运算中， 0 不能用作除数，在MySQL中，一个数除以 0 为NULL。</p>
</li>
</ul>
<ol start="3">
<li>求模（求余）运算符</li>
</ol>
<h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1 ，比较的结果为假则返回 0 ，其他情况则返回NULL。比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<ol>
<li><p>等号运算符</p>
<p>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回 1 ，不相等则返回0 。</p>
<p>在使用等号运算符时，遵循如下规则：</p>
</li>
</ol>
<ul>
<li><p>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</p>
</li>
<li><p>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</p>
</li>
<li><p>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</p>
</li>
<li><p>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</p>
</li>
</ul>
<ol start="2">
<li><p>安全等于运算符</p>
<p>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，唯一的区别是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为 1 ，而不为NULL；当一个操作数为NULL时，其返回值为 0 ，而不为NULL。</p>
</li>
<li><p>不等于运算符 </p>
<p>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回 1 ，相等则返回 0 。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 </p>
</li>
<li><p>空运算符 </p>
<p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回 1 ，否则返回0 。</p>
</li>
<li><p>非空运算符 </p>
<p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回 1 ，否则返回 0 。 </p>
</li>
<li><p>最小值运算符 </p>
<p>语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>最大值运算符 </p>
<p>语法格式为：GREATEST(值 1 ，值 2 ，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>BETWEEN AND运算符 </p>
<p>BETWEEN运算符使用的格式通常为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D <span class="keyword">FROM</span> <span class="keyword">TABLE</span> </span><br><span class="line"><span class="keyword">WHERE</span> C <span class="keyword">BETWEEN</span> A <span class="keyword">AND</span> B</span><br></pre></td></tr></table></figure>

<p>此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0 。</p>
</li>
<li><p>IN运算符 </p>
<p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
</li>
<li><p>NOT IN运算符 </p>
<p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回 1 ，否则返回 0 。</p>
</li>
<li><p>LIKE运算符</p>
<p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回 1 ，否则返回0 。如果给定的值或者匹配条件为NULL，则返回结果为NULL。LIKE运算符通常与通配符一起使用。</p>
</li>
<li><p>REGEXP运算符</p>
<p>REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1 ；如果不满足，则返回 0 。若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
</li>
</ol>
<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为 1 、 0 或者NULL。</p>
<p>MySQL中支持 4 种逻辑运算符如下：</p>
<ol>
<li><p>逻辑非运算符 </p>
<p>逻辑非（NOT或!）运算符表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL。</p>
</li>
<li><p>逻辑与运算符 </p>
<p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL。</p>
</li>
<li><p>逻辑或运算符 </p>
<p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
</li>
</ol>
<p><strong>注意</strong>：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
<ol start="4">
<li><p>逻辑异或运算符 </p>
<p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1 。</p>
</li>
</ol>
<h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<ol>
<li><p>按位与运算符 </p>
<p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位或运算符 </p>
<p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位异或运算符 </p>
<p>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位取反运算符 </p>
<p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</p>
</li>
</ol>
<p><strong>注意</strong>：由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以 10 &amp; ~ 1 ，首先，对数字 1 进</p>
<p>行按位取反操作，结果除了最低位为 0 ，其他位都为 1 ，然后与 10 进行按位与操作，结果为 10 。</p>
<ol start="5">
<li><p>按位右移运算符 </p>
<p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。</p>
</li>
<li><p>按位左移运算符 按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐。</p>
</li>
</ol>
<h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p>结论：赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p>
<h1 id="第-04-章-排序与分页"><a href="#第-04-章-排序与分页" class="headerlink" title="第 04 章 排序与分页"></a>第 04 章 排序与分页</h1><h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1. 1 排序规则"></a>1. 1 排序规则</h3><p>使用 <strong>ORDER BY 子句</strong>进行排序，ASC（ascend）为升序，DESC（descend）为降序，ORDER BY 子句在SELECT语句的结尾。</p>
<h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1. 2 单列排序"></a>1. 2 单列排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例子如下：</span><br><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date ;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1. 3 多列排序"></a>1. 3 多列排序</h3><p>可以使用不在SELECT列表中的列排序。在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</p>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-分页规则"><a href="#2-1-分页规则" class="headerlink" title="2. 1 分页规则"></a>2. 1 分页规则</h3><p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。MySQL中使用 **LIMIT **实现分页，LIMIT 子句必须放在整个SELECT语句的最后！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT [位置偏移量],行数</span><br></pre></td></tr></table></figure>

<p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
<p><strong>举例</strong>：MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第 5 条记录开始后面的 3 条记录，和“LIMIT4,3;”返回的结果相同。</p>
<p><strong>分页显式公式</strong>：LIMIT（当前页数- 1 ）*每页条数，每页条数</p>
<p><strong>使用 LIMIT 的好处</strong>：约束返回结果的数量可以减少据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回；</p>
<h1 id="第-05-章-多表查询"><a href="#第-05-章-多表查询" class="headerlink" title="第 05 章 多表查询"></a>第 05 章 多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p><strong>前提条件</strong>：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<h2 id="1-笛卡尔积产生的问题"><a href="#1-笛卡尔积产生的问题" class="headerlink" title="1. 笛卡尔积产生的问题"></a>1. 笛卡尔积产生的问题</h2><h3 id="1-1-笛卡尔积（或交叉连接）的理解"><a href="#1-1-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1. 1 笛卡尔积（或交叉连接）的理解"></a>1. 1 笛卡尔积（或交叉连接）的理解</h3><ul>
<li><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p>
</li>
<li><p>SQL 92 中，笛卡尔积也称为交叉连接，英文是 CROSS JOIN。在 SQL 99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。</p>
</li>
</ul>
<h3 id="1-2-分析与问题解决"><a href="#1-2-分析与问题解决" class="headerlink" title="1. 2 分析与问题解决"></a>1. 2 分析与问题解决</h3><p>笛卡尔积的错误会在下面条件下产生 ：</p>
<ol>
<li><p>省略多个表的连接条件（或关联条件）</p>
</li>
<li><p>连接条件（或关联条件）无效</p>
</li>
<li><p>所有表中的所有行互相连接</p>
</li>
</ol>
<p>为了避免笛卡尔积， 可以 在 WHERE 加入有效的连接条件。加入连接条件后，查询语法如下：</p>
<p><strong>在 WHERE子句中写入连接条件，在表中有相同列时，在列名之前加上表名前缀</strong></p>
<h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类-1-：等值连接-vs-非等值连接"><a href="#分类-1-：等值连接-vs-非等值连接" class="headerlink" title="分类 1 ：等值连接 vs 非等值连接"></a>分类 1 ：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> table1.column <span class="number">1</span> <span class="operator">=</span> table2.column <span class="number">2</span> ;  #连接条件为等号即为等值连接</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>多个连接条件与 AND 操作符</p>
</li>
<li><p>区分重复的列名，当多个表中有相同列时，必须在列名之前加上表名前缀，在不同表中具有相同列名的列可以用表名加以区分。</p>
</li>
<li><p>使用表的别名可以简化查询，列名前使用表名前缀可以提高查询效率。但需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p>
</li>
<li><p>连接 n个表,至少需要n- 1 个连接条件。 比如，连接三个表，至少需要两个连接条件。</p>
</li>
</ol>
<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>一个用户查询请求涉及到多个表的时候，连接两个表的条件为=时，就是等值连接连接；其他的运算符连接的就是非等值连接。<br><strong>注意</strong>：连接条件中的各连接字段类型必须是可比的，但不必是相同的，整型和浮点型是可比的，但是字符型和整型就不可比。</p>
<h3 id="分类-2-：自连接-vs-非自连接"><a href="#分类-2-：自连接-vs-非自连接" class="headerlink" title="分类 2 ：自连接 vs 非自连接"></a>分类 2 ：自连接 vs 非自连接</h3><p>自连接就是当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询操作。</p>
<h3 id="分类-3-：内连接-vs-外连接"><a href="#分类-3-：内连接-vs-外连接" class="headerlink" title="分类 3 ：内连接 vs 外连接"></a>分类 3 ：内连接 vs 外连接</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行；</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
<ul>
<li><p>如果是左外连接，则连接条件中左边的表也称为主表，右边的表称为从表。</p>
</li>
<li><p>如果是右外连接，则连接条件中右边的表也称为主表，左边的表称为从表。</p>
</li>
</ul>
<h4 id="SQL-92-语法：使用-创建连接"><a href="#SQL-92-语法：使用-创建连接" class="headerlink" title="SQL 92 语法：使用(+)创建连接"></a>SQL 92 语法：使用(+)创建连接</h4><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接，而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p>
<p>下面是SQL92关于外连接的语法：(层次性和可读性不强不推荐使用)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="3-SQL-99-语法实现多表查询"><a href="#3-SQL-99-语法实现多表查询" class="headerlink" title="3. SQL 99 语法实现多表查询"></a>3. SQL 99 语法实现多表查询</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3. 1 基本语法"></a>3. 1 基本语法</h3><p>使用JOIN…ON子句创建连接的语法结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column,table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3. 2 内连接(INNER JOIN)的实现"></a>3. 2 内连接(INNER JOIN)的实现</h3><p><strong>语法说明</strong>：</p>
<ul>
<li><p>可以使用 ON 子句指定额外的连接条件 ，这个连接条件是与其它条件分开的，ON 子句使语句具有更高的易读性 ；</p>
</li>
<li><p>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接；</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3. 3 外连接(OUTER JOIN)的实现"></a>3. 3 外连接(OUTER JOIN)的实现</h3><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3. 3. 1 左外连接(LEFT OUTER JOIN)"></a>3. 3. 1 左外连接(LEFT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3. 3. 2 右外连接(RIGHT OUTER JOIN)"></a>3. 3. 2 右外连接(RIGHT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：LEFT JOIN 和 RIGHT JOIN 只存在于 SQL 99 及以后的标准中，在 SQL 92 中不存在，只能用 (+) 表示。</p>
<h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3. 3. 3 满外连接(FULL OUTER JOIN)"></a>3. 3. 3 满外连接(FULL OUTER JOIN)</h4><p>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
<p>SQL 99 是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</p>
<p><strong>需要注意的是</strong>：MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。</p>
<h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><p>合并查询结果 利用<strong>UNION</strong>关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p>
<h5 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UNION操作符：UNION 操作符返回两个查询的结果集的并集，并去除重复记录。</p>
</li>
<li><p>UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
</li>
</ul>
<p><strong>注意</strong>：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
<h2 id="5-SQL-99-语法新特性"><a href="#5-SQL-99-语法新特性" class="headerlink" title="5. SQL 99 语法新特性"></a>5. SQL 99 语法新特性</h2><h3 id="5-1-自然连接"><a href="#5-1-自然连接" class="headerlink" title="5. 1 自然连接"></a>5. 1 自然连接</h3><p>SQL 99 在 SQL 92 的基础上提供了一些特殊语法，比如<strong>NATURAL JOIN</strong>用来表示自然连接。我们可以把自然连接理解为 SQL 92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。</p>
<p>在SQL 92 标准中写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br></pre></td></tr></table></figure>

<p>在 SQL 99 中你可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-USING连接"><a href="#5-2-USING连接" class="headerlink" title="5. 2 USING连接"></a>5. 2 USING连接</h3><p>当我们进行连接的时候，SQL 99 还支持使用 <strong>USING</strong> 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br></pre></td></tr></table></figure>

<p>与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="6-章节小结"><a href="#6-章节小结" class="headerlink" title="6. 章节小结"></a>6. 章节小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p>
<ul>
<li><p>WHERE：适用于所有关联查询</p>
</li>
<li><p>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</p>
</li>
<li><p>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">where</span>后面</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">on</span>后面，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联字段写在<span class="keyword">using</span>()中，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示<span class="operator">=</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs <span class="keyword">USING</span>(job_id);</span><br></pre></td></tr></table></figure>



<h1 id="第-06-章-聚合函数"><a href="#第-06-章-聚合函数" class="headerlink" title="第 06 章 聚合函数"></a>第 06 章 聚合函数</h1><p>区别于MySQL对单个值操作的单行函数，实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p>
<h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul>
<li><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p>
</li>
<li><p>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</p>
</li>
</ul>
<h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1. 1 AVG和SUM函数"></a>1. 1 AVG和SUM函数</h3><p>可以对数值型数据使用AVG 和 SUM 函数。</p>
<h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1. 2 MIN和MAX函数"></a>1. 2 MIN和MAX函数</h3><p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p>
<h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1. 3 COUNT函数"></a>1. 3 COUNT函数</h3><p>COUNT(*)返回表中记录总数，适用于任意数据类型 。COUNT(expr) 返回 expr不为空 的记录总数。</p>
<p><strong>问题1</strong>：用count(*)，count(1)，count(列名)谁好呢?</p>
<p>这取决于所用的引擎，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，好于具体的count(列名)。</p>
<p><strong>问题2</strong>：能不能使用count(列名)替换count(*)?</p>
<p>不要使用 count(列名)来替代 count(*)，count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2. 1 基本使用"></a>2. 1 基本使用</h3><p>可以使用<strong>GROUP BY子句</strong>将表中的数据分成若干组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2-2-GROUP-BY中使用WITH-ROLLUP"><a href="#2-2-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2. 2 GROUP BY中使用WITH ROLLUP"></a>2. 2 GROUP BY中使用WITH ROLLUP</h3><p>使用<strong>WITH ROLLUP</strong>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的。</p>
<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3. 1 基本使用"></a>3. 1 基本使用</h3><p>使用<strong>HAVING子句</strong>来过滤分组</p>
<p>使用情况如下：</p>
<ol>
<li><p>行已经被分组。</p>
</li>
<li><p>使用了聚合函数，注意不能在 WHERE 子句中使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span> <span class="number">10000</span> ;</span><br><span class="line"></span><br><span class="line"># 下面为错误的使用方法</span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure></li>
<li><p>满足HAVING 子句中条件的分组将被显示。</p>
</li>
<li><p>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</p>
</li>
</ol>
<h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3. 2 WHERE和HAVING的对比"></a>3. 2 WHERE和HAVING的对比</h3><p><strong>区别 1 ：</strong></p>
<ul>
<li><p>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；</p>
</li>
<li><p>HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</p>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p>
</li>
</ul>
<p><strong>区别 2 ：</strong></p>
<p>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p>
<p><strong>各自的优点与缺点：</strong></p>
<ul>
<li><p>WHERE 先筛选数据再关联，执行效率高，但不能使用分组中的计算函数进行筛选</p>
</li>
<li><p>HAVING 可以使用分组中的计算函数，在最后的结果集中进行筛选，但执行效率较低</p>
</li>
</ul>
<p><strong>开发中的参考选择：</strong></p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p>
<h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4. 1 查询的结构"></a>4. 1 查询的结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT .......</span><br><span class="line"></span><br><span class="line">#其中：</span><br><span class="line">#（ <span class="number">1</span> ）<span class="keyword">from</span>：从哪些表中筛选</span><br><span class="line">#（ <span class="number">2</span> ）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（ <span class="number">3</span> ）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（ <span class="number">4</span> ）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据</span><br><span class="line">#（ <span class="number">5</span> ）<span class="keyword">having</span>：在统计结果中再次筛选</span><br><span class="line">#（ <span class="number">6</span> ）<span class="keyword">order</span> <span class="keyword">by</span>：排序</span><br><span class="line">#（ <span class="number">7</span> ）limit：分页</span><br></pre></td></tr></table></figure>
<h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4. 2 SELECT执行顺序"></a>4. 2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p>
<ol>
<li><p>关键字的顺序是不能颠倒的，关键字顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT...</span><br></pre></td></tr></table></figure></li>
<li><p>SELECT 语句的执行顺序 （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
</li>
</ol>
<p>比如你写了一个 SQL 语句，那么它的执行顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> 的字段 <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num # 顺序 <span class="number">5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id # 顺序 <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> # 顺序 <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id # 顺序 <span class="number">3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> # 顺序 <span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> # 顺序 <span class="number">6</span></span><br><span class="line">LIMIT <span class="number">2</span> # 顺序 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h1 id="第-07-章-子查询"><a href="#第-07-章-子查询" class="headerlink" title="第 07 章 子查询"></a>第 07 章 子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询;</p>
<h2 id="1-子查询基本情况"><a href="#1-子查询基本情况" class="headerlink" title="1. 子查询基本情况"></a>1. 子查询基本情况</h2><h3 id="1-1-子查询的基本使用"><a href="#1-1-子查询的基本使用" class="headerlink" title="1. 1 子查询的基本使用"></a>1. 1 子查询的基本使用</h3><p><strong>子查询的基本语法结构例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>子查询（内查询）在主查询之前一次执行完成。子查询的结果被主查询（外查询）使用 。</p>
</li>
<li><p>子查询要包含在括号内将子查询放在比较条件的右侧，单行操作符对应单行子查询，多行操作符对应多行子查询。</p>
</li>
</ol>
<h3 id="1-2-子查询的分类"><a href="#1-2-子查询的分类" class="headerlink" title="1. 2 子查询的分类"></a>1. 2 子查询的分类</h3><p><strong>分类方式 1 ：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。</p>
<p><strong>分类方式 2 ：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为相关(或关联)子查询和不相关(或非关联)子查询。</p>
<ul>
<li>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</li>
</ul>
<ul>
<li>如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</li>
</ul>
<h2 id="2-多行子查询"><a href="#2-多行子查询" class="headerlink" title="2. 多行子查询"></a>2. 多行子查询</h2><p>多行子查询也称为集合比较子查询，内查询返回多行，使用多行比较操作符</p>
<h3 id="2-1-多行比较操作符"><a href="#2-1-多行比较操作符" class="headerlink" title="2. 1 多行比较操作符"></a>2. 1 多行比较操作符</h3><p>IN 等于列表中的 任意一个</p>
<p>ANY 需要和单行比较操作符一起使用，和子查询返回的 某一个 值比较</p>
<p>ALL 需要和单行比较操作符一起使用，和子查询返回的 所有 值比较</p>
<p>SOME 实际上是ANY的别名，作用相同，一般常使用ANY</p>
<h2 id="3-相关子查询"><a href="#3-相关子查询" class="headerlink" title="3. 相关子查询"></a>3. 相关子查询</h2><h3 id="3-1-相关子查询执行流程"><a href="#3-1-相关子查询执行流程" class="headerlink" title="3. 1 相关子查询执行流程"></a>3. 1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<ul>
<li><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p>
</li>
<li><p>在ORDER BY 中使用子查询：</p>
</li>
</ul>
<h3 id="3-2-EXISTS-与-NOT-EXISTS关键字"><a href="#3-2-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="3. 2 EXISTS 与 NOT EXISTS关键字"></a>3. 2 EXISTS 与 NOT EXISTS关键字</h3><p>关联子查询通常也会和 <strong>EXISTS</strong>操作符一起来使用，用来检查在子查询中是否存在满足条件的行。如果在子查询中不存在满足条件的行，条件返回 FALSE，继续在子查询中查找，如果在子查询中存在满足条件的行，不在子查询中继续查找，条件返回 TRUE；</p>
<p><strong>NOT EXISTS</strong>关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span></span><br><span class="line">e1.employee_id);</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是：</strong></p>
<p>当既可以使用子查询，也可以使用自连接时，一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h1 id="第-8-章-创建和管理表"><a href="#第-8-章-创建和管理表" class="headerlink" title="第 8 章 创建和管理表"></a>第 8 章 创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-标识符命名规则"><a href="#1-1-标识符命名规则" class="headerlink" title="1. 1 标识符命名规则"></a>1. 1 标识符命名规则</h3><ul>
<li><p>数据库名、表名不得超过 30 个字符，变量名限制为 29 个，必须只能包含 A–Z, a–z, 0 – 9 , _共 63 个字符</p>
</li>
<li><p>数据库名、表名、字段名等对象名中间不要包含空格</p>
</li>
<li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名，必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</p>
</li>
<li><p>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</p>
</li>
</ul>
<h3 id="1-2-MySQL中的数据类型"><a href="#1-2-MySQL中的数据类型" class="headerlink" title="1. 2 MySQL中的数据类型"></a>1. 2 MySQL中的数据类型</h3><p><strong>类型举例：</strong></p>
<ul>
<li><p>整数类型 TINYINT、SMALLINT、MEDIUMINT、 INT(或INTEGER) 、BIGINT</p>
</li>
<li><p>浮点类型 FLOAT、DOUBLE</p>
</li>
<li><p>定点数类型 DECIMAL</p>
</li>
<li><p>位类型 BIT</p>
</li>
<li><p>日期时间类型 YEAR、TIME、 DATE 、DATETIME、TIMESTAMP</p>
</li>
<li><p>文本字符串类型 CHAR、 VARCHAR 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</p>
</li>
<li><p>枚举类型 ENUM</p>
</li>
<li><p>集合类型 SET</p>
</li>
<li><p>二进制字符串类型BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</p>
</li>
<li><p>JSON类型 JSON对象、JSON数组</p>
</li>
<li><p>空间数据类型</p>
</li>
</ul>
<p>单值：GEOMETRY、POINT、LINESTRING、POLYGON；</p>
<p>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</p>
<p><strong>数据类型描述：</strong></p>
<ul>
<li><p>INT 从-2^31到2^31-1的整型数据。存储大小为 4 个字节</p>
</li>
<li><p>CHAR(size) 定长字符数据。若未指定，默认为 1 个字符，最大长度 255</p>
</li>
<li><p>VARCHAR(size) 可变长字符数据，根据字符串实际长度保存， 必须指定长度</p>
</li>
<li><p>FLOAT(M,D)单精度，占用 4 个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</p>
</li>
<li><p>DOUBLE(M,D) 双精度，占用 8 个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</p>
</li>
<li><p>DECIMAL(M,D)高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</p>
</li>
</ul>
<ul>
<li><p>DATE 日期型数据，格式’YYYY-MM-DD’</p>
</li>
<li><p>BLOB 二进制形式的长文本数据，最大可达4G</p>
</li>
<li><p>TEXT 长文本数据，最大可达4G</p>
</li>
</ul>
<h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2. 1 创建数据库"></a>2. 1 创建数据库</h3><p>方式 1 ：创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：创建数据库并指定字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br></pre></td></tr></table></figure>

<p>方式 3 ：判断数据库是否已经存在，不存在则创建数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p>
<h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2. 2 使用数据库"></a>2. 2 使用数据库</h3><p>查看当前所有的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure>

<p>查看当前正在使用的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure>

<p>查看指定库下所有的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>查看数据库的创建信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名\G</span><br></pre></td></tr></table></figure>

<p>使用/切换数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名”。</p>
<h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2. 3 修改数据库"></a>2. 3 修改数据库</h3><p>更改数据库字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure>

<h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2. 4 删除数据库"></a>2. 4 删除数据库</h3><p>方式 1 ：删除指定的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：判断数据库是否存在后再删除指定的数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="3-1-创建方式"><a href="#3-1-创建方式" class="headerlink" title="3. 1 创建方式"></a>3. 1 创建方式</h3><p><strong>语法格式：</strong></p>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
<p><strong>必须指定：</strong>表名、列名(或字段名)，数据类型， 长度</p>
<p><strong>可选指定：</strong>表约束条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">字段<span class="number">1</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">2</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">3</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">......</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-查看数据表结构"><a href="#3-2-查看数据表结构" class="headerlink" title="3. 2 查看数据表结构"></a>3. 2 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>

<h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。使用 ALTER TABLE 语句可以实现：</p>
<p>向已有的表中添加列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 【<span class="keyword">COLUMN</span>】 字段名 字段类型 【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名】;</span><br></pre></td></tr></table></figure>

<p>修改现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 【<span class="keyword">COLUMN</span>】 字段名 <span class="number">1</span> 字段类型 【<span class="keyword">DEFAULT</span> 默认值】【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名</span><br><span class="line"><span class="number">2</span> 】;</span><br></pre></td></tr></table></figure>

<p>删除现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 【<span class="keyword">COLUMN</span>】字段名</span><br></pre></td></tr></table></figure>

<p>重命名现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 【<span class="keyword">column</span>】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>

<h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><p>方式一：使用RENAME</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> emp</span><br><span class="line"><span class="keyword">TO</span> myemp;</span><br></pre></td></tr></table></figure>

<p>方式二：必须是对象的拥有者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> dept</span><br><span class="line">RENAME [<span class="keyword">TO</span>] detail_dept;  <span class="comment">-- [TO]可以省略</span></span><br></pre></td></tr></table></figure>

<h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><p>在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, ..., 数据表n];</span><br></pre></td></tr></table></figure>

<p>IF EXISTS的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<p><strong>注意：</strong>DROP TABLE 语句不能回滚</p>
<h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><p>TRUNCATE TABLE语句：删除表中所有的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 数据表;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚；</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h1 id="第-9-章-增删改语句"><a href="#第-9-章-增删改语句" class="headerlink" title="第 9 章 增删改语句"></a>第 9 章 增删改语句</h1><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-将数据插入表中"><a href="#1-1-将数据插入表中" class="headerlink" title="1. 1 将数据插入表中"></a>1. 1 将数据插入表中</h3><p>使用<strong>INSERT 语句</strong>向表中插入数据。</p>
<p><strong>方式 1 ：</strong>VALUES的方式添加，使用这种语法一次只能向表中插入一条数据。</p>
<p>情况 1 ：为表的所有字段按默认顺序插入数据，</p>
<ul>
<li>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,....);</span><br></pre></td></tr></table></figure>
<p>情况 2 ：为表的指定字段插入数据</p>
<ul>
<li><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
</li>
<li><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span> (value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>情况 3 ：同时插入多条记录</p>
<ul>
<li><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开</p>
<p>基本语法格式如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><p>VALUES也可以写成VALUE，但是VALUES是标准写法。</p>
</li>
<li><p>字符和日期型数据应包含在单引号中。</p>
</li>
</ul>
<h3 id="1-2-将查询结果插入到表中"><a href="#1-2-将查询结果插入到表中" class="headerlink" title="1. 2 将查询结果插入到表中"></a>1. 2 将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, ..., tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, ..., src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<p>在 INSERT 语句中加入子查询不必书写 VALUES 子句,子查询中的值列表应与 INSERT 子句中的列名对应。</p>
<h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p>使用 <strong>UPDATE 语句</strong>更新数据。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> 更新字段<span class="operator">=</span>更新值</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以一次更新多条数据。</p>
</li>
<li><p>如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;</p>
</li>
<li><p>使用 WHERE 子句指定需要更新的数据，如果省略 WHERE 子句，则表中的所有数据都将被更新。</p>
</li>
</ul>
<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><p>使用 <strong>DELETE 语句</strong>从表中删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p>
<p><strong>truncate table与delete table对比：</strong></p>
<p>相同点：都可以删除表中所有数据，同时保留表结构<br>不同点：truncate table清除全部表数据后不可回滚；delete table不带where时也清除全部表数据，同时数据可以回滚；</p>
<h1 id="第-10-章-约束"><a href="#第-10-章-约束" class="headerlink" title="第 10 章 约束"></a>第 10 章 约束</h1><h2 id="1-约束概述"><a href="#1-约束概述" class="headerlink" title="1. 约束概述"></a>1. 约束概述</h2><h3 id="1-1-什么是约束"><a href="#1-1-什么是约束" class="headerlink" title="1. 1 什么是约束"></a>1. 1 什么是约束</h3><p>约束是表级的强制规定。可以在 创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建后通过 ALTER TABLE 语句规定约束 。</p>
<h3 id="1-2-约束的分类"><a href="#1-2-约束的分类" class="headerlink" title="1. 2 约束的分类"></a>1. 2 约束的分类</h3><p>根据约束数据列的限制， 约束可分为：</p>
<ul>
<li><p>单列约束 ：每个约束只约束一列</p>
</li>
<li><p>多列约束 ：每个约束可约束多列数据</p>
</li>
</ul>
<p>根据约束的作用范围 ，约束可分为：</p>
<ul>
<li><p>列级约束 ：只能作用在一个列上，跟在列的定义后面</p>
</li>
<li><p>表级约束 ：可以作用在多个列上，不与列一起，而是单独定义</p>
</li>
</ul>
<p>根据约束起的作用 ，约束可分为：</p>
<ul>
<li><p>NOT NULL 非空约束，规定某个字段不能为空</p>
</li>
<li><p>UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的</p>
</li>
<li><p>PRIMARY KEY 主键(非空且唯一)约束</p>
</li>
<li><p>FOREIGN KEY 外键约束</p>
</li>
<li><p>CHECK 检查约束</p>
</li>
<li><p>DEFAULT 默认值约束</p>
</li>
</ul>
<p>**注意： **MySQL不支持check约束，但可以使用check约束，不过没有任何效果</p>
<h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2. 1 作用"></a>2. 1 作用</h3><p>限定某个字段/某列的值不允许为空</p>
<h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2. 2 关键字"></a>2. 2 关键字</h3><p>NOT NULL</p>
<h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2. 3 特点"></a>2. 3 特点</h3><ul>
<li><p>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</p>
</li>
<li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空，一个表可以有很多列都分别限定了非空</p>
</li>
<li><p>空字符串’不等于NULL， 0 也不等于NULL</p>
</li>
</ul>
<h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2. 4 添加非空约束"></a>2. 4 添加非空约束</h3><p>（1）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2. 5 删除非空约束"></a>2. 5 删除非空约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">NULL</span>;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br></pre></td></tr></table></figure>
<h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3. 1 作用"></a>3. 1 作用</h3><p>用来限制某个字段/某列的值不能重复。</p>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3. 2 关键字"></a>3. 2 关键字</h3><p>UNIQUE</p>
<h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3. 3 特点"></a>3. 3 特点</h3><ul>
<li><p>同一个表可以有多个唯一约束。</p>
</li>
<li><p>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</p>
</li>
<li><p>唯一性约束允许列值为空。</p>
</li>
<li><p>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</p>
</li>
<li><p>MySQL会给唯一约束的列上默认创建一个唯一索引。</p>
</li>
</ul>
<h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3. 4 添加唯一约束"></a>3. 4 添加唯一约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后指定唯一键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> key(字段列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 字段类型 <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3. 5 关于复合唯一约束"></a>3. 5 关于复合唯一约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">unique</span> key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-删除唯一约束"><a href="#3-6-删除唯一约束" class="headerlink" title="3. 6 删除唯一约束"></a>3. 6 删除唯一约束</h3><ul>
<li><p>添加唯一性约束的列上也会自动创建唯一索引，删除唯一约束只能通过删除唯一索引的方式删除。</p>
</li>
<li><p>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</p>
</li>
</ul>
<p><strong>注意：</strong>可以通过 show index from 表名称;查看表的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>; #查看都有哪些约束</span><br></pre></td></tr></table></figure>
<h2 id="4-PRIMARY-KEY-主键约束"><a href="#4-PRIMARY-KEY-主键约束" class="headerlink" title="4. PRIMARY KEY 主键约束"></a>4. PRIMARY KEY 主键约束</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4. 1 作用"></a>4. 1 作用</h3><p>用来唯一标识表中的一行记录。</p>
<h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4. 2 关键字"></a>4. 2 关键字</h3><p>primary key</p>
<h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4. 3 特点"></a>4. 3 特点</h3><ul>
<li><p>主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。</p>
</li>
<li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
</li>
<li><p>主键约束对应着表中的一列或者多列（复合主键），如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p>
</li>
<li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
<h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4. 4 添加主键约束"></a>4. 4 添加主键约束</h3><p>（ 1 ）建表时指定主键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key, #列级模式</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">primary</span> key(字段名) #表级模式</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后增加主键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure>

<h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4. 5 关于复合主键"></a>4. 5 关于复合主键</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">primary</span> key(字段名<span class="number">1</span>,字段名<span class="number">2</span>)  #表示字段 <span class="number">1</span> 和字段 <span class="number">2</span> 的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4. 6 删除主键约束"></a>4. 6 删除主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
<h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5. 1 作用"></a>5. 1 作用</h3><p>某个字段的值自增</p>
<h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5. 2 关键字"></a>5. 2 关键字</h3><p>auto_increment</p>
<h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5. 3 特点和要求"></a>5. 3 特点和要求</h3><ul>
<li><p>一个表最多只能有一个自增长列</p>
</li>
<li><p>当需要产生唯一标识符或顺序值时，可设置自增长</p>
</li>
<li><p>自增长列约束的列必须是键列（主键列，唯一键列）</p>
</li>
<li><p>自增约束的列的数据类型必须是整数类型</p>
</li>
<li><p>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
</li>
</ul>
<h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5. 4 如何指定自增约束"></a>5. 4 如何指定自增约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,,</span><br><span class="line"><span class="keyword">primary</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br></pre></td></tr></table></figure>

<h3 id="5-5-删除自增约束"><a href="#5-5-删除自增约束" class="headerlink" title="5. 5 删除自增约束"></a>5. 5 删除自增约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure>

<h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6. 1 作用"></a>6. 1 作用</h3><p>限定某个表的某个字段的引用完整性。</p>
<h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6. 2 关键字"></a>6. 2 关键字</h3><p>FOREIGN KEY</p>
<h3 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6. 3 主表和从表/父表和子表"></a>6. 3 主表和从表/父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<p><strong>例子1：</strong>员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p>
<p><strong>例如2：</strong>学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p>
<h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6. 4 特点"></a>6. 4 特点</h3><p>（ 1 ）从表的外键列，必须引用/参考主表的主键或唯一约束的列，因为被依赖/被参考的值必须是唯一的</p>
<p>（ 2 ）在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名，也可以指定外键约束名。</p>
<p>（ 3 ）创建(CREATE)表时就指定外键约束的话，必须先创建主表，再创建从表</p>
<p>（ 4 ）删表时，先删从表（或先删除外键约束），再删除主表</p>
<p>（ 5 ）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p>
<p>（ 6 ）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p>
<p>（ 7 ）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。</p>
<p>（ 8 ） 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）</p>
<p>（ 9 ）删除外键约束后，必须手动删除对应的索引</p>
<h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6. 5 添加外键约束"></a>6. 5 添加外键约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表名称(</span><br><span class="line">字段 <span class="number">1</span> 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段 <span class="number">2</span> 数据类型,</span><br><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键约束名称<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY（从表的某个字段) <span class="keyword">references</span> 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line"><span class="comment">-- FOREIGN KEY: 在表级指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES: 标示在父表中的列</span></span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段);</span><br></pre></td></tr></table></figure>

<h3 id="6-6-删除外键约束"><a href="#6-6-删除外键约束" class="headerlink" title="6. 6 删除外键约束"></a>6. 6 删除外键约束</h3><p>流程如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span> )第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">（ <span class="number">2</span> ）第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称; #查看某个表的索引名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>
<h2 id="7-DEFAULT约束"><a href="#7-DEFAULT约束" class="headerlink" title="7. DEFAULT约束"></a>7. DEFAULT约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7. 1 作用"></a>7. 1 作用</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h3 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7. 2 关键字"></a>7. 2 关键字</h3><p>DEFAULT</p>
<h3 id="7-3-如何给字段加默认值"><a href="#7-3-如何给字段加默认值" class="headerlink" title="7. 3 如何给字段加默认值"></a>7. 3 如何给字段加默认值</h3><h5 id="（-1-）建表时"><a href="#（-1-）建表时" class="headerlink" title="（ 1 ）建表时"></a>（ 1 ）建表时</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line"><span class="keyword">primary</span> key(字段名),</span><br><span class="line"><span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure>

<h5 id="（-2-）建表后"><a href="#（-2-）建表后" class="headerlink" title="（ 2 ）建表后"></a>（ 2 ）建表后</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值</span><br></pre></td></tr></table></figure>
<h3 id="7-4-删除默认值约束"><a href="#7-4-删除默认值约束" class="headerlink" title="7. 4 删除默认值约束"></a>7. 4 删除默认值约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br></pre></td></tr></table></figure>

<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h1 id="第-11-章-视图"><a href="#第-11-章-视图" class="headerlink" title="第 11 章 视图"></a>第 11 章 视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><ul>
<li><p>表(TABLE)</p>
<p> 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</p>
</li>
<li><p>数据字典</p>
<p>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</p>
</li>
<li><p>约束(CONSTRAINT)</p>
<p>执行数据校验的规则，用于保证数据完整性的规则</p>
</li>
<li><p>视图(VIEW)</p>
<p> 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</p>
</li>
<li><p>索引(INDEX) </p>
<p>用于提高查询性能，相当于书的目录</p>
</li>
<li><p>存储过程(PROCEDURE)</p>
<p>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</p>
</li>
<li><p>存储函数(FUNCTION)</p>
<p>用于完成一次特定的计算，具有一个返回值</p>
</li>
<li><p>触发器(TRIGGER)</p>
<p>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</p>
</li>
</ul>
<h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2. 1 为什么使用视图？"></a>2. 1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p>
<h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2. 2 视图的理解"></a>2. 2 视图的理解</h3><ul>
<li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p>
</li>
<li><p>视图建立在已有表的基础上 , 视图赖以建立的这些表称为基表 。</p>
</li>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
</li>
<li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句</p>
</li>
<li><p>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</p>
</li>
<li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
</li>
</ul>
<h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><p>在 CREATE VIEW 语句中嵌入子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br></pre></td></tr></table></figure>
<p><strong>说明 1 ：</strong>实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形</p>
<p>成一张虚拟表。</p>
<p><strong>说明 2 ：</strong>在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字</p>
<p>段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法 1 ：查看数据库的表对象、视图对象</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>

<p>语法 2 ：查看视图的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 视图名称;</span><br></pre></td></tr></table></figure>

<p>语法 3 ：查看视图的属性信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>语法 4 ：查看视图的详细定义信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>

<h2 id="5-不可更新的视图"><a href="#5-不可更新的视图" class="headerlink" title="5. 不可更新的视图"></a>5. 不可更新的视图</h2><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li><p>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>视图定义基于一个不可更新视图；</p>
</li>
<li><p>常量视图。</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p>
</li>
</ul>
<p><strong>总结：</strong>虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图的数据。 对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p>
<h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6. 1 修改视图"></a>6. 1 修改视图</h3><p>方式 1 ：使用CREATE OR REPLACE VIEW 子句 修改视图</p>
<p><strong>注意：</strong>CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
<p>方式 2 ：ALTER VIEW</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6. 2 删除视图"></a>6. 2 删除视图</h3><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7. 1 视图优点"></a>7. 1 视图优点</h3><ol>
<li><p>操作简单</p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
</li>
<li><p>减少数据冗余</p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
</li>
<li><p>数据安全</p>
<p>MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， 用户不需要查询数据表，可以直接通过视图获取数据表中的信息 。这在一定程度上保障了数据表中数据的安全性。</p>
</li>
<li><p>适应灵活多变的需求</p>
<p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
</li>
<li><p>能够分解复杂的查询逻辑 </p>
<p>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
</li>
</ol>
<h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7. 2 视图不足"></a>7. 2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么， 如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h1 id="第-12-章-存储过程与函数"><a href="#第-12-章-存储过程与函数" class="headerlink" title="第 12 章 存储过程与函数"></a>第 12 章 存储过程与函数</h1><h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1. 1 理解"></a>1. 1 理解</h3><p><strong>含义 ：</strong>存储过程的英文是 Stored Procedure。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。</p>
<p><strong>执行过程：</strong>存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处 ：</strong></p>
<ol>
<li><p>简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </p>
</li>
<li><p>减少操作过程中的失误，提高效率</p>
</li>
<li><p>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </p>
</li>
<li><p>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p>
</li>
</ol>
<p><strong>和视图、函数的对比 ：</strong></p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1. 2 分类"></a>1. 2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<ol>
<li>没有参数（无参数无返回） </li>
<li>仅仅带 IN 类型（有参数无返回）</li>
<li>仅仅带 OUT 类型（无参数有返回） </li>
<li>既带 IN 又带 OUT（有参数有返回） </li>
<li>带 INOUT（有参数有返回）</li>
</ol>
<p><strong>注意：</strong>IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2. 1 语法分析"></a>2. 1 语法分析</h3><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span> 新的结束标记</span><br><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>参数前面的符号的意思</li>
</ol>
<ul>
<li><p>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认是 IN，表示输入参数。</p>
</li>
<li><p>OUT：当前参数为输出参数，也就是表示出参；执行完成后，调用这个存储过程客户端或者应用程序就可以读取这个参数返回值了。</p>
</li>
<li><p>INOUT：当前参数既可以为输入参数，也可以为输出参数。</p>
</li>
</ul>
<ol start="2">
<li><p>形参类型可以是 MySQL数据库中的任意类型。</p>
</li>
<li><p>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
</li>
</ol>
<ul>
<li><p>LANGUAGE SQL：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>
</li>
<li><p>[NOT] DETERMINISTIC：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。</p>
</li>
<li><p>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</p>
</li>
<li><p>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</p>
</li>
<li><p>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</p>
</li>
<li><p>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。默认情况下，系统会指定为CONTAINS SQL。</p>
</li>
<li><p>SQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
</li>
<li><p>DEFINER表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</p>
</li>
<li><p>INVOKER表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。如果没有设置相关的值，则MySQL默认指定值为DEFINER。</p>
</li>
<li><p>COMMENT ‘string’：注释信息，可以用来描述存储过程。</p>
</li>
</ul>
<ol start="4">
<li><p>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
</li>
<li><p>需要设置新的结束标记</p>
</li>
</ol>
<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p>
<p><strong>比如：</strong>“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p>
<h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><p>调用格式如下：</p>
<p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4. 1 语法分析"></a>4. 1 语法分析</h3><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><p>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p>
</li>
<li><p>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。</p>
</li>
<li><p>characteristic 创建函数时指定的对函数的约束。</p>
</li>
<li><p>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
</li>
</ol>
<h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4. 2 调用存储函数"></a>4. 2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。</p>
<h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5. 1 查看"></a>5. 1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍 3 种方法。</p>
<ol>
<li><p>使用SHOW CREATE语句查看存储过程和函数的创建信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure></li>
<li><p>使用SHOW STATUS语句查看存储过程和函数的状态信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">#[<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。 </span><br></pre></td></tr></table></figure></li>
<li><p>从information_schema.Routines表中查看存储过程和函数的信息</p>
</li>
</ol>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;];</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>如果在MySQL数据库中存在存储过程和函数名称相同情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
<h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5. 2 修改"></a>5. 2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<p><strong>注意：</strong>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
<h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5. 3 删除"></a>5. 3 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br><span class="line"># IF <span class="keyword">EXISTS</span>：如果程序或函数不存储，它可以防止发生错误，产生一个用<span class="keyword">SHOW</span> WARNINGS查看的警告。</span><br></pre></td></tr></table></figure>

<h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6. 1 优点"></a>6. 1 优点</h3><ol>
<li><p>存储过程可以一次编译多次使用。 存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
</li>
<li><p>可以减少开发工作量。 将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
</li>
<li><p>存储过程的安全性强。 我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</p>
</li>
<li><p>可以减少网络传输量。 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
</li>
<li><p>良好的封装性。 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
</li>
</ol>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6. 2 缺点"></a>6. 2 缺点</h3><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<ol>
<li><p>可移植性差。 存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
</li>
<li><p>调试困难。 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
</li>
<li><p>存储过程的版本管理很困难。 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
</li>
<li><p>它不适合高并发的场景。 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
</li>
</ol>
<h1 id="第-13-章-变量、流程控制与游标"><a href="#第-13-章-变量、流程控制与游标" class="headerlink" title="第 13 章 变量、流程控制与游标"></a>第 13 章 变量、流程控制与游标</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ul>
<li><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
</li>
<li><p>在 MySQL 数据库中，变量分为系统变量以及用户自定义变量。</p>
</li>
</ul>
<h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1. 1 系统变量"></a>1. 1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1. 1. 1 系统变量分类"></a>1. 1. 1 系统变量分类</h4><ul>
<li><p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数；</p>
</li>
<li><p>系统变量分为全局系统变量（需要添加global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 如果不写，默认为会话级别。 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
</li>
<li><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p>
</li>
<li><p>全局系统变量针对于所有会话（连接）有效，但不能跨重启，而会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值，但是会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</p>
</li>
</ul>
<h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1. 1. 2 查看系统变量"></a>1. 1. 2 查看系统变量</h4><p>查看所有或部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看指定系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure>

<p>作为 MySQL 编码规范，MySQL 中的系统变量以“**@@**”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
<h4 id="1-1-3修改系统变量"><a href="#1-1-3修改系统变量" class="headerlink" title="1.1.3修改系统变量"></a>1.1.3修改系统变量</h4><p>方式 1 ：修改MySQL配置文件，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式 2 ：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1. 2 用户变量"></a>1. 2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1. 2. 1 用户变量分类"></a>1. 2. 1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个“**@**”开头。根据作用范围不同，又分为会话用户变量和局部变量。</p>
<ul>
<li><p>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</p>
</li>
<li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</p>
</li>
</ul>
<h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1. 2. 2 会话用户变量"></a>1. 2. 2 会话用户变量</h4><p>作用域：<strong>针对于当前会话有效</strong>，可定义在会话的任何位置，等同于会话变量的作用域</p>
<ol>
<li>查看用户变量的值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>声明变量并初始化</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>赋值（更新用户变量的值）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1. 2. 3 局部变量"></a>1. 2. 3 局部变量</h4><p>定义：可以使用DECLARE语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的<strong>BEGIN … END 中</strong>有效，只能放在 BEGIN … END 中，而且只能放在第一句</p>
<ol>
<li>定义变量</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 [<span class="keyword">default</span> 值];  # 如果没有<span class="keyword">DEFAULT</span>子句，初始值为NULLBEGIN</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量赋值</li>
</ol>
<p>方式 1 ：一般用于赋简单的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：一般用于赋表中的字段值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure>

<p>3 .使用变量 （查看、比较、运算等)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>

<h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><p>只要是执行的程序，流程就分为三大类：</p>
<ul>
<li><p>顺序结构：程序从上往下依次执行</p>
</li>
<li><p>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</p>
</li>
<li><p>循环结构：程序满足一定条件下，重复执行一组语句</p>
</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li><p>条件判断语句：IF 语句和 CASE 语句</p>
</li>
<li><p>循环语句：LOOP、WHILE 和 REPEAT 语句</p>
</li>
<li><p>跳转语句：ITERATE 和 LEAVE 语句</p>
</li>
</ul>
<h3 id="2-1-分支结构之-IF"><a href="#2-1-分支结构之-IF" class="headerlink" title="2. 1 分支结构之 IF"></a>2. 1 分支结构之 IF</h3><p>IF 语句的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 表达式 <span class="number">1</span> <span class="keyword">THEN</span> 操作 <span class="number">1</span></span><br><span class="line">[ELSEIF 表达式 <span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]......</span><br><span class="line">[<span class="keyword">ELSE</span> 操作N]</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br><span class="line">#根据表达式的结果为<span class="literal">TRUE</span>或<span class="literal">FALSE</span>执行相应的语句。这里“[]”中的内容是可选的。</span><br></pre></td></tr></table></figure>

<p>特点：① 不同的表达式对应不同的操作  ② 使用在begin end中</p>
<h3 id="2-2-分支结构之-CASE"><a href="#2-2-分支结构之-CASE" class="headerlink" title="2. 2 分支结构之 CASE"></a>2. 2 分支结构之 CASE</h3><p>CASE 语句的语法结构 1 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构 2 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<h3 id="2-3-循环结构之LOOP"><a href="#2-3-循环结构之LOOP" class="headerlink" title="2. 3 循环结构之LOOP"></a>2. 3 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br><span class="line"></span><br><span class="line">#其中，loop_label表示LOOP语句的标注名称，该参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="2-4-循环结构之WHILE"><a href="#2-4-循环结构之WHILE" class="headerlink" title="2. 4 循环结构之WHILE"></a>2. 4 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br><span class="line"></span><br><span class="line"># while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环</span><br></pre></td></tr></table></figure>

<h3 id="2-5-循环结构之REPEAT"><a href="#2-5-循环结构之REPEAT" class="headerlink" title="2. 5 循环结构之REPEAT"></a>2. 5 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br><span class="line"></span><br><span class="line"># repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<ul>
<li>loop：一般用于实现简单的死循环</li>
<li>while：先判断后执行</li>
<li>repeat：先执行后判断，无条件至少执行一次</li>
</ul>
<h3 id="2-6-跳转语句之LEAVE语句"><a href="#2-6-跳转语句之LEAVE语句" class="headerlink" title="2. 6 跳转语句之LEAVE语句"></a>2. 6 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。可以把 LEAVE 理解为编程语句中的 break。</p>
<p>基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LEAVE label</span><br><span class="line"># 其中，label参数表示循环的标志。LEAVE和<span class="keyword">BEGIN</span> ... <span class="keyword">END</span>或循环一起被使用。</span><br></pre></td></tr></table></figure>

<h3 id="2-7-跳转语句之ITERATE语句"><a href="#2-7-跳转语句之ITERATE语句" class="headerlink" title="2. 7 跳转语句之ITERATE语句"></a>2. 7 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。可以把 ITERATE 理解为编程语句中的 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br><span class="line"># label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</span><br></pre></td></tr></table></figure>

<h2 id="3-游标"><a href="#3-游标" class="headerlink" title="3. 游标"></a>3. 游标</h2><h3 id="3-1-什么是游标"><a href="#3-1-什么是游标" class="headerlink" title="3. 1 什么是游标"></a>3. 1 什么是游标</h3><ul>
<li><p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。 游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</p>
</li>
<li><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。MySQL中游标可以在存储过程和函数中使用。</p>
</li>
</ul>
<h3 id="3-2-使用游标步骤"><a href="#3-2-使用游标步骤" class="headerlink" title="3. 2 使用游标步骤"></a>3. 2 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><em><strong>第一步，声明游标</strong></em></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。</p>
<p>如果是用 Oracle 或者 PostgreSQL，则需要写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。</p>
<p><strong>第二步，打开游标</strong></p>
<p>打开游标的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。</p>
<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>var_name必须在声明游标之前就定义好。</p>
</li>
<li><p>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 ，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
</li>
</ol>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源，如果不及时关闭， 游标会一直保持到存储过程结束 ，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<h1 id="第-14-章-触发器"><a href="#第-14-章-触发器" class="headerlink" title="第 14 章_触发器"></a>第 14 章_触发器</h1><h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><p>创建触发器的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br><span class="line"></span><br><span class="line"># 表名：表示触发器监控的对象。</span><br><span class="line"># BEFORE<span class="operator">|</span>AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</span><br><span class="line"># <span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>：表示触发的事件。</span><br><span class="line"># <span class="keyword">INSERT</span> 表示插入记录时触发；</span><br><span class="line"># <span class="keyword">UPDATE</span> 表示更新记录时触发；</span><br><span class="line"># <span class="keyword">DELETE</span> 表示删除记录时触发。</span><br></pre></td></tr></table></figure>

<p>触发器执行的语句块可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p>
<h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3. 1 查看触发器"></a>3. 1 查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式 1 ：查看当前数据库的所有触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：查看当前数据库中某个触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure>

<p>方式 3 ：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3. 2 删除触发器"></a>3. 2 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4. 1 优点"></a>4. 1 优点</h3><ol>
<li><p>触发器可以确保数据的完整性 。</p>
</li>
<li><p>触发器可以帮助我们记录操作日志。</p>
</li>
<li><p>触发器还可以用在操作数据前，对数据进行合法性检查。</p>
</li>
</ol>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4. 2 缺点"></a>4. 2 缺点</h3><ol>
<li>触发器最大的一个问题就是可读性差。</li>
</ol>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</p>
<ol start="2">
<li>相关数据的变更，可能会导致触发器出错。</li>
</ol>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2020/09/05/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人学习Nginx基本使用所总结的笔记，仅供参考</p>
<span id="more"></span>

<h2 id="1-Nginx基本概念"><a href="#1-Nginx基本概念" class="headerlink" title="1. Nginx基本概念"></a>1. Nginx基本概念</h2><h3 id="1-1-Nginx概念"><a href="#1-1-Nginx概念" class="headerlink" title="1.1 Nginx概念"></a>1.1 Nginx概念</h3><p>一个高性能的HTTP和反向代理web服务器，专为性能优化而开发，能承受高并发连接</p>
<h3 id="1-2-正向代理与反向代理"><a href="#1-2-正向代理与反向代理" class="headerlink" title="1.2 正向代理与反向代理"></a>1.2 正向代理与反向代理</h3><p><strong>正向代理</strong>：在客户端配置代理服务器，必须要通过代理服务器才能访问互联网；</p>
<p><strong>反向代理</strong>：只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端（<strong>此时对外暴露的是代理服务器的地址，隐藏了真实服务器的IP地址</strong>）</p>
<h3 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h3><p><strong>负载均衡</strong>：通过增加服务器数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上改为分发到多个服务器上，即<strong>将负载分发到不同的服务器上</strong>；</p>
<h3 id="1-4-动静分离"><a href="#1-4-动静分离" class="headerlink" title="1.4 动静分离"></a>1.4 动静分离</h3><p><strong>动静分离</strong>：<strong>将动态页面和静态页面由不同的服务器来解析（先把请求发送到Nginx，Nginx根据请求进行转发，服务器Tomcat部署动态资源，专门服务器部署静态资源）</strong>，加快解析速度和降低原来单个服务器的压力；</p>
<h2 id="2-Nginx常用命令"><a href="#2-Nginx常用命令" class="headerlink" title="2. Nginx常用命令"></a>2. Nginx常用命令</h2><p><strong>注意：</strong>使用Nginx操作命令必须要先进入Nginx的目录**/user/local/nginx/sbin**</p>
<ol>
<li><p>查看Nginx版本号：**./nginx -v**</p>
</li>
<li><p>启动Nginx：**./nginx**</p>
</li>
<li><p>关闭Nginx：**./nginx -s stop**</p>
</li>
<li><p>重新加载Nginx（<strong>热部署</strong>）：**./nginx -s reload**</p>
</li>
</ol>
<h2 id="3-Nginx配置文件"><a href="#3-Nginx配置文件" class="headerlink" title="3. Nginx配置文件"></a>3. Nginx配置文件</h2><h3 id="3-1-Nginx配置文件组成"><a href="#3-1-Nginx配置文件组成" class="headerlink" title="3.1 Nginx配置文件组成"></a>3.1 Nginx配置文件组成</h3><p>Nginx配置文件由三部分组成：</p>
<ul>
<li><p>第一部分：全局块<br>主要配置一些影响Nginx服务器整体运行的配置指令；</p>
</li>
<li><p>第二部分：events块<br>主要影响Nginx服务器与用户的网络连接，影响Nginx的性能；</p>
</li>
<li><p>第三部分：http块（http块包括http全局块和server块，server块又包含全局server块和location块）</p>
<p>主要配置如代理、缓存和日志定义等绝大多数功能和第三方模块的配置</p>
</li>
</ul>
<h2 id="4-Nginx配置实例"><a href="#4-Nginx配置实例" class="headerlink" title="4. Nginx配置实例"></a>4. Nginx配置实例</h2><h3 id="4-1-实例1：反向代理"><a href="#4-1-实例1：反向代理" class="headerlink" title="4.1 实例1：反向代理"></a>4.1 实例1：反向代理</h3><p>使用Nginx反向代理，可以根据访问的路径跳转到不同端口的服务中；</p>
<p>利用Nginx实现反向代理的步骤如下：</p>
<ol>
<li><p>在window的HOST文件添加域名和ip对应关系的配置（Nginx服务器中的ip地址    要访问的域名）</p>
</li>
<li><p><strong>在Nginx的配置文件的server块进行如下参数配置</strong>：</p>
<ul>
<li><strong>server_name    Nginx服务器中的ip地址</strong>（将localhost改为该ip地址）</li>
<li>location中添加转发路径：<strong>proxy_pass    转发到真正要访问的ip地址</strong></li>
</ul>
</li>
</ol>
<p><strong>实现例子：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现效果：</span></span><br><span class="line"><span class="comment"># Nginx监听端口9001，当访问edu模块时，跳转到8080端口，当访问vod模块时跳转到8081端口(实现访问http://ip地址:9001/edu/直接跳转到http://ip地址:8080的效果)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="attr">listen</span>	<span class="string">9091</span></span><br><span class="line">	<span class="attr">server_name</span>	<span class="string">Nginx服务器中的ip地址</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">location</span> <span class="string">~ /edu/ &#123;</span></span><br><span class="line">		<span class="attr">proxy_pass</span>	<span class="string">http://ip地址:8080</span></span><br><span class="line">	<span class="attr">&#125;</span></span><br><span class="line">	<span class="attr">location</span> <span class="string">~ /vod/ &#123;</span></span><br><span class="line">		<span class="attr">proxy_pass</span>	<span class="string">http://ip地址:8081</span></span><br><span class="line">	<span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 注意：如果location的uri包含正则表达式，则必须要有~或者~*标识</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-2-实例2：负载均衡"><a href="#4-2-实例2：负载均衡" class="headerlink" title="4.2 实例2：负载均衡"></a>4.2 实例2：负载均衡</h3><p><strong>实现例子：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现效果：</span></span><br><span class="line"><span class="comment"># 浏览器地址栏输入地址http://Nginx服务器中的ip地址:9001/edu/时，实现负载均衡效果，平均到8080和8081两个端口中</span></span><br><span class="line"></span><br><span class="line"><span class="attr">在Nginx的配置文件的http块进行如下参数配置：</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">服务名 &#123;</span></span><br><span class="line">	<span class="attr">server</span>	<span class="string">ip地址:8080</span></span><br><span class="line">	<span class="attr">server</span>	<span class="string">ip地址:8081</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="attr">listen</span>	<span class="string">9091</span></span><br><span class="line">	<span class="attr">server_name</span>	  <span class="string">ip地址</span></span><br><span class="line">	<span class="attr">...</span></span><br><span class="line">	<span class="attr">location</span> <span class="string">~ /edu/ &#123;</span></span><br><span class="line">		<span class="attr">proxy_pass</span> <span class="string">http://服务名;</span></span><br><span class="line">	<span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Nginx分配服务器的策略：</strong></p>
<ol>
<li><p>轮询策略（默认）</p>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器宕机就自动剔除</p>
</li>
<li><p>权重策略</p>
<p>weight代表权重默认为1，权重越高被分配的客户端越多</p>
</li>
<li><p>ip_hash策略</p>
<p>每个请求按访问的ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session问题</p>
</li>
<li><p>fair策略</p>
<p>按照后端服务器的响应时间来分配请求，响应时间短的优先分配</p>
</li>
</ol>
<h3 id="4-3-实例3：动静分离"><a href="#4-3-实例3：动静分离" class="headerlink" title="4.3 实例3：动静分离"></a>4.3 实例3：动静分离</h3><p>同样需要在Nginx配置文件中对location进行配置</p>
<h2 id="5-Nginx高可用集群搭建"><a href="#5-Nginx高可用集群搭建" class="headerlink" title="5. Nginx高可用集群搭建"></a>5. Nginx高可用集群搭建</h2><p>（后续继续学习）</p>
<h2 id="6-Nginx原理解析"><a href="#6-Nginx原理解析" class="headerlink" title="6. Nginx原理解析"></a>6. Nginx原理解析</h2><p>结构：master负责管理监控请求派发给worker，worker通过争抢机制完成任务</p>
<ol>
<li><p>Nginx中一个master和多个worker进程的好处：</p>
<ul>
<li>可以使用**./nginx -s reload热部署**；</li>
<li>每个worker是独立的进程，其中一个worker出现问题不会影响其他worker进行争抢实现请求过程，不会造成服务中断；</li>
</ul>
</li>
<li><p>设计多个worker才是合适的：</p>
<p>worker数和服务器的CPU数量相等最为合适；</p>
</li>
<li><p>nginx支持的最大并发数：</p>
</li>
</ol>
<ul>
<li><strong>普通的静态访问最大并发数</strong>：<br>worker最大连接数 * worker数 / 2</li>
<li><strong>HTTP作为反向代理最大并发数</strong>：<br>worker最大连接数 * worker数 / 4</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息队列学习笔记①</title>
    <url>/2020/09/13/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人学习RabbitMQ消息队列时所总结的一部分学习笔记，关于RabbitMQ的更深入内容后续学习继续补充；</p>
<span id="more"></span>

<h2 id="1-消息队列概述"><a href="#1-消息队列概述" class="headerlink" title="1. 消息队列概述"></a>1. 消息队列概述</h2><h3 id="1-1-MQ概念"><a href="#1-1-MQ概念" class="headerlink" title="1.1 MQ概念"></a>1.1 MQ概念</h3><p>MQ（Message Queue）本质上是一个FIFO的队列，只不过队列中存放的内容是消息，用于上下游传递消息，用于上下有“逻辑解耦+物理解耦”的消息通信服务，使用MQ之后消息发送上有只需要依赖MQ而不再需要依赖其他服务；</p>
<h3 id="1-2-MQ作用"><a href="#1-2-MQ作用" class="headerlink" title="1.2 MQ作用"></a>1.2 MQ作用</h3><h4 id="1-2-1-流量消峰"><a href="#1-2-1-流量消峰" class="headerlink" title="1.2.1 流量消峰"></a>1.2.1 流量消峰</h4><p>以订单系统为例，加入某订单系统最多能处理一万次订单，在正常时段处理能力足够，但是在高峰期就会有订单超过一万后不允许继续下单的限制，<strong>当使用MQ做缓冲时，先把请求发送到消息队列而不是直接发送到订单系统，消息队列把短时间集中的订单分散到一段时间来处理达到流量消峰的目的，虽然相比平时下单返回的结果时间会变慢，但是不至于订单系统崩溃</strong>；</p>
<h4 id="1-2-2-应用解耦"><a href="#1-2-2-应用解耦" class="headerlink" title="1.2.2 应用解耦"></a>1.2.2 应用解耦</h4><p>以电商系统为例，订单系统如果调用物流系统和支付系统，任何一个子系统出故障都会导致下单操作异常，当转变为基于MQ的方式后，可以减少系统间调用的问题，比如<strong>物流系统发生故障需要几分钟来修复，在这几分钟的时间里，订单系统发送的需要物流系统处理的消息先被缓存在消息队列中，用户的下单操作可以正常完成，当物流系统恢复后，物流系统继续处理订单消息即可，中途用户感受不到物流系统的故障</strong>；</p>
<h4 id="1-2-3-异步处理"><a href="#1-2-3-异步处理" class="headerlink" title="1.2.3 异步处理"></a>1.2.3 异步处理</h4><p>以服务调用为例，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后发送一条消息给MQ，MQ会将这消息转发给A，这样A既不用循环调用B的查询api，又能去处理其他业务的同时及时得到B异步处理完成的消息；</p>
<h3 id="1-3-MQ核心概念与名词"><a href="#1-3-MQ核心概念与名词" class="headerlink" title="1.3 MQ核心概念与名词"></a>1.3 MQ核心概念与名词</h3><h4 id="1-3-1-RabbitMQ概念"><a href="#1-3-1-RabbitMQ概念" class="headerlink" title="1.3.1 RabbitMQ概念"></a>1.3.1 RabbitMQ概念</h4><p>RabbitMQ是一个消息中间件，用于接收、存储和转发消息数据；</p>
<h4 id="1-3-2-四个核心概念"><a href="#1-3-2-四个核心概念" class="headerlink" title="1.3.2 四个核心概念"></a>1.3.2 四个核心概念</h4><p><strong>生产者：</strong>产生数据发送消息的程序；</p>
<p><strong>消费者：</strong>等待接收消息的程序；（同一个应用程序既可以是生产者也可以是消费者）</p>
<p><strong>交换机：</strong>RabbitMQ的接收和分发消息的组件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中，由交换机类型决定如何处理它接收到的消息；</p>
<p><strong>队列：</strong>RabbirMQ内部使用的数据结构，消息只能存储在队列中，本质上是一个消息缓冲区；<strong>一个交换机可以与多个队列建立绑定关系，通常一个队列对应一个消费者</strong>，当一个队列对应多个消费者时也只会有其中一个消费者能收到消息；</p>
<h2 id="2-生产消费模型"><a href="#2-生产消费模型" class="headerlink" title="2. 生产消费模型"></a>2. 生产消费模型</h2><h3 id="2-1-简单队列模式"><a href="#2-1-简单队列模式" class="headerlink" title="2.1 简单队列模式"></a>2.1 简单队列模式</h3><p><strong>生产者代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记得先引入rabbitmq依赖客户端amap-client、操作文件流依赖commons-io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0.队列名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;自定义队列名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建连接工厂：</span></span><br><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.工厂IP连接RabbitMQ队列</span></span><br><span class="line">factory.setHost(主机IP地址);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.用户名及密码</span></span><br><span class="line">factory.setUsername(用户名);</span><br><span class="line">factory.setPassword(密码);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取信道（一个连接中可以有多个信道）</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connnection.createChannel( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.生成队列</span></span><br><span class="line">channel.quereDeclare(发送的队列名, 队列是否持久化, 是否只供一个消费者进行消费和进行消息共享, 断开连接后是否自动删除队列, 其他参数);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.发送消息</span></span><br><span class="line">channel.basicPublish(发送到哪个交换机, 路由的Key值, 其它参数信息, 发送消息的消息体);</span><br></pre></td></tr></table></figure>

<p><strong>消费者代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.队列名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;自定义队列名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建连接工厂：</span></span><br><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.工厂IP连接RabbitMQ队列</span></span><br><span class="line">factory.setHost(主机IP地址);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.用户名及密码</span></span><br><span class="line">factory.setUsername(用户名);</span><br><span class="line">factory.setPassword(密码);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取信道</span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connnection.createChannel( );</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.接收消息</span></span><br><span class="line">channel.basicConsume(消费的队列名, 消费成功后是否自动应答, 消费者未成功消费的回调, 消费者取消消费的回调);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-工作队列模式"><a href="#2-2-工作队列模式" class="headerlink" title="2.2 工作队列模式"></a>2.2 工作队列模式</h3><p>含义：<strong>多个工作线程作为消费者去接收消息</strong>，但要注意的是，<strong>一个消息只能被处理一次不能被处理多次</strong>，因此采用轮询分发消息的模式（即公平分发，与之对应的是不公平分发），不同的工作线程之间是竞争关系；</p>
<h4 id="2-2-1-消息应答"><a href="#2-2-1-消息应答" class="headerlink" title="2.2.1 消息应答"></a>2.2.1 消息应答</h4><p>概念：消费者在接收到消息并且处理该消息之后，发送ACK确认告诉RabbitMQ已经处理，RabbitMQ才可以把消息删除；（<strong>引入消息应答的目的是保证消息在发送过程中不丢失</strong>）</p>
<p><strong>自动应答模式</strong>（默认采用）</p>
<ul>
<li><strong>消息发送后立即被认为已经传送成功</strong>，这种模式需要在高吞吐量和数据传输安全性方面做权衡</li>
<li><strong>没有对传输的消息数量进行限制</strong>，可能导致消费者处消息积压（建议这种模式使用在消费者可以高效并以某种速率能够处理这些消息的情况下）；</li>
</ul>
<p><strong>手动应答模式：</strong>可以批量应答并且减少网络拥堵；</p>
<p>手动应答的方法如下：</p>
<ol>
<li>channel.basicAck (用于肯定确认)</li>
<li>channel.basicNack (用于否定确认)</li>
<li>channel.basicReject (用于否定确认，不处理该消息直接拒绝)，<strong>与basicNack相比没有批量处理参数，只应答当前消息</strong></li>
</ol>
<p><strong>消息自动重新入队：</strong>消费者由于某些原因失去连接导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将其重新排队；如果此时其他消费者可以处理，它将该消息重新发给另一个消费者处理，确保消息不会丢失；（开启手动应答才会使用）</p>
<h3 id="2-3-持久化"><a href="#2-3-持久化" class="headerlink" title="2.3 持久化"></a>2.3 持久化</h3><h4 id="2-3-1-队列持久化"><a href="#2-3-1-队列持久化" class="headerlink" title="2.3.1 队列持久化"></a>2.3.1 队列持久化</h4><p>默认创建的队列是非持久化的，RabbitMQ重启该队列就会被删除，实现队列持久化需要在声明队列前把durable参数设置为持久化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明参数durable为true队列持久化</span></span><br><span class="line">channel.quereDeclare(发送的队列名, <span class="literal">true</span>, 是否只供一个消费者进行消费和进行消息共享, 断开连接后是否自动删除队列, 其他参数);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-消息持久化"><a href="#2-3-2-消息持久化" class="headerlink" title="2.3.2 消息持久化"></a>2.3.2 消息持久化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在发送消息时添加MessageProperties.PERSISTENT_TEXT_PLAIN属性即可把消息保存在磁盘上，实现消息持久化</span></span><br><span class="line">channel.basicPublish(发送到哪个交换机, 路由的Key值, MessageProperties.PERSISTENT_TEXT_PLAIN, 发送消息的消息体);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-不公平分发"><a href="#2-3-3-不公平分发" class="headerlink" title="2.3.3 不公平分发"></a>2.3.3 不公平分发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicQos(<span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>注意：prefetchCount设置为0是轮询分发，设置为1就是不公平分发；将prefetchCount设置成其他数字可以设置为预取值；</p>
<h3 id="2-4-发布确认模式"><a href="#2-4-发布确认模式" class="headerlink" title="2.4 发布确认模式"></a>2.4 发布确认模式</h3><p>发布确认模式可分为以下几种：单个发布确认、批量发布确认、异步批量确认；</p>
<ul>
<li><strong>单个发布确认</strong>属于一种同步发布确认模式，特点是<strong>收到单个消息就马上进行一次发布确认</strong></li>
<li><strong>批量发布确认</strong>特点是<strong>批量发送指定数量的消息后才进行一次发布确认</strong>，但消息出现丢失时无法确定具体哪个消息未被确认</li>
<li><strong>异步批量确认</strong>属于一种异步发布确认模式，特点是<strong>无论是否收到都进行确认应答，确认收到时回调ackCallback，未确认收到回调nackCallback</strong></li>
</ul>
<h2 id="3-交换机模型"><a href="#3-交换机模型" class="headerlink" title="3. 交换机模型"></a>3. 交换机模型</h2><h3 id="3-1-绑定"><a href="#3-1-绑定" class="headerlink" title="3.1 绑定"></a>3.1 绑定</h3><p>绑定（blinding）即声明交换机和具体哪个队列之间建立关系；</p>
<h3 id="3-2-扇出交换机（发布订阅模式）"><a href="#3-2-扇出交换机（发布订阅模式）" class="headerlink" title="3.2 扇出交换机（发布订阅模式）"></a>3.2 扇出交换机（发布订阅模式）</h3><p>扇出（Fanout）是交换机类型之一，即将接收到的所有消息广播到它知道的所有队列中；</p>
<p><strong>扇出交换机消费者代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个交换机</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//声明一个临时队列，当消费者断开与队列连接时，队列就会自动删除</span></span><br><span class="line">channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定交换机和队列</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;routingKey&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicConsume();</span><br></pre></td></tr></table></figure>

<h3 id="3-3-直接（Direct）交换机（路由模式）"><a href="#3-3-直接（Direct）交换机（路由模式）" class="headerlink" title="3.3 直接（Direct）交换机（路由模式）"></a>3.3 直接（Direct）交换机（路由模式）</h3><h3 id="3-4-主题（Topic）交换机"><a href="#3-4-主题（Topic）交换机" class="headerlink" title="3.4 主题（Topic）交换机"></a>3.4 主题（Topic）交换机</h3><h2 id="4-死信队列"><a href="#4-死信队列" class="headerlink" title="4. 死信队列"></a>4. 死信队列</h2><p>概念：<strong>死信即无法被消费的信息</strong>，死信队列即存放这些消息的队列；</p>
<p>应用场景：为了保证订单业务的消息数据不丢失，<strong>当消息消费发生异常时就将消息投入到死信队列中，后续恢复时该消息可以继续消费</strong>（如用户在商城下单成功并点击去支付后，在指定的时间未支付时自动失效）</p>
<h3 id="4-1-死信来源"><a href="#4-1-死信来源" class="headerlink" title="4.1 死信来源"></a>4.1 死信来源</h3><p>死信的来源主要有三个：</p>
<ol>
<li>消息TTL过期</li>
<li>队列达到最大长度，无法再添加数据到MQ中</li>
<li>消息被拒绝</li>
</ol>
<h3 id="4-2-延迟队列"><a href="#4-2-延迟队列" class="headerlink" title="4.2 延迟队列"></a>4.2 延迟队列</h3><p>概念：延迟队列即死信来源为<strong>消息TTL过期</strong>的情况，是<strong>用来存放需要在指定时间被处理的元素</strong>的队列</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习笔记</title>
    <url>/2021/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人学习设计模式时的学习笔记，开始先介绍了七大设计原则和UML类图的基础知识，接着按照创建型模式、结构型模式和行为型模式的分类来分别介绍23种设计模式，对各种设计模式有了一个基本认识；</p>
<span id="more"></span>

<h2 id="1-七大设计原则"><a href="#1-七大设计原则" class="headerlink" title="1. 七大设计原则"></a>1. 七大设计原则</h2><p><strong>核心思想：</strong></p>
<ol>
<li>独立出需要变化的地方，不要和那些不需要变化的部分混在一起；</li>
<li>针对接口编程而不是针对实现编程；</li>
<li>交互对象之间松耦合设计；</li>
</ol>
<h3 id="1-1-单一职责原则（单一功能原则）"><a href="#1-1-单一职责原则（单一功能原则）" class="headerlink" title="1.1 单一职责原则（单一功能原则）"></a>1.1 单一职责原则（单一功能原则）</h3><p><strong>含义：</strong>对类来说，即一个类应该只负责一项职责；（只有类中方法数量足够少，可在方法级别遵守单一职责原则）</p>
<h3 id="1-2-接口隔离原则"><a href="#1-2-接口隔离原则" class="headerlink" title="1.2 接口隔离原则"></a>1.2 接口隔离原则</h3><p><strong>含义：</strong>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>；</p>
<p><strong>实现方法：</strong></p>
<ul>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
</ul>
<h3 id="1-3-依赖倒置原则"><a href="#1-3-依赖倒置原则" class="headerlink" title="1.3 依赖倒置原则"></a>1.3 依赖倒置原则</h3><p><strong>含义：</strong></p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节，细节应该依赖抽象；</li>
<li><strong>依赖倒置的中心思想是面向接口编程，而不是面向实现编程</strong>；</li>
<li>以抽象为基础搭建的架构比细节为基础的架构要稳定得多（在java中抽象指接口或抽象类，细节指具体的实现类）；</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及具体的操作，具体细节由实现类完成；</li>
</ol>
<p><strong>实现方法：</strong></p>
<ul>
<li><p>每个类尽量提供接口或抽象类，或者两者都具备。</p>
</li>
<li><p>变量的声明类型尽量是接口或者是抽象类。</p>
</li>
<li><p>任何类都不应该从具体类派生。</p>
</li>
<li><p>使用继承时尽量遵循里氏替换原则。</p>
</li>
</ul>
<h3 id="1-4-里氏替换原则"><a href="#1-4-里氏替换原则" class="headerlink" title="1.4 里氏替换原则"></a>1.4 里氏替换原则</h3><p><strong>含义：</strong></p>
<ol>
<li>所有引用父类的地方必须能透明地使用其子类的对象；</li>
<li><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，即子类继承父类时，除添加新的方法完成新增功能外，在子类中尽量不要重写父类的方法；</li>
<li>继承实际上是让两个类耦合性增强，原来的父类和子类应该都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替；</li>
</ol>
<p><strong>实现方法：</strong></p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>
</ul>
<h3 id="1-5-开闭-ocp-原则"><a href="#1-5-开闭-ocp-原则" class="headerlink" title="1.5 开闭(ocp)原则"></a>1.5 开闭(ocp)原则</h3><p><strong>ocp原则含义：（最基础最重要的设计原则）</strong><br>1.一个软件实体如类、模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）；</p>
<p>2.当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；</p>
<p><strong>实现方法：</strong>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中</p>
<h3 id="1-6-迪米特法则（最少知识原则）"><a href="#1-6-迪米特法则（最少知识原则）" class="headerlink" title="1.6 迪米特法则（最少知识原则）"></a>1.6 迪米特法则（最少知识原则）</h3><p><strong>含义：</strong></p>
<ol>
<li><strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。</strong></li>
<li>一个类对自己依赖的类知道得越少越好，即对于被依赖的类不管多么复杂都尽量将逻辑封装在类的内部，对外除了提供public方法不对外泄露任何信息；</li>
<li><strong>只与直接朋友通信</strong>（出现在成员变量、方法参数、方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）</li>
</ol>
<p><strong>实现方法：</strong></p>
<ul>
<li><p>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</p>
</li>
<li><p>在类的结构设计上，尽量降低类成员的访问权限。</p>
</li>
<li><p>在对其他类的引用上，将引用其他对象的次数降到最低。</p>
</li>
<li><p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p>
</li>
</ul>
<h3 id="1-7-合成复用原则"><a href="#1-7-合成复用原则" class="headerlink" title="1.7 合成复用原则"></a>1.7 合成复用原则</h3><p><strong>含义：</strong>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现（使用继承关系时必须严格遵守里氏替换原则）</p>
<h3 id="1-8-七大设计原则总结"><a href="#1-8-七大设计原则总结" class="headerlink" title="1.8 七大设计原则总结"></a>1.8 七大设计原则总结</h3><p>开闭原则：对扩展开放，对修改关闭</p>
<p>依赖倒置原则：高层不应该依赖低层，要面向接口编程</p>
<p>单一职责原则：一个类只干一件事，实现类要单一</p>
<p>接口隔离原则：一个接口只服务一个子模块，接口要精简单一</p>
<p>迪米特法则：一个类应该保持对其它对象最少的了解</p>
<p>里氏替换原则：不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</p>
<p>合成复用原则：尽量使用组合或者聚合关系实现代码复用，少使用继承</p>
<p><strong>七大原则目的：</strong>降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p>
<h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h2><h3 id="2-1-创建型模式"><a href="#2-1-创建型模式" class="headerlink" title="2.1 创建型模式"></a>2.1 创建型模式</h3><h4 id="2-1-1-单例模式"><a href="#2-1-1-单例模式" class="headerlink" title="2.1.1 单例模式"></a>2.1.1 单例模式</h4><p><strong>含义：</strong>指<strong>一个类只有一个实例</strong>，且<strong>该类能自行创建这个实例</strong>，<strong>对外提供一个访问该单例的全局访问点</strong>；</p>
<p><strong>注意：</strong>在JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>需要频繁地进行创建和销毁的对象（多线程线程池、网络连接池等）</li>
<li>创建对象时耗时过多或耗费资源过多(重量级对象)但又经常用到的对象；</li>
<li>某类只要求生成一个对象时；</li>
<li>频繁访问数据库或文件的对象（数据源、session工厂等）</li>
</ol>
<p><strong>单例模式的几种写法：</strong></p>
<h5 id="写法一：饿汉式1：静态常量"><a href="#写法一：饿汉式1：静态常量" class="headerlink" title="写法一：饿汉式1：静态常量"></a>写法一：饿汉式1：静态常量</h5><p><strong>评价：</strong>这种写法可用，在类装载时就完成实例化，虽然可以避免线程同步问题，但没有达到懒加载效果，如果始终没有用过这个实例，可能造成内存浪费；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="number">1.</span>类的内部创建静态对象实例</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span>构造器私有化，外部不能<span class="keyword">new</span>创建对象</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">3.</span>向外暴露一个静态公共方法getInstance，返回实例对象</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写法二：饿汉式2：静态代码块"><a href="#写法二：饿汉式2：静态代码块" class="headerlink" title="写法二：饿汉式2：静态代码块"></a>写法二：饿汉式2：静态代码块</h5><p><strong>评价：</strong>这种写法可用，在类装载时就完成实例化，虽然可以避免线程同步问题，但没有达到懒加载效果，如果始终没有用过这个实例，可能造成内存浪费；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="number">1.</span>构造器私有化</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span>类内部创建对象实例</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="number">3.</span>在静态代码块中创建单例对象</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">4.</span>向外暴露一个公共的静态的公共方法getInstance，返回实例对象</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写法三：懒汉式：线程安全同步"><a href="#写法三：懒汉式：线程安全同步" class="headerlink" title="写法三：懒汉式：线程安全同步"></a>写法三：懒汉式：线程安全同步</h5><p><strong>评价：在实际开发中不推荐使用这种方式</strong>，虽然解决线程不安全问题，但每次访问时都要同步，会影响性能，且消耗更多的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//保证instance在所有线程中同步</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private避免雷灾外部被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供静态同步公有方法，类加载时没有生成单例，只有当第一次调用getlnstance方法时才去创建这个单例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写法四：双重检查"><a href="#写法四：双重检查" class="headerlink" title="写法四：双重检查"></a>写法四：双重检查</h5><p><strong>评价：</strong>实际开发时推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供静态公有方法，加入双重检查代码，解决线程安全问题同时解决懒加载问题，同时保证效率；</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写法五：静态内部类"><a href="#写法五：静态内部类" class="headerlink" title="写法五：静态内部类"></a>写法五：静态内部类</h5><p><strong>评价：</strong>在实际开发时推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写一个静态内部类SingletonInstance，该类中有一个静态属性INSTANCE，当外部类加载时静态内部类并不会加载，只有静态方法被调用时才会装载静态内部类，里面的静态属性只会在第一次加载类的时候初始化（JVM类装载机制保证）</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">( )</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写法六：枚举类"><a href="#写法六：枚举类" class="headerlink" title="写法六：枚举类"></a>写法六：枚举类</h5><p><strong>评价：</strong>实际开发推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-工厂模式"><a href="#2-1-2-工厂模式" class="headerlink" title="2.1.2 工厂模式"></a>2.1.2 工厂模式</h4><h5 id="2-1-2-1-简单工厂模式（静态工厂方法模式）"><a href="#2-1-2-1-简单工厂模式（静态工厂方法模式）" class="headerlink" title="2.1.2.1 简单工厂模式（静态工厂方法模式）"></a>2.1.2.1 简单工厂模式（静态工厂方法模式）</h5><p><strong>含义：</strong>定义<strong>一个工厂类可以根据参数的不同返回不同类的实例</strong>，被创建的实例通常都具有共同的父类，其创建实例的方法通常为静态方法；（一个工厂类负责所有产品的生产）</p>
<p><strong>简单工厂模式的主要角色如下：</strong></p>
<ol>
<li><p>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</p>
</li>
<li><p>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</p>
</li>
<li><p>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</p>
</li>
</ol>
<h5 id="2-1-2-2-工厂方法模式"><a href="#2-1-2-2-工厂方法模式" class="headerlink" title="2.1.2.2 工厂方法模式"></a>2.1.2.2 工厂方法模式</h5><p><strong>含义：</strong>基类定义一个创建对象的抽象方法，由多个子类决定分别要实例化的类，<strong>工厂方法模式将对象的实例化推迟到子类</strong>；（一个具体的子类负责一类产品的生产）</p>
<p><strong>工厂方法模式的主要角色如下：</strong></p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能的公共弄接口。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品显示&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了产品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：实现了产品的生成方法，并返回具体产品（一个工厂只生产一种产品）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂生成--&gt;具体产品&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-3-抽象工厂模式【难点】"><a href="#2-1-2-3-抽象工厂模式【难点】" class="headerlink" title="2.1.2.3 抽象工厂模式【难点】"></a>2.1.2.3 抽象工厂模式【难点】</h5><p><strong>含义：定义一个interface用于创建相关或有依赖关系的对象簇</strong>，而无需指明具体的类；（即<strong>定义抽象工厂类和具体实现的工厂子类</strong>）（一个具体的子类负责多类产品的生产）</p>
<p><strong>抽象工厂模式的主要角色如下：</strong></p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品：提供了多个产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品显示&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品检查&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂：提供了多个产品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：实现了产品的生成方法，并返回具体产品（一个工厂生成多种产品）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂生成--&gt;具体产品1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂生成--&gt;具体产品2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-原型模式"><a href="#2-1-3-原型模式" class="headerlink" title="2.1.3 原型模式"></a>2.1.3 原型模式</h4><p><strong>含义：</strong>用一个已经创建的实例作为原型，通过<strong>复制该原型对象来创建一个和原型相同或相似的新对象</strong></p>
<p><strong>原型模式包含以下主要角色：</strong></p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><strong>原型模式实现：</strong></p>
<p>原型模式的克隆分为<strong>浅克隆</strong>和<strong>深克隆</strong>。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。（Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。）</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<h4 id="2-1-4-建造者模式"><a href="#2-1-4-建造者模式" class="headerlink" title="2.1.4 建造者模式"></a>2.1.4 建造者模式</h4><p><strong>含义：</strong>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示；（<strong>所创建产品间有较多共同点，如果产品间差异性很大则不适合使用建造者模式</strong>）</p>
<p><strong>建造者模式的四个角色</strong>：</p>
<ol>
<li>Product（产品角色）：一个包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件；</li>
<li>Builder（抽象建造者）：一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品对象的方法 getResult( )。</li>
<li>ConcreteBuilder（具体建造者）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>Director（指挥者）：构建一个使用Builder接口的对象，调用建造者中的方法完成复杂对象的创建；</li>
</ol>
<h3 id="2-2-结构型模式"><a href="#2-2-结构型模式" class="headerlink" title="2.2 结构型模式"></a>2.2 结构型模式</h3><h4 id="2-2-1-装饰器模式"><a href="#2-2-1-装饰器模式" class="headerlink" title="2.2.1 装饰器模式"></a>2.2.1 装饰器模式</h4><p><strong>含义：</strong>指<strong>在不改变现有对象结构的情况下，动态地给该对象增加一些职责</strong>，即增加其额外功能；（注意装饰器模式会增加许多子类，过度使用会增加程序得复杂性）</p>
<p><strong>装饰器模式主要包含以下角色：</strong></p>
<ol>
<li>抽象构件（Component）：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）：实现抽象构件，<strong>通过具体装饰角色为其添加一些职责</strong>。</li>
<li>抽象装饰（Decorator）：<strong>实现抽象构件，并包含具体构件的实例</strong>，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）：<strong>继承抽象装饰的相关方法，并给具体构件对象添加附加的责任</strong>。</li>
</ol>
<p><strong>应用场景：</strong></p>
<ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象装饰（其中包含具体构件的实例）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        addedFunction();</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-代理模式"><a href="#2-2-2-代理模式" class="headerlink" title="2.2.2 代理模式"></a>2.2.2 代理模式</h4><p><strong>含义：</strong>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，<strong>访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介</strong>。</p>
<p><strong>代理模式的主要角色如下：</strong></p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p><strong>根据代理的创建时期，代理模式分为静态代理和动态代理：</strong></p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当被请求时，采用Proxy来获取RealSubject中的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可选择添加的原代码前后的增强代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-适配器模式（Adapter模式）"><a href="#2-2-3-适配器模式（Adapter模式）" class="headerlink" title="2.2.3 适配器模式（Adapter模式）"></a>2.2.3 适配器模式（Adapter模式）</h4><p><strong>含义：</strong>将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容；（用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法）</p>
<p><strong>适配器模式（Adapter）包含以下主要角色：</strong></p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，<strong>通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者</strong>。</li>
</ol>
<p><strong>应用场景：</strong></p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h5 id="2-2-3-1-类适配器模式"><a href="#2-2-3-1-类适配器模式" class="headerlink" title="2.2.3.1 类适配器模式"></a>2.2.3.1 类适配器模式</h5><p><strong>含义：</strong>定义一个适配器类来实现当前系统的目标接口，同时继承适配者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-2-对象适配器模式"><a href="#2-2-3-2-对象适配器模式" class="headerlink" title="2.2.3.2 对象适配器模式"></a>2.2.3.2 对象适配器模式</h5><p><strong>含义：</strong>将适配者类中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-桥接模式【难点】"><a href="#2-2-4-桥接模式【难点】" class="headerlink" title="2.2.4 桥接模式【难点】"></a>2.2.4 桥接模式【难点】</h4><p><strong>含义：</strong>将抽象与实现分离，使它们可以独立变化。（<strong>即将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系</strong>，从而降低了抽象和实现这两个可变维度的耦合度）</p>
<p><strong>桥接（Bridge）模式包含以下主要角色：</strong></p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类并<strong>包含一个对实现化角色的引用</strong>。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并<strong>通过组合关系调用实现化角色中的业务方法</strong>。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，<strong>供扩展抽象化角色调用</strong>。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor impl;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Abstraction</span><span class="params">(Implementor impl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedAbstraction</span><span class="params">(Implementor impl)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span> &#123;</span><br><span class="line">        impl.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-组合模式【难点】"><a href="#2-2-5-组合模式【难点】" class="headerlink" title="2.2.5 组合模式【难点】"></a>2.2.5 组合模式【难点】</h4><p><strong>含义：将对象组合成树状的层次结构</strong>，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性；</p>
<p><strong>组合模式包含以下主要角色：</strong></p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。<strong>（总的抽象类或接口，定义一些通用的方法，比如新增、删除）</strong></li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，<strong>用于继承或实现抽象构件</strong>。</li>
<li>树枝构件（Composite）角色 / 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是<strong>存储和管理子部件</strong>，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<p>组合模式分为<strong>透明式的组合模式</strong>和<strong>安全式的组合模式</strong>：</p>
<ul>
<li><p>透明式组合模型</p>
<p>在该方式中，由于<strong>抽象构件声明了所有子类中的全部方法</strong>，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：<strong>树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常）</strong>，这样会带来一些安全性问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>安全式组合模型</p>
<p>在该方式中，将<strong>管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法</strong>，这样就避免了透明式组合模型的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构建，只保留层次的公共行为</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-6-外观模式（Facada模式）"><a href="#2-2-6-外观模式（Facada模式）" class="headerlink" title="2.2.6 外观模式（Facada模式）"></a>2.2.6 外观模式（Facada模式）</h4><p><strong>含义：</strong>通过<strong>为多个复杂的子系统提供一个统一的接口</strong>，而使这些子系统更加容易被访问；</p>
<p><strong>外观模式包含以下主要角色：</strong></p>
<ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口，它包含了对各个子系统的引用</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem01</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem01</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem02</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem02</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统角色1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统角色2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-享元模式【难点】"><a href="#2-2-7-享元模式【难点】" class="headerlink" title="2.2.7 享元模式【难点】"></a>2.2.7 享元模式【难点】</h4><p><strong>含义：</strong>运用<strong>共享</strong>技术来有效地支持大量<strong>细粒度对象</strong>的复用（享元模式本质上是缓存共享对象，<strong>相同对象只保存一份</strong>）</p>
<p><strong>享元模式的主要角色有如下：</strong></p>
<ol>
<li>抽象享元（Flyweight）角色：是所有的具体享元类的基类，<strong>为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入</strong>。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它<strong>以参数的形式注入具体享元的相关方法中</strong>。</li>
<li>享元工厂（Flyweight Factory）角色：<strong>负责创建和管理享元角色</strong>。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsharedConcreteFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info) &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="comment">//享元工厂管理的关键字</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="keyword">public</span> Flyweight <span class="title function_">getFlyweight</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> (Flyweight) flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-行为型模式"><a href="#2-3-行为型模式" class="headerlink" title="2.3 行为型模式"></a>2.3 行为型模式</h3><h4 id="2-3-1-观察者模式（Observer模式）"><a href="#2-3-1-观察者模式（Observer模式）" class="headerlink" title="2.3.1 观察者模式（Observer模式）"></a>2.3.1 观察者模式（Observer模式）</h4><p><strong>含义：</strong>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式；</p>
<p><strong>观察者模式的主要角色如下：</strong></p>
<ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它<strong>提供了一个用于保存观察者对象的聚集类</strong>和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，<strong>当具体主题的内部状态发生改变时，通知所有注册过的观察者对象</strong>。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，<strong>当接到具体主题的更改通知时被调用</strong>。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便<strong>在得到目标的更改通知时更新自身的状态</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知观察者的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//更新状态</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">response</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-模板方法模式【难点】"><a href="#2-3-2-模板方法模式【难点】" class="headerlink" title="2.3.2 模板方法模式【难点】"></a>2.3.2 模板方法模式【难点】</h4><p><strong>含义：</strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。（<strong>即提取公共部分代码，不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现</strong>）</p>
<p><strong>模板方法模式包含以下主要角色：</strong></p>
<ol>
<li>抽象类/抽象模板（Abstract Class）</li>
</ol>
<p>抽象模板类，负责给出一个算法的轮廓和骨架。它<strong>由一个模板方法和若干个基本方法构成</strong>。这些方法的定义如下：</p>
<p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型：</p>
<ul>
<li>抽象方法：在抽象类中声明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<ol start="2">
<li>具体子类/具体实现（Concrete Class）</li>
</ol>
<p>具体实现类，用于实现抽象类中所定义的抽象方法和钩子方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象模板类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod1</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-命令模式【难点】"><a href="#2-3-3-命令模式【难点】" class="headerlink" title="2.3.3 命令模式【难点】"></a>2.3.3 命令模式【难点】</h4><p><strong>含义：</strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开，两者之间通过命令对象进行沟通，可以提供命令的撤销和恢复功能。</p>
<p><strong>命令模式包含以下主要角色：</strong></p>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它<strong>拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</strong>。</li>
<li>实现者/接收者（Receiver）角色：<strong>执行命令功能的相关操作，是具体命令对象业务的真正实现者</strong>。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并<strong>通过访问命令对象来执行相关请求，它不直接访问接收者</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用者call()中command.execute()根据多态性，实际调用了具体命令类execute()中的receiver.action(),间接访问接收者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-访问者模式【难点】"><a href="#2-3-4-访问者模式【难点】" class="headerlink" title="2.3.4 访问者模式【难点】"></a>2.3.4 访问者模式【难点】</h4><p><strong>含义：</strong>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。<strong>（将对数据的操作与数据结构进行分离）</strong></p>
<p><strong>访问者模式包含以下主要角色：</strong></p>
<ol>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，<strong>为每个具体元素类对应一个访问操作 visit()</strong> ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，<strong>确定访问者访问一个元素时该做什么</strong>。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，<strong>被接受的访问者对象作为 accept() 方法的参数</strong>。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，<strong>提供让访问者对象遍历容器中的所有元素的方法</strong>，通常由 List、Set、Map 等聚合类实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElementA element)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElementB element)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElementA element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElementB element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-迭代器模式"><a href="#2-3-5-迭代器模式" class="headerlink" title="2.3.5 迭代器模式"></a>2.3.5 迭代器模式</h4><p><strong>含义：</strong>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。（即<strong>通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的</strong>，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据）</p>
<p><strong>迭代器模式主要包含以下角色：</strong></p>
<ol>
<li>抽象聚合（Aggregate）角色：定义<strong>存储、添加、删除聚合对象以及创建迭代器对象</strong>的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，<strong>返回一个具体迭代器的实例</strong>。</li>
<li>抽象迭代器（Iterator）角色：定义<strong>访问和遍历聚合元素</strong>的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，<strong>完成对聚合对象的遍历，记录遍历的当前位置</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object obj)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>;</span><br><span class="line">    <span class="comment">//创建迭代器对象</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回具体迭代器实例</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(index);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-中介者模式"><a href="#2-3-6-中介者模式" class="headerlink" title="2.3.6 中介者模式"></a>2.3.6 中介者模式</h4><p><strong>含义：</strong>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p><strong>中介者模式包含以下主要角色：</strong></p>
<ol>
<li>抽象中介者（Mediator）角色：它是中介者的接口，<strong>提供了同事对象注册与转发同事对象信息的抽象方法</strong>。</li>
<li>具体中介者（Concrete Mediator）角色：实现中介者接口，<strong>定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系</strong>，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，<strong>保存中介者对象，提供同事对象交互的抽象方法</strong>，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，<strong>当需要与其他同事对象交互时，由中介者对象负责后续的交互</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//同事对象注册</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span>;</span><br><span class="line">    <span class="comment">//转发同时对象信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">relay</span><span class="params">(Colleague cl)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">relay</span><span class="params">(Colleague cl)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ((Colleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMedium</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//请中介者转发</span></span><br><span class="line">        mediator.relay(<span class="built_in">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-7-备忘录模式（快照模式）"><a href="#2-3-7-备忘录模式（快照模式）" class="headerlink" title="2.3.7 备忘录模式（快照模式）"></a>2.3.7 备忘录模式（快照模式）</h4><p><strong>含义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后<strong>当需要时能将该对象恢复到原先保存的状态</strong>。</p>
<p><strong>备忘录模式的主要角色如下：</strong></p>
<ol>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，<strong>提供创建备忘录和恢复备忘录数据的功能</strong>，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责<strong>存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</strong>。</li>
<li>管理者（Caretaker）角色：<strong>对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储发起人内部状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建备忘录</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(m.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento m)</span> &#123;</span><br><span class="line">        memento = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-8-解释器模式【不常用】"><a href="#2-3-8-解释器模式【不常用】" class="headerlink" title="2.3.8 解释器模式【不常用】"></a>2.3.8 解释器模式【不常用】</h4><p><strong>含义：</strong>给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。</p>
<p><strong>解释器模式包含以下主要角色：</strong></p>
<ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，<strong>用来实现文法中与终结符相关的操作</strong>，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，<strong>用来实现文法中与非终结符相关的操作</strong>，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常<strong>包含各个解释器需要的数据或是公共的功能</strong>，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">     <span class="comment">//解释方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(String info)</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">implements</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(String info)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(String info)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="comment">//数据初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String info)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-9-状态模式【难点】"><a href="#2-3-9-状态模式【难点】" class="headerlink" title="2.3.9 状态模式【难点】"></a>2.3.9 状态模式【难点】</h4><p><strong>含义：</strong>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p><strong>状态模式包含以下主要角色：</strong></p>
<ol>
<li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，<strong>内部维护一个当前状态，并负责具体状态的切换</strong>。</li>
<li>抽象状态（State）角色：定义一个接口，<strong>用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为</strong>。</li>
<li>具体状态（Concrete State）角色：<strong>实现抽象状态所对应的行为，并且在需要的情况下进行状态切换</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">()</span> &#123;</span><br><span class="line">        state.Handle(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 A.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 B.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-10-策略模式【难点】"><a href="#2-3-10-策略模式【难点】" class="headerlink" title="2.3.10 策略模式【难点】"></a>2.3.10 策略模式【难点】</h4><p><strong>含义：</strong>定义一组算法，并将每个算法封装到一系列的策略类中，并且使它们之间可以互换。作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法。</p>
<p><strong>策略模式的主要角色如下：</strong></p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：<strong>持有一个策略类的引用，最终给客户端调用</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//策略方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> Strategy <span class="title function_">getStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-11-责任链模式（职责链模式）"><a href="#2-3-11-责任链模式（职责链模式）" class="headerlink" title="2.3.11 责任链模式（职责链模式）"></a>2.3.11 责任链模式（职责链模式）</h4><p><strong>含义：</strong>将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p><strong>职责链模式主要包含以下角色：</strong></p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，<strong>包含抽象处理方法和一个后继连接</strong>。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，<strong>判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</strong></li>
<li>客户类（Client）角色：<strong>创建处理链，并向链头的具体处理者对象提交请求</strong>，它不关心处理细节和请求的传递过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainOfResponsibilityPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//组装责任链，先创建头节点和后续节点</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        <span class="comment">//向链头提交请求创建处理链</span></span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象处理者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//创建后续节点</span></span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-设计模式总结"><a href="#2-4-设计模式总结" class="headerlink" title="2.4 设计模式总结"></a>2.4 设计模式总结</h3><h4 id="2-4-1-创建型模式（简单来说就是用来创建对象的）"><a href="#2-4-1-创建型模式（简单来说就是用来创建对象的）" class="headerlink" title="2.4.1 创建型模式（简单来说就是用来创建对象的）"></a>2.4.1 创建型模式（简单来说就是用来创建对象的）</h4><h5 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h5><p>保证一个类仅有一个实例，并且提供一个全局访问点</p>
<h5 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h5><p>不同条件下创建不同实例</p>
<h5 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h5><p>通过拷贝原型创建新的对象</p>
<h5 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h5><p>用来分步按顺序创建复杂的复合对象</p>
<h4 id="2-4-2-结构型模式（关注类和对象的组合）"><a href="#2-4-2-结构型模式（关注类和对象的组合）" class="headerlink" title="2.4.2 结构型模式（关注类和对象的组合）"></a>2.4.2 结构型模式（关注类和对象的组合）</h4><h5 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h5><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<h5 id="2-外观模式"><a href="#2-外观模式" class="headerlink" title="2. 外观模式"></a>2. 外观模式</h5><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，即对外提供一个统一的接口用来访问子系统</p>
<h5 id="3-装饰器模式"><a href="#3-装饰器模式" class="headerlink" title="3. 装饰器模式"></a>3. 装饰器模式</h5><p>动态地给一个对象添加一些额外的职责</p>
<h5 id="4-享元模式"><a href="#4-享元模式" class="headerlink" title="4. 享元模式"></a>4. 享元模式</h5><p>使用对象池来减少重复对象的创建</p>
<h5 id="5-组合模式"><a href="#5-组合模式" class="headerlink" title="5. 组合模式"></a>5. 组合模式</h5><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</p>
<h5 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h5><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</p>
<h5 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h5><p>将两个能够独立变化的部分分离开来</p>
<h4 id="2-4-3-行为型模式（关注对象之间的通信）"><a href="#2-4-3-行为型模式（关注对象之间的通信）" class="headerlink" title="2.4.3 行为型模式（关注对象之间的通信）"></a>2.4.3 行为型模式（关注对象之间的通信）</h4><h5 id="1-模板方法模式"><a href="#1-模板方法模式" class="headerlink" title="1. 模板方法模式"></a>1. 模板方法模式</h5><p>定义一套流程模板，根据需要实现模板中的操作</p>
<h5 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h5><p>封装不同的算法，算法之间能互相替换，组织这些算法的使用</p>
<h5 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3. 责任链模式"></a>3. 责任链模式</h5><p>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<h5 id="4-迭代器模式"><a href="#4-迭代器模式" class="headerlink" title="4. 迭代器模式"></a>4. 迭代器模式</h5><p>提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<h5 id="5-命令模式"><a href="#5-命令模式" class="headerlink" title="5. 命令模式"></a>5. 命令模式</h5><p>将请求封装成命令，并记录下来，能够撤销与重做</p>
<h5 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6. 状态模式"></a>6. 状态模式</h5><p> 当一个对象内在状态改变时允许其改变行为，根据不同的状态做出不同的行为</p>
<h5 id="7-备忘录模式"><a href="#7-备忘录模式" class="headerlink" title="7. 备忘录模式"></a>7. 备忘录模式</h5><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样有需要时就可将该对象恢复到原先保存的状态</p>
<h5 id="8-中介者模式"><a href="#8-中介者模式" class="headerlink" title="8. 中介者模式"></a>8. 中介者模式</h5><p>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</p>
<h5 id="9-解释器模式"><a href="#9-解释器模式" class="headerlink" title="9. 解释器模式"></a>9. 解释器模式</h5><p>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</p>
<h5 id="10-观察者模式"><a href="#10-观察者模式" class="headerlink" title="10. 观察者模式"></a>10. 观察者模式</h5><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于 它的对象都会得到通知并被自动更新</p>
<h5 id="11-访问者模式"><a href="#11-访问者模式" class="headerlink" title="11. 访问者模式"></a>11. 访问者模式</h5><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java各模块知识点总结</title>
    <url>/2022/01/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些关于Java各个知识点的个人总结，例如Java基础、集合、并发编程、JVM、Redis、MySQL、RabbitMQ等模块内容；</p>
<span id="more"></span>

<h2 id="Java-IO-amp-反射"><a href="#Java-IO-amp-反射" class="headerlink" title="Java IO &amp; 反射"></a>Java IO &amp; 反射</h2><h4 id="✨1-1-Java反射是什么？如何通过反射调用一个对象的方法？"><a href="#✨1-1-Java反射是什么？如何通过反射调用一个对象的方法？" class="headerlink" title="✨1.1 Java反射是什么？如何通过反射调用一个对象的方法？"></a>✨1.1 Java反射是什么？如何通过反射调用一个对象的方法？</h4><p>定义：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取信息以及动态调用对象方法的功能称为Java的反射机制<strong>（反射就是把Java类中的各种成分映射成一个个的Java对象）</strong></p>
<p>通过反射调用一个对象的方法（以user类为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>通过反射获取类中的对象</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> User.class;</span><br><span class="line"><span class="number">2.</span>创建运行时类的对象</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)clazz.newInstance();</span><br><span class="line"><span class="number">3.</span>获取方法</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;具体方法名&quot;</span>, <span class="string">&quot;需要传入的参数&quot;</span>);</span><br><span class="line"><span class="number">4.</span>通过invoke()进行调用</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(user);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-怎么利用反射获取类中的对象？"><a href="#1-2-怎么利用反射获取类中的对象？" class="headerlink" title="1.2 怎么利用反射获取类中的对象？"></a>1.2 怎么利用反射获取类中的对象？</h4><ul>
<li><p><strong>获取反射中类Class实例的方法（以获取String类实例为例子）</strong></p>
<ol>
<li>调用Class的静态方法：Class.forname(类全路径名)；</li>
</ol>
<p>当可以知道该类的全路径名时，推荐优先使用使用该方法获取 Class 类对象；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用运行时类的属性：类名.class</li>
</ol>
<p>这种方法只适合在编译前就知道要操作的 Class；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = String.class;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过运行时类的对象：对象名.getClass()；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = new String(&quot;Hello&quot;);</span><br><span class="line">Class clazz = str.getClass();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用类的加载器：ClassLoader；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = String.class.getClassLoader();</span><br><span class="line">Class clazz = classLoader.loadClass(&quot;java.lang.String&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>创建运行时类的对象</strong></p>
<ol>
<li><p>直接通过new关键字；</p>
</li>
<li><p>通过 Class类对象的 newInstance() 方法；</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = String.class;</span><br><span class="line">String str = (String)clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>​           3. 通过 Constructor构造器对象的 newInstance() 方法；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = String.class;</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br><span class="line">String str = (String)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>通过 Constructor 对象创建类对象可以选择指定的构造方法，包括无参和有参的构造器，而通过 Class 对象创建则只能使用默认的无参构造方法。</p>
<h4 id="2-BIO、NIO和AIO概念"><a href="#2-BIO、NIO和AIO概念" class="headerlink" title="2. BIO、NIO和AIO概念"></a>2. BIO、NIO和AIO概念</h4><ul>
<li><p><strong>BIO：同步并阻塞</strong>，服务器的实现模式是<strong>一个连接一个线程，即客户端有新的连接请求时服务器端就需要启动一个新线程进行处理</strong>，这样的模式很明显的一个缺陷是：由于客户端连接数与服务器线程数成正比关系，如果这个连接不做任何事情可能造成不必要的线程开销，严重的还将导致服务器内存溢出。这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。</p>
<ul>
<li><p><strong>BIO编程简单流程</strong></p>
<ol>
<li>服务器端启动一个ServerSocket</li>
<li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户各建立一个线程与之通讯</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后再继续执行</li>
</ol>
</li>
<li><p><strong>BIO存在问题</strong></p>
<ol>
<li>每个请求都需要创建独立的线程与对应的客户端进行数据交互</li>
<li>当并发数大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li><strong>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在读操作上，造成线程资源浪费</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>NIO：</strong>在JDK1.4以前，Java的IO模型一直是BIO，但从JDK1.4开始，JDK引入的新的IO模型NIO，它是<strong>同步非阻塞</strong>的。而服务器的实现模式是<strong>多个请求一个线程，即客户端发送的连接请求都会注册到多路复用器Selector上，多路复用器轮询到连接有IO请求时才启动一个线程处理</strong>。</p>
<ul>
<li><strong>不同于BIO基于字节流和字符流进行操作，NIO面向缓冲区或者说是面向块编程</strong>，数据线会先读取到一个稍后处理的缓冲区，需要时可在缓冲区中前后移动</li>
<li>NIO的非阻塞模式，使一个线程发送请求或者读取数据，但是它仅能得到目前可用的数据，<strong>如果目前没有数据可用时就什么都不会获取，而不是保持线程阻塞</strong>，所以知道数据变得可以读取之前，该线程可以继续做其他事情，非阻塞写操作同理，一个线程请求写入数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情；</li>
<li><strong>NIO其实是对BIO的进一步封装（在原生流中内置Channel）</strong></li>
</ul>
</li>
<li><p><strong>AIO：</strong>JDK1.7发布了NIO2.0，这就是真正意义上的<strong>异步非阻塞</strong>，服务器的实现模式为<strong>多个有效请求一个线程，只有有效的请求才启动线程，即先由操作系统完成后才通知服务端程序启动线程去处理</strong>（适用于连接数目多且连接时间较长的架构）</p>
</li>
</ul>
<h4 id="3-【NIO和BIO的主要区别】"><a href="#3-【NIO和BIO的主要区别】" class="headerlink" title="3.【NIO和BIO的主要区别】"></a>3.【NIO和BIO的主要区别】</h4><ul>
<li><strong>面向流与面向缓冲区</strong><br> Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区（buffer）的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li>
<li><strong>阻塞与非阻塞IO</strong><br> Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</li>
<li><strong>选择器（Selector）</strong><br> Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</li>
</ul>
<p><strong>NIO提供了与标准IO不同的IO工作方式：</strong></p>
<ul>
<li>Channel and Buffer（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</li>
<li>Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</li>
<li>Selector（选择器）：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</li>
</ul>
<h4 id="4-NIO的核心组件有哪几个？"><a href="#4-NIO的核心组件有哪几个？" class="headerlink" title="4.NIO的核心组件有哪几个？"></a>4.NIO的核心组件有哪几个？</h4><p><strong>NIO的三大核心组件：</strong>Channel通道、Buffer缓冲区、Selector选择器</p>
<ul>
<li><p><strong>NIO三大核心组件关系</strong></p>
<ol>
<li>每个Channel都会对应一个Buffer</li>
<li>一个Selector会对应一个线程，一个线程对应多个Channel</li>
<li>一般会有多个Channel注册到一个Selector程序</li>
<li>程序切换到具体哪个Channel是由事件（Event）决定的</li>
<li>Selector会根据不同的事件在各个通道上切换</li>
<li>Buffer本质就是一个内存块，底层是由一个数组组成</li>
<li>数据的读取写入是通过Buffer完成的，这个区别于BIO，BIO中不能双向读写，但NIO的Buffer是可以读可以写或者同时读写，需要使用flip()切换；Channel也是双向的</li>
</ol>
</li>
<li><p><strong>缓冲区Buffer</strong></p>
<ul>
<li>缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个**容器对象(含数组)**，Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都需要经由Buffer；</li>
<li>在NIO中Buffer是一个顶级父类，他是一个抽象类，其常用的子类有①ByteBuffer：存储字节数据到缓冲区；②CharBuffer：存储字符数据到缓冲区；</li>
<li>Buffer类定义了所有缓冲区都具有的四个属性：<ul>
<li><strong>Capacity</strong>：容量，既可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</li>
<li><strong>Limit</strong>：表示缓冲区的当前终点，不能对缓冲区超出极限的位置进行读写操作；极限是可以修改的</li>
<li><strong>Position</strong>：为止，指下一个要被读或写的元素的索引，每次读写缓冲区数据是都会改变该值，为下次读写做准备</li>
<li><strong>Mark</strong>：标记</li>
</ul>
</li>
</ul>
<ul>
<li>Buffer常用操作<ul>
<li><code>flip()</code>：反转读写模式</li>
<li><code>clear()或compact()</code>：清除缓冲区内容</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>通道Channel</strong></p>
<ul>
<li>不同于流只能读或者只能写，通道可以同时进行读写</li>
<li>通道可以实现异步读写数据，可以从缓冲区读数据，也可以向缓冲区写数据</li>
<li>Channel是一个接口，常用的Channel类有FileChannel、DatagramChannel、ServerSocketChannel和SocketChannel；<ul>
<li>FileChannel：用于文件的数据读写，</li>
<li>DatagramChannel：用于UDP的数据读写，</li>
<li>SocketChannel：用于TCP的数据读写</li>
<li>ServerSocketChannel：监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel，其本身并不传输数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>选择Selector</strong></p>
<ul>
<li>Selector能够检测多个注册的Channel上是否有事件发生（多个Channel以事件的方式可以注册到同一个Selector）</li>
</ul>
</li>
</ul>
<h4 id="5-select、poll和epoll的区别？（待补充）"><a href="#5-select、poll和epoll的区别？（待补充）" class="headerlink" title="5. select、poll和epoll的区别？（待补充）"></a>5. select、poll和epoll的区别？（待补充）</h4><ol>
<li>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标识位数组来存放，所以select会受到最大连接数的限制，而poll不会，而epoll采用红黑树存储也没有最大连接数限制；</li>
<li>select、poll、epoll虽然都会返回就绪的文件描述符数量，但select和poll并不会明确指出是哪些文件描述符处于就绪态，而epoll会。造成的区别就是系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪态，而epoll的epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。</li>
<li>select、poll都需要将有关文件描述符的数据结构从用户空间拷贝进内核之后再拷贝出来。而epoll执行epoll_create会在内核的高速cache区中建立一颗红黑树以及双向链表(该链表存储已经就绪的文件描述符，即触发了监听事件的socket)，接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点</li>
<li>select、poll采用轮询的方式对连接进行线性遍历来检查文件描述符是否处于就绪态，而epoll采用回调机制，在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在双向链表中。造成的结果就是随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。</li>
</ol>
<h4 id="6-说一说Linux的五种IO模型"><a href="#6-说一说Linux的五种IO模型" class="headerlink" title="6. 说一说Linux的五种IO模型"></a>6. 说一说Linux的五种IO模型</h4><p>概念解释：</p>
<ul>
<li><strong>阻塞与非阻塞</strong>：描述的是用户线程调用内核IO操作的方式。<ul>
<li>阻塞：IO操作需要彻底完成后才返回到用户空间；</li>
<li>非阻塞：IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成；</li>
</ul>
</li>
<li><strong>同步与异步</strong>：描述的是用户线程与内核的交互方式。<ul>
<li>同步：用户线程发起IO请求后，需要等待或者轮询内核IO操作完成后才能继续执行；</li>
<li>异步：用户线程发起IO请求后，仍继续执行其他操作，当内核IO操作完成后会通知用户线程或调用用户线程注册的回调函数；</li>
</ul>
</li>
</ul>
<p>五种IO模型介绍：</p>
<ul>
<li><p>同步IO（区别在于数据准备阶段处理有所不同，数据拷贝阶段处理都相同）</p>
<ul>
<li><p><strong>阻塞IO</strong></p>
<p>应用进程从发起 IO 系统调用后一直等待直到内核返回成功标识，<strong>即IO的数据准备和数据拷贝两个阶段都是处于阻塞状态的</strong>。</p>
</li>
<li><p><strong>非阻塞IO</strong></p>
<p>应用进程在发起 IO 系统调用后会立刻返回，应用进程可以轮询的发起 IO 系统调用直到内核返回成功标识，这期间<strong>数据准备阶段用户进程不断主动轮询进行系统调用处于非阻塞状态</strong>（发起一次调用后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好就返回状态码，进程在返回之后可以干别的事情，之后再进行调用），但是<strong>数据拷贝阶段仍是处于阻塞状态的</strong>。</p>
</li>
<li><p><strong>多路复用IO / 事件驱动IO</strong> </p>
<p><strong>多了一个多路复用器（select、poll、epoll函数），多个socket可以注册到同一个多路复用器上</strong>，当用户进程调用该多路复用器时，select会监听所有注册好的IO，数据准备阶段如果所有被监听的IO需要的数据都没有准备好时，<strong>select调用进程会同时阻塞所有IO</strong>。当其中任意一个IO所需的数据准备好之后即可读或可写，select就会对该socket进行返回，<strong>数据拷贝阶段仍是处于阻塞状态的</strong>。</p>
</li>
<li><p><strong>信号驱动IO</strong></p>
<p><strong>用户进程预先向内核注册一个信号处理函数，然后用户进程返回并且不阻塞</strong>，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。<strong>用户进程在数据准备阶段是非阻塞的，在数据拷贝阶段仍是阻塞的；注意与其他同步IO方式不同的是，信号驱动IO的数据准备阶段不需要轮询或等待，是异步的</strong>。</p>
</li>
</ul>
</li>
<li><p>异步IO</p>
<p>用户进程发起系统调用操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时如何通知进程，然后就立刻去做其他事情了。当内核收到系统调用命令后会立刻返回，然后内核开始等待数据准备，数据准备好以后直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。用户进程在两个阶段是非阻塞的，且内核在整体阶段是异步状态。</p>
</li>
</ul>
<h4 id="✨7-Maven的scope有哪几个？"><a href="#✨7-Maven的scope有哪几个？" class="headerlink" title="✨7. Maven的scope有哪几个？"></a>✨7. Maven的scope有哪几个？</h4><ol>
<li>compile：<strong>默认scope</strong>，运行期有效，需要打入包中</li>
<li>provided：编译期有效，运行期不需要提供，不会打入包中</li>
<li>runtime：编译期不需要，在运行期有效，需要导入包中</li>
<li>test：测试需要，不会打入包中</li>
<li>system：非本地仓库引入、存在系统的某个路径下的jar</li>
</ol>
<h4 id="✨8-String、StringBuilder和StringBuffer的区别？（待补充）"><a href="#✨8-String、StringBuilder和StringBuffer的区别？（待补充）" class="headerlink" title="✨8. String、StringBuilder和StringBuffer的区别？（待补充）"></a>✨8. String、StringBuilder和StringBuffer的区别？（待补充）</h4><h4 id="✨9-子类重写父类方法的规则"><a href="#✨9-子类重写父类方法的规则" class="headerlink" title="✨9. 子类重写父类方法的规则"></a>✨9. 子类重写父类方法的规则</h4><ul>
<li>参数列表和方法名与被重写方法的参数列表和方法名必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值类型的派生类。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。</li>
</ul>
<h4 id="✨10-子类中调用父类方法的规则"><a href="#✨10-子类中调用父类方法的规则" class="headerlink" title="✨10. 子类中调用父类方法的规则"></a>✨10. 子类中调用父类方法的规则</h4><ol>
<li>子类构造函数中想要调用父类构造函数，用super。</li>
<li>子类重写父类方法后，若想调用父类中被重写的方法，用super</li>
<li>调用父类中未被重写的方法可以直接调用，但子类不可以调用父类的私有方法。</li>
</ol>
<h2 id="✨👏Java集合"><a href="#✨👏Java集合" class="headerlink" title="✨👏Java集合"></a>✨👏Java集合</h2><h4 id="✨1-【介绍一下HashMap的底层实现原理】"><a href="#✨1-【介绍一下HashMap的底层实现原理】" class="headerlink" title="✨1.  【介绍一下HashMap的底层实现原理】"></a>✨1.  【介绍一下HashMap的底层实现原理】</h4><ul>
<li><strong>HashMap的底层是数组+链表+红黑树</strong>，基于hash算法实现的，存储对象时通过put(key,value)传入key，它调用hashCode()计算hash值，根据hash值将value保存到对应的bucket位置，获取对象时将key传给get()，它调用hashcode()计算hash值从而得到bucket位置，并进一步调用equals()确定键值对。</li>
</ul>
<p><strong>HashMap解决哈希冲突的方法：</strong></p>
<ul>
<li>当计算出的hash值相同时会发生hash冲突(即hash碰撞)，为了解决hash碰撞问题，HashMap通过链表将产生碰撞冲突的元素组织起来。在jdk1.8中，如果一个bucket中碰撞冲突的元素超过某个阈值(默认是8)，先会尝试进行数组扩容来减小链表长度，如果数组容量&gt;=64时，则会树化使用红黑树来替换链表。</li>
</ul>
<h4 id="✨2-为什么在解决哈希冲突时不直接用红黑树而先选择用链表，再转红黑树？"><a href="#✨2-为什么在解决哈希冲突时不直接用红黑树而先选择用链表，再转红黑树？" class="headerlink" title="✨2. 为什么在解决哈希冲突时不直接用红黑树而先选择用链表，再转红黑树？"></a>✨2. 为什么在解决哈希冲突时不直接用红黑树而先选择用链表，再转红黑树？</h4><p>因为红黑树是一种平衡二叉树，需要进行左旋、右旋、变色这些操作来保持平衡，而单链表不需要。当元素个数小于8个时，此时做查询操作链表结构已经能保证查询性能，当元素个数大于8个时，红黑树搜索时间复杂度是O(log n)，而链表是O(n)，此时可以用红黑树来加快查询速度，但会导致新增节点的效率变慢，因此假如一开始就用红黑树，元素个数少查询性能没提升且新增节点效率又比较慢。</p>
<h4 id="3-1【HashMap为什么说是线程不安全的？】"><a href="#3-1【HashMap为什么说是线程不安全的？】" class="headerlink" title="3.1【HashMap为什么说是线程不安全的？】"></a>3.1【HashMap为什么说是线程不安全的？】</h4><ul>
<li><strong>多线程下扩容会死循环：</strong>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容时有可能导致环形链表的出现形成死循环。到了JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>
<li><strong>多线程的put可能导致元素的丢失：</strong>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>
<li><strong>put和get并发时，可能导致get为null：</strong>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>
</ul>
<h4 id="3-2-【Arraylist为什么说是线程不安全的？】"><a href="#3-2-【Arraylist为什么说是线程不安全的？】" class="headerlink" title="3.2 【Arraylist为什么说是线程不安全的？】"></a>3.2 【Arraylist为什么说是线程不安全的？】</h4><p><strong>ArrayList的底层是数组队列</strong>，相当于一个动态数组，与数组不同的是容量可以动态增长；</p>
<ul>
<li><p><strong>并发环境下进行add操作时可能会导致elementData数组越界</strong></p>
<p>add()实际执行的过程并非原子操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elementData[size] = e;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="✨4-1【HashMap和HashTable的区别？】"><a href="#✨4-1【HashMap和HashTable的区别？】" class="headerlink" title="✨4.1【HashMap和HashTable的区别？】"></a>✨4.1【HashMap和HashTable的区别？】</h4><ol>
<li><strong>线程是否安全</strong>： HashMap 是非线程安全的，Hashtable 是线程安全的,  因为Hashtable内部的方法，例如chear()，基本都经过synchronized修饰。<strong>（如果你要保证线程安全的话就使用 ConcurrentHashMap ，HashTable基本被淘汰使用了）</strong></li>
<li><strong>对 Null key 和 Null value 的支持</strong>： HashMap允许key和value为null，但null作为键只能有一个，null作为值可以有多个；Hashtable 不允许key和value为null，否则会抛出NullPointerException。<strong>（使用ConcurrentHashMap，同Hashtable一样不允许key和value为null）</strong></li>
<li><strong>初始容量大小和每次扩充容量大小的不同</strong> ：HashTable中数组的默认大小是11，增加方式是old*2+1，HashMap中数组的默认大小是16，增加方式是2的指数倍；</li>
</ol>
<h4 id="✨4-2-【ArrayList和LinkedList的区别？】"><a href="#✨4-2-【ArrayList和LinkedList的区别？】" class="headerlink" title="✨4.2 【ArrayList和LinkedList的区别？】"></a>✨4.2 【ArrayList和LinkedList的区别？】</h4><ol>
<li><p>ArrayList的实现是基于动态数组，LinkedList的实现是基于<strong>双向链表</strong>。</p>
<ul>
<li><p>✨<strong>单链表和双向链表的区别：</strong></p>
<ol>
<li>单向链表只有一个指向下一结点的指针，双向链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针。</li>
<li>单向链表只能next ，双向链表可以return。</li>
<li>单链表只能单向读取，双向链表可以通过prev()快速找到前一结点。</li>
</ol>
<p><strong>单向链表优缺点：</strong></p>
<ol>
<li>优点：单向链表增加删除节点简单。遍历时候不会死循环；</li>
<li>缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。</li>
</ol>
<p><strong>双向链表优缺点：</strong></p>
<ol>
<li>优点：可以找到前驱和后继，可进可退；</li>
<li>缺点：增加删除节点复杂，多需要分配一个指针存储空间。</li>
</ol>
</li>
</ul>
</li>
<li><p>对于<strong>随机访问</strong>，ArrayList优于LinkedList，不需要像链式结构从头遍历。</p>
</li>
<li><p>对于<strong>插入和删除操作</strong>，LinkedList优于ArrayList，不需要像线性结构那样移动插入位置后面的数据。</p>
</li>
<li><p>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用指针；</p>
</li>
</ol>
<h4 id="✨5-【ConcurrentHashMap实现线程安全的底层原理是什么？】"><a href="#✨5-【ConcurrentHashMap实现线程安全的底层原理是什么？】" class="headerlink" title="✨5.【ConcurrentHashMap实现线程安全的底层原理是什么？】"></a>✨5.【ConcurrentHashMap实现线程安全的底层原理是什么？】</h4><ul>
<li>JDK7中的ConcurrentHashMap由Hash bucket数组组成，每个哈希桶数组切分成多个Segment数组，每个Segment数组中由多个HashEntry组成，即把数据分为一段段存储，然后给每一段数据配一把分段锁，当一个线程占有锁访问其中一段数据时，其他段的数据也能被同时其他线程访问，实现并发访问；<strong>Segment继承自ReentrantLock，其中有volatile修饰的HashEntry&lt;K, V&gt;[] table保证在数组扩容时的可见性</strong>；<strong>volatile修饰HashEntry中的属性value和指向下一个节点的指针next，保证了多线程环境下数据获取时的可见性，这也是ConcurrentHashMap的get()不需要加锁的原因</strong>；</li>
<li>JDK8中ConcurrentHashMap选择了与HashMap相同的Node数组+链表+红黑树结构，在锁的实现上抛弃了原有的Segment分段锁，采用CAS+synchronized实现更加细粒度的锁，只需要锁住链表的头节点（或者是红黑树的根节点），而不会影响其他Node数组元素的读写，进一步提高并发度；</li>
</ul>
<h4 id="6-ConcurrentHashMap不支持key或value为null的原因？"><a href="#6-ConcurrentHashMap不支持key或value为null的原因？" class="headerlink" title="6. ConcurrentHashMap不支持key或value为null的原因？"></a>6. ConcurrentHashMap不支持key或value为null的原因？</h4><p>因为ConcurrentHashMap是用于多线程的，如果通过get(key)得到了null，无法判断是映射的value值就为null，还是没有找到对应的key而为null，存在二义性；而key不支持为null是源码规定的，当key和value都为null时会抛出空指针异常；</p>
<h4 id="✨7-【谈谈HashMap的扩容机制】"><a href="#✨7-【谈谈HashMap的扩容机制】" class="headerlink" title="✨7. 【谈谈HashMap的扩容机制】"></a>✨7. 【谈谈HashMap的扩容机制】</h4><p><strong>什么时候扩容：</strong>一般情况下，<strong>当元素数量大于等于阈值时, 即当前容器内的元素个数大于当前数组的长度×负载因子的值</strong>时便会触发扩容，每次扩容的容量都是之前容量的2倍，并将原来的对象拷贝到新的数组中；</p>
<ul>
<li><strong>负载因子</strong>表示Hash表中元素的填满程度，负载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了，而<strong>负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率</strong>。</li>
</ul>
<p><strong>JDK7中的扩容机制：</strong></p>
<p>resize()中传入新的容量，引用扩容前的Entry数组后进行判断，如果扩容前的数组大小已经达到最大容量，则修改阈值为int的最大值，以后就不会扩容了；之后<strong>初始化一个新的Entry数组，将数据通过transfer()将原Entry数组的元素拷贝到新的Entry数组中</strong>，HashMap的table属性引用新的Entry数组，并修改新阈值=新容量×负载因子；</p>
<h5 id="7-1-HashMap在JDK8时扩容上做了哪些优化？（待补充）"><a href="#7-1-HashMap在JDK8时扩容上做了哪些优化？（待补充）" class="headerlink" title="7.1 HashMap在JDK8时扩容上做了哪些优化？（待补充）"></a>7.1 HashMap在JDK8时扩容上做了哪些优化？（待补充）</h5><h5 id="✨7-2-为什么HashMap扩容的时候是两倍？（待补充）"><a href="#✨7-2-为什么HashMap扩容的时候是两倍？（待补充）" class="headerlink" title="✨7.2 为什么HashMap扩容的时候是两倍？（待补充）"></a>✨7.2 为什么HashMap扩容的时候是两倍？（待补充）</h5><h4 id="8-谈谈ConcurrentHashMap的扩容机制（待补充）"><a href="#8-谈谈ConcurrentHashMap的扩容机制（待补充）" class="headerlink" title="8. 谈谈ConcurrentHashMap的扩容机制（待补充）"></a>8. 谈谈ConcurrentHashMap的扩容机制（待补充）</h4><p>当往ConcurrentHashMap如果新增节点之后，会调用addCount()重新计算map中的size，并检查是否需要进行扩容，当sizeCtl&gt;0.75n时就触发扩容逻辑，若所在链表的元素个数达到了阈值 8，则会调用treeifyBin())把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断，如果数组长度n小于阈值默认是64，则会调用tryPresize())把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。</p>
<ul>
<li><strong>扩容阈值sizeCtl关键点：</strong></li>
</ul>
<ol>
<li><p>sizeCtl在没有触发扩容时，是用来表示扩容阈值的，这时候sizeCtl是个正数，当map内数据数量达到这个阈值时，会触发扩容逻辑</p>
</li>
<li><p>当某个线程触发扩容时，会通过CAS修改sizeCtl值，修改的逻辑是将上面生成的扩容邮戳向左位移16位，然后+2，这时候由于符号位是1（因为邮戳的算法决定了把邮戳向左位移16位后，符号位是1），所以sizeCtl一定是个负数，也正是由于是cas操作，所以只会有一个线程cas成功并开启扩容流程，不会有多个扩容流程被开启。</p>
</li>
<li><p>当sizeCtl为负数时，说明在扩容中，这时候其他线程可以一起扩容，需要先通过cas将sizeCtl+1，这样可以通过sizeCtl的低16位来判断有多少并发线程在一起做扩容，从而判断哪个线程最后完成扩容，然后做收尾工作，这个收尾工作包括将当前对象的table指向新表，将sizeCtl重新设置成表示扩容阈值的正数等。</p>
</li>
</ol>
<ul>
<li><strong>扩容时的线程安全怎么做的？</strong><ol>
<li><strong>扩容线程间的并发场景：</strong>扩容线程间在进行任务分配时，是从数组尾部往头部以桶为单位截取，并且用来标记已分配区域的指针<code>transferIndex</code>是<code>volatile</code>修饰的，所以线程间是可见的，通过cas来修改<code>transferIndex</code>值，保证线程间没有重复的桶</li>
<li><strong>扩容线程与写线程的并发场景：</strong><ul>
<li>在触发扩容流程时，需要通过CAS将sizeCtl从正数改成负数，并且+2，这样只会有一个线程cas成功，避免其他的写线程也触发扩容流程。</li>
<li>扩容线程是遍历桶内的链表或者B树来rehash，如果往已经遍历的链表或者B树中插入新数据，扩容线程是无法感知到的，会导致新表中没有这些数据，<strong>对于空桶</strong>，不管是put操作还是扩容操作，都是通过cas操作来往空桶中添加数据，所以在出现并发往空桶写时，只会有一个线程成功，而不管是put的线程失败还是扩容的线程失败时，都会重新获取里面的值，再重新触发对应的put或者扩容逻辑，从而避免其他写线程往处于扩容中、扩容完毕的桶里写数据的并发问题；<strong>对于有数据的桶</strong>，put操作和扩容操作都是通过<code>synchronized</code>在桶上加锁来避免并发写问题；</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​        3. <strong>扩容线程与读线程之间的并发场景</strong>（<strong>ConcurrentHashMap.get(key)是没有加锁的，怎么保证在这个扩容过程中，其他线程的get(key)能获取到正确的值，不出现线程安全问题？</strong>）</p>
<ol>
<li><p><strong>在转移桶内数据时</strong>，不移动桶内数据并且不修改桶内数据的next指针，而是new一个新的node对象放到新表中，这样不会导致读取数据的线程在遍历链表时候因为next引用被更改而查询不到数据；</p>
</li>
<li><p><strong>在桶内数据迁移完后</strong>，在原table的桶内放一个<code>ForwardingNode</code>节点，通过这个节点的<code>find(k)</code>方法能获取到对应的数据；</p>
</li>
<li><p><strong>在整个扩容完成后</strong>，将新表引用赋值给<code>volatile</code>的变量table，这样更新引用的动作对其他线程可见；</p>
<p>从而保证在这三个过程中都能读取到正确的值。</p>
</li>
</ol>
<ul>
<li><p><strong>其他线程怎么感知到扩容状态，从而一起进行扩容？</strong></p>
<p>在对某个桶进行扩容时候，在完成扩容后会生成一个<code>ForwardingNode</code>放在旧表的对应下标的位置下，当有其他线程修改这个桶内数据时，如果发现这个类型的节点，就会一起进行扩容；</p>
</li>
</ul>
<h4 id="9-【谈谈ArrayList的扩容机制】"><a href="#9-【谈谈ArrayList的扩容机制】" class="headerlink" title="9. 【谈谈ArrayList的扩容机制】"></a>9. 【谈谈ArrayList的扩容机制】</h4><p>ArrayList扩容的本质是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去，默认情况下，新容量会是旧容量的1.5倍；</p>
<p><strong>JDK8中的扩容机制：</strong></p>
<ol>
<li>每次在add()一个元素时，ArrayList都会对这个elementData数组的容量进行判断是否能容纳元素，若能则直接添加到末尾，若不能则进行扩容后再把元素添加到末尾；</li>
<li>若要求的最低存储能力&gt;elementData数组的容量，说明ArrayList存储能力不足需要扩容，则调用**grow()<strong>进行扩容：获取elementData数组的内存空间长度后，扩容至原来的1.5倍，检验容量是否够和检查是否溢出后，调用</strong>Array.copyOf()**将elementData数组指向新的内存空间，并将elementData的数据复制到新的内存空间；</li>
</ol>
<h4 id="10-谈谈CopyOnWriteArraylist的底层实现原理？其与ReetrantReadWriteLock读写锁的区别？"><a href="#10-谈谈CopyOnWriteArraylist的底层实现原理？其与ReetrantReadWriteLock读写锁的区别？" class="headerlink" title="10. 谈谈CopyOnWriteArraylist的底层实现原理？其与ReetrantReadWriteLock读写锁的区别？"></a>10. 谈谈CopyOnWriteArraylist的底层实现原理？其与ReetrantReadWriteLock读写锁的区别？</h4><p>适用于<strong>读多写少</strong>的并发场景，CopyOnWriteArrayList容器允许并发读，读操作是无锁的，而写操作则<strong>首先将容器复制一份，然后在新副本上执行写操作并加锁，此过程中若有读操作则会作用在当前容器上使得读写分离，写入操作结束之后再将当前容器的引用指向新副本，用volatile保证切换过程对读线程立即可见</strong>；</p>
<p><strong>CopyOnWriteArraylist缺点：</strong></p>
<ul>
<li><strong>一是内存占用问题</strong>，每次执行写操作都要将原容器拷贝一份，在数据量大时对内存压力较大，可能会引起频繁GC；</li>
<li><strong>二是无法保证实时性，存在数据一致性问题</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList的写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li>
</ul>
<p><strong>与ReetranReadWriteLock读写锁的区别：</strong></p>
<p><strong>相同点</strong>：</p>
<ol>
<li><p>两者都是通过读写分离的思想实现；</p>
</li>
<li><p>读线程间是互不阻塞的（读读不互斥），写线程间是阻塞的（写写互斥）；</p>
</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li>ReetrantReadWriteLock对读线程而言，为了实现数据实时性，在写锁被获取后读线程和写线程都会等待，或者当读锁被获取后写线程会等待，即<strong>读写互斥</strong>，从而解决“脏读”等问题，也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。</li>
<li>CopyOnWriteArraylist读写在不同容器上所以<strong>读写不互斥</strong>，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况。</li>
</ol>
<h4 id="✨11-HashMap的put-流程？get-流程？（待补充）"><a href="#✨11-HashMap的put-流程？get-流程？（待补充）" class="headerlink" title="✨11. HashMap的put()流程？get()流程？（待补充）"></a>✨11. HashMap的put()流程？get()流程？（待补充）</h4><p>以JDK 1.8为例，首先根据key的值计算hash值找到该元素在数组中存储的下标，如果数组是空的则调用resize进行初始化；如果没有发生哈希冲突则直接放在对应的数组下标处；如果发生了哈希冲突且key已经存在，则覆盖掉value；如果发生哈希冲突后发现该节点是链表，判断该链表是否大于8，若大于8且数组容量小于64就进行数组扩容后插入键值对，若数组容量大于64则将链表转换为红黑树。</p>
<h4 id="12-ConcurrentHashMap的put-流程？get-流程？（待补充）"><a href="#12-ConcurrentHashMap的put-流程？get-流程？（待补充）" class="headerlink" title="12. ConcurrentHashMap的put()流程？get()流程？（待补充）"></a>12. ConcurrentHashMap的put()流程？get()流程？（待补充）</h4><ul>
<li>JDK 1.7时先会尝试获取锁，如果获取失败利用自旋方式获取锁，如果自旋重试的次数超过了64次，则改为阻塞获取锁；获取到锁后，将当前Segment通过key的hashcode定位到相应HashEntry数组，遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value，如果为空则新建一个HashEntry并加入Segment中，同时判断是否需要扩容，最后put()成功后释放Segment的锁；</li>
<li>JDK 1.8根据key计算出hash值，判断是否需要进行初始化，根据hash值定位到Node，拿到首节点f，对首节点f进行判断：如果f为null，则通过CAS的方式尝试添加；如果f.hash=MOVED=-1，说明其他线程在扩容，就参与一起扩容；如果都不满足，则synchronized锁住首节点f后遍历插入，当链表长度达到8时，数组扩容或将链表转换为红黑树；</li>
</ul>
<h4 id="✨13-TreeSet和HashSet的区别？"><a href="#✨13-TreeSet和HashSet的区别？" class="headerlink" title="✨13. TreeSet和HashSet的区别？"></a>✨13. TreeSet和HashSet的区别？</h4><ol>
<li><strong>底层使用的数据存储结构不同：</strong>Hashset底层是HashMap实现的，使用哈希表结构储存，而Treeset底层是TreeMap，使用二叉树结构储存；</li>
<li><strong>元素是否有序：</strong>HashSet中的元素是无序的，而TreeSet实现了SortedSet接口，可以确保集合元素处于排序状态，其是有序的；</li>
<li><strong>保证元素唯一方式不同：</strong>HashSet是通过hashCode()和equals()来保证的，而TreeSet是通过实现了Compareable接口的compareTo()来保证的;</li>
</ol>
<h4 id="✨14-Set集合是如何实现去重的？（Set集合去重原理）"><a href="#✨14-Set集合是如何实现去重的？（Set集合去重原理）" class="headerlink" title="✨14. Set集合是如何实现去重的？（Set集合去重原理）"></a>✨14. Set集合是如何实现去重的？（Set集合去重原理）</h4><ul>
<li><p><strong>HashSet去重原理：通过hashCode()和equals()是否都相同来比较</strong></p>
<p>put()中调用hashCode()先算出当前元素的哈希值，比较哈希值是否相同，通过equals()比较对象是否相等</p>
<ul>
<li><p>如果哈希值不同，则说明元素不相同，将元素添加到集合中；</p>
</li>
<li><p>如果哈希值相同，则继续判断equals()</p>
<ul>
<li>如果equals返回true，则说明元素的哈希值与内容都相同，该元素重复，不会添加到集合中；</li>
<li>如果equals返回false，则说明元素的哈希值相同，但内容不同，元素不重复，就添加到集合中；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TreeSet去重：compareTo()</strong></p>
<p>调用了comparaTo()，根据比较器的属性去重。如果compareTo()返回0，说明是重复的；如果是负数，则往前面排；如果是正数，往后面排。</p>
</li>
</ul>
<h2 id="✨👏Java并发编程"><a href="#✨👏Java并发编程" class="headerlink" title="✨👏Java并发编程"></a>✨👏Java并发编程</h2><h4 id="1-【请谈谈你对volatile、Java内存模型的理解】"><a href="#1-【请谈谈你对volatile、Java内存模型的理解】" class="headerlink" title="1. 【请谈谈你对volatile、Java内存模型的理解】"></a>1. 【请谈谈你对volatile、Java内存模型的理解】</h4><p>volatile是JVM提供的轻量级的同步机制，能<strong>保证可见性，不保证原子性，禁止指令重排保证有序性</strong></p>
<ul>
<li><p><strong>JMM（Java内存模型）</strong>并不真实存在，描述的是一组规范，定义了程序中各个变量的访问方式，它有三个特性是<strong>可见性、原子性和有序性</strong>；</p>
</li>
<li><p>JMM规定所有变量都存储在主内存，线程对变量的所有操作（读取、赋值等）必须在工作内存中进行，当需要对共享变量进行修改时，首先要将共享变量拷贝副本到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存；</p>
<ul>
<li><strong>可见性：</strong>当一个线程对主内存的共享变量进行了修改，其他线程能够收到通知得知该变量已经被修改。</li>
</ul>
</li>
<li><p><strong>volatile不保证原子性解释：</strong></p>
<ul>
<li><strong>原子性：</strong>即某个线程正在做某个具体业务时，中间不可以被加塞或者分割，操作需要整体完整。</li>
<li>一个线程a修改了共享变量的值但未写回主内存时，当不保证原子性就可能出现另一个线程b又对同一个共享变量进行操作，但此时a线程工作内存中的共享变量副本对线程b不可见，可能出现写数据丢失情况</li>
<li>如何解决volatile原子性问题？<ul>
<li><strong>使用JUC下的AtomicInteger类</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>volatile实现禁止指令重排优化</strong>，避免多线程环境下程序出现乱序执行的现象</p>
<ul>
<li><p><strong>有序性：</strong>不会发生指令重排保证代码原本的执行顺序</p>
</li>
<li><p><strong>内存屏障</strong>：又称为内存栅栏，作用有以下两个：</p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性（Lock前缀指令实现了volatile的内存可见性）</li>
</ol>
</li>
</ul>
<p>通过插入内存屏障禁止编译器和处理器在内存屏障前后的指令执行重排序优化，并且内存栅栏能强制刷出CPU的各种缓存数据，使线程都能读取到这些数据的最新版本</p>
<ul>
<li><strong>happen-before原则：</strong>规定了在一些特殊情况下不允许编译器和指令器对代码进行指令重排，保证代码的有序性；</li>
</ul>
</li>
<li><p>volatile使用场景：</p>
<p>volatile修饰单例对象的DCL（双端检索机制）的单例模式（原因在于DCl机制不一定线程安全，原因是有指令重排的存在，需要再加入volatile禁止指令重排）</p>
</li>
</ul>
<h4 id="2-【CAS底层实现原理是什么？】"><a href="#2-【CAS底层实现原理是什么？】" class="headerlink" title="2. 【CAS底层实现原理是什么？】"></a>2. 【CAS底层实现原理是什么？】</h4><p><strong>CAS（Compare and Swap 比较并交换）</strong>：比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作修改为新的值，否则继续比较直到主内存和工作内存中的值一致为止</p>
<ul>
<li><strong>CAS底层原理：</strong><ul>
<li><strong>Unsafe</strong>：是CAS的核心类，其所有方法都是native修饰，其内部方法操作可以像C的指针一样直接操作内存，基于此类可以直接操作特定内存的数据，<strong>CAS操作的执行依赖于Unsafe类的各个方法，可以说CAS就是一条CPU并发原语，功能是判断内存某个位置的值是否为预期值，如果是则更改为新值，不是则进行比较直到和预期值相等为止</strong>（原语的执行必须是连续的，在执行过程中不允许被中断，保证CAS的原子性）</li>
</ul>
</li>
<li><strong>CAS缺点：</strong><ul>
<li><strong>循环时间长开销大</strong>，如果CAS失败会一直进行尝试，长时间一直不成功可能会给CPU带来很大的开销；</li>
<li><strong>只能保证一个共享变量的原子操作</strong>，对多个变量操作时无法保证操作的原子性；</li>
<li><strong>会引来ABA问题</strong></li>
</ul>
</li>
</ul>
<h4 id="3-【使用Atomic原子类解决ABA问题】"><a href="#3-【使用Atomic原子类解决ABA问题】" class="headerlink" title="3. 【使用Atomic原子类解决ABA问题】"></a>3. 【使用Atomic原子类解决ABA问题】</h4><p><strong>问题简介：</strong>有两个线程同时去修改一个变量的值，比如线程1、线程2都去更新变量值，将变量值从A更新成B，线程1获取到CPU的时间片，线程2由于某些原因发生阻塞进行等待，此时线程1进行比较更新，成功将变量从A更新成B；更新完毕后，恰好又有线程3进来想把变量的值从B更新成A，线程3进行比较更新，成功将变量从B更新成A；线程2获取到CPU时间片然后进行比较更新，发现值是预期的A，然后就将其更新成B，此值就有了A-&gt;B-&gt;A的过程。</p>
<p><strong>如何避免ABA问题：</strong></p>
<ul>
<li>加版本号或者加时间戳（原子引用）<ul>
<li>（Atomic包下的<code>AtomicStampedReference类</code>：其<code>compareAndSet</code>方法首先检查<strong>当前引用是否等于预期引用</strong>，并且<strong>当前标志是否等于预期标志</strong>，如果全部相等，才会以原子方式将该引用的标志值设置为给定的更新值）</li>
</ul>
</li>
</ul>
<h4 id="4-【公平锁-非公平锁-可重入锁请谈谈你的理解？】"><a href="#4-【公平锁-非公平锁-可重入锁请谈谈你的理解？】" class="headerlink" title="4. 【公平锁/非公平锁/可重入锁请谈谈你的理解？】"></a>4. 【公平锁/非公平锁/可重入锁请谈谈你的理解？】</h4><ul>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的先后时间顺序来依次获得释放的锁；</li>
<li>非公平锁：在锁被释放时，任何一个等待该锁的线程都有机会获得锁（可能会造成优先级反转或者线程饥饿现象）；</li>
<li>可重入锁：又名<strong>递归锁</strong>，是指在同一个线程中，在外层方法获取锁的时候，进入内层方法会自动获取锁；</li>
</ul>
<h4 id="8-死锁编码及定位分析"><a href="#8-死锁编码及定位分析" class="headerlink" title="8. 死锁编码及定位分析"></a>8. 死锁编码及定位分析</h4><p><strong>死锁理解：</strong></p>
<p>线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请锁L1。因为锁是唯一的，两个线程都在等待对方释放自己需要的锁，所以两个线程都会停留在阻塞状态永远不会结束，这就导致了死锁。</p>
<p><strong>死锁定位：</strong></p>
<p>方法一：</p>
<ol>
<li><strong>jps</strong>查看死锁的线程pid</li>
<li>使用 <strong>jstack -l pid</strong> 查看死锁信息</li>
<li>通过查看所打印信息我们可以找到发生死锁的代码是在哪个位置</li>
</ol>
<p>方法二：通过Arthas（阿尔萨斯，阿里来源的Java诊断工具）的命令<strong>thread -b</strong> 就可以查看到死锁信息</p>
<h4 id="10-LockSupport是什么？（待补充）"><a href="#10-LockSupport是什么？（待补充）" class="headerlink" title="10. LockSupport是什么？（待补充）"></a>10. LockSupport是什么？（待补充）</h4><p>LockSupport类是用来创建锁和其他同步类的基本线程阻塞原语，其中的park()和unpack()的作用分别是阻塞线程和解除阻塞线程（可理解为线程等待唤醒机制wait/notify的增强版）</p>
<p><strong>三种让线程等待和唤醒的方法：</strong></p>
<ol>
<li><p>Object类中的wait和notify方法实现线程等待和唤醒</p>
<ul>
<li>wait和notify方法必须要在同步块或者同步方法里面且成对出现使用</li>
<li>必须要先wait后notify才能起作用</li>
</ul>
</li>
<li><p>Condition接口中的await和signal方法实现线程等待和唤醒</p>
<ul>
<li><strong>线程先要获得并持有锁，必须在锁块（synchronized或lock）中</strong></li>
<li><strong>必须要先等待后唤醒，线程才能够被唤醒</strong></li>
</ul>
</li>
<li><p>LockSupport类中的park等待和unpark唤醒</p>
<ul>
<li><p><strong>为什么可以先唤醒线程后阻塞线程？</strong></p>
<p>因为LOckSupport和每个使用它的线程都有一个许可关联permit，permit最多只有1个，默认是0，调用一次unpark就加1变成1.调用一次park会消费凭证将1变为0同时park立即返回，当再次调用park时会因为permit为0而阻塞，一直到调用unpark将permit变为1</p>
</li>
<li><p><strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞进程？</strong></p>
<p>因为凭证数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park需要消费两个凭证，证不够就不能放行</p>
</li>
</ul>
</li>
</ol>
<h4 id="11-【AQS的实现原理是什么？】"><a href="#11-【AQS的实现原理是什么？】" class="headerlink" title="11. 【AQS的实现原理是什么？】"></a>11. 【AQS的实现原理是什么？】</h4><p><strong>AQS，即抽象队列同步器（基于模板方法模式实现）</strong>（AbstractQueuedSynchronizer）<strong>使用一个volatile修饰的int型变量表示持有锁的同步状态State，通过内置的先进先出队列（底层是由同步队列+条件队列组成）来完成资源获取的排队工作，将每一条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS操作完成对同步状态值的修改</strong>；</p>
<ul>
<li>同步队列管理获取不到锁的线程的排队和释放，条件队列是在一定场景下对同步队列的补充，如获得锁的线程尝试从空队列中拿数据时，条件队列就管理该线程使其阻塞；</li>
</ul>
<p><strong>AQS中同步队列工作方式：</strong></p>
<p>当前线程获取同步状态失败，同步器将当前线程等待状态等信息构造成一个Node节点加入同步队列中放到队尾，同步器重新设置其为尾节点，加入队列后会阻塞当前线程；当同步状态被释放时同步器重新设置头节点，同步器唤醒同步队列中的第一个节点，让其获取同步状态并成为新的头节点</p>
<p><strong>AQS定义对资源的共享方式：</strong></p>
<ul>
<li><strong>独占式：</strong>只有一个线程能执行，如ReentrantLock，又可分为公平锁和非公平锁<ul>
<li>公平锁：按照线程在队列中的排队顺序获取锁</li>
<li>非公平锁：当线程要获取锁是，无视队列排队顺序竞争去抢占获取锁</li>
</ul>
</li>
<li><strong>共享式：</strong>多个线程可同时执行，如下文的各个AQS组件</li>
</ul>
<p><strong>JUC中和AQS相关的同步组件（JUC辅助类）：</strong>ReentrantLock、CountDownLatch、Semaphore、CyclicBarrier</p>
<h5 id="11-1-Semaphore信号量"><a href="#11-1-Semaphore信号量" class="headerlink" title="11.1 Semaphore信号量"></a>11.1 <strong>Semaphore信号量</strong></h5><ul>
<li>区别于<code>synchronized</code> 和 <code>ReentrantLock</code> 一次只允许一个线程访问某个资源，<code>Semaphore</code>可以指定多个线程同时访问某个资源</li>
</ul>
<ul>
<li>执行 <code>acquire()</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code>acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，<code>Semaphore</code> 只是维持了一个可获得许可证的数量，<code>Semaphore</code> 经常用于限制获取某种资源的线程数量。<code>tryAcquire()</code> 方法则是如果获取不到许可就立即返回 false；</li>
</ul>
<h5 id="11-2-CountDownLatch倒计时器"><a href="#11-2-CountDownLatch倒计时器" class="headerlink" title="11.2 CountDownLatch倒计时器"></a>11.2 <strong>CountDownLatch倒计时器</strong></h5><ul>
<li><p><code>CountDownLatch</code> 协调多个线程之间的同步控制线程等待，允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
</li>
<li><p><code>CountDownLatch</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时，其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
</li>
<li><p><strong>CountDownLatch 的两种典型用法</strong></p>
<ol>
<li><strong>某一线程在开始运行前等待 n 个线程执行完毕</strong>。</li>
</ol>
<p>将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 CountDownLatch 上 await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
<ol start="2">
<li><strong>实现多个线程开始执行任务的最大并行性</strong>。</li>
</ol>
<p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p>
</li>
<li><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用；</p>
</li>
</ul>
<h5 id="11-3-CyclicBarrier循环栅栏"><a href="#11-3-CyclicBarrier循环栅栏" class="headerlink" title="11.3 CyclicBarrier循环栅栏"></a>11.3 CyclicBarrier循环栅栏</h5><ul>
<li><code>CyclicBarrier</code> 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会解除，所有被屏障拦截的线程才会继续执行</li>
<li><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过</li>
<li><code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。</li>
</ul>
<h4 id="✨12-【Synchronized的底层原理是什么？】"><a href="#✨12-【Synchronized的底层原理是什么？】" class="headerlink" title="✨12. 【Synchronized的底层原理是什么？】"></a>✨12. 【Synchronized的底层原理是什么？】</h4><p>Synchronized是一种实现同步互斥的方式，<strong>被Synchronized修饰过的代码块在编译前后会被编译器生成monitorenter和monitorexit两个字节码指令，在虚拟机执行到monitorenter指令时，首先尝试获取对象的锁，如果这个对象没有锁定或者当前线程已经拥有了这个锁，则把锁的计数器+1；当执行monitorexit指令时将锁计数器-1；当计数器为0时锁就被释放，通过在对象头设置标记达到获取锁和释放锁的目的</strong>；</p>
<h5 id="12-为什么说synchronized是非公平锁？"><a href="#12-为什么说synchronized是非公平锁？" class="headerlink" title="12. 为什么说synchronized是非公平锁？"></a>12. 为什么说synchronized是非公平锁？</h5><ol>
<li>当持有锁的线程释放锁时，该线程会执行两个操作：先将锁的持有者owner属性赋为为null，再去唤醒等待链表中的其中一个线程，当两个操作之间如果有其他线程刚好在尝试获取锁就可以马上获取到锁；</li>
<li>当线程尝试获取锁失败进入阻塞时，其放入等待链表的顺序和最终被唤醒的顺序不一定是一致的；</li>
</ol>
<h4 id="15-乐观锁一定是好的吗？"><a href="#15-乐观锁一定是好的吗？" class="headerlink" title="15. 乐观锁一定是好的吗？"></a>15. 乐观锁一定是好的吗？</h4><p>乐观锁虽然避免了悲观锁独占对象的同时也提高了并发性能，但是它有如下缺点：</p>
<ol>
<li>乐观锁只能保证一个共享变量的原子操作；</li>
<li>采用自旋锁的方式（当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环），长时间不成功一直自旋会导致CPU开销大；</li>
<li>会造成ABA问题（原因在于CAS的核心思想是通过比对内存值与预期值是否一样而判断内存之是否被改过，并不在意中途是否发生过变化），可引入版本号解决；</li>
</ol>
<h4 id="✨16-【与Synchronized相比，可重入锁ReentrantLock的实现原理有什么不同？】"><a href="#✨16-【与Synchronized相比，可重入锁ReentrantLock的实现原理有什么不同？】" class="headerlink" title="✨16. 【与Synchronized相比，可重入锁ReentrantLock的实现原理有什么不同？】"></a>✨16. 【与Synchronized相比，可重入锁ReentrantLock的实现原理有什么不同？】</h4><p><strong>其实锁的实现原理基本都是为了达到一个目的：让所有线程都能看到某种标记</strong>，Synchronized通过在对象头中设置标记实现这一目的，而ReentrantLock以及所有基于Lock接口的实现类，都是<strong>通过用volitile修饰的int型变量</strong>，保证每个线程都拥有对该变量的可见性，本质是基于AQS；</p>
<h5 id="16-1-了解ReentrantLock吗？"><a href="#16-1-了解ReentrantLock吗？" class="headerlink" title="16.1 了解ReentrantLock吗？"></a>16.1 了解ReentrantLock吗？</h5><p>ReetrantLock是一个可重入的独占锁，支持公平锁和非公平锁，<strong>其实现依赖于AQS维护一个阻塞队列，多个线程需要加锁时，竞争失败者会进入阻塞队列等待唤醒，之后重新尝试加锁</strong>；</p>
<p>其有两个特性：一是可重入，二是可以指定公平或非公平</p>
<ul>
<li><p><strong>可重入</strong>：指获取独占资源的线程可以重复地获取该独占资源，不需要重复请求；</p>
<ul>
<li>在请求独占资源时，ReentrantLock都会判断当前持有独占资源的线程是不是当前线程，如果是的话，只是简单地将state值加1后再记录设置当前线程的重入次数。</li>
<li>释放独占资源的时候，都会调用tryRelease()，只有state值为0的时候才会释放资源。即<strong>重入多少次就必须释放多少次</strong>。</li>
</ul>
</li>
<li><p><strong>公平与非公平</strong>：在new ReetrantLock对象的时候，可以指定其支持公平锁还是非公平锁</p>
<ul>
<li>当设置为公平锁时，FairSync继承Sync，ReentrantLock调用lock方法，最终会调用sync的tryAcquire函数获取资源。FairSync的tryAcquire函数设置if语句，<strong>当前线程只有在队列为空或者是队首节点的时候，才能获取资源，否则会被加入到阻塞队列中。</strong></li>
<li>当设置为非公平锁时，</li>
<li>NoFairSync同样继承Sync，ReentrantLock调用lock方法，最终会调用sync的tryAcquire函数获取资源。而NoFairSync的tryAcquire函数，会调用父类Sync的方法nofairTryAcquire函数，<strong>如果资源释放时，新的线程会尝试CAS操作获取资源，而不管阻塞队列中是否有先于其申请的线程。</strong></li>
</ul>
</li>
</ul>
<h5 id="16-2-了解ReadWriteLock吗？"><a href="#16-2-了解ReadWriteLock吗？" class="headerlink" title="16.2 了解ReadWriteLock吗？"></a>16.2 了解ReadWriteLock吗？</h5><p>ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是其一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，只有读和写、写和读、写和写之间才会互斥；</p>
<h5 id="16-3-ReentrantReadWriteLock实现原理是什么？"><a href="#16-3-ReentrantReadWriteLock实现原理是什么？" class="headerlink" title="16.3 ReentrantReadWriteLock实现原理是什么？"></a>16.3 ReentrantReadWriteLock实现原理是什么？</h5><p>适用于<strong>读多写少</strong>的并发场景，读写锁内部维护了一个ReadLock和一个WriteLock，基于AQS实现，使用一个state通过“按位切割”的方式实现表示读和写两种状态：state的高16位表示读状态即获取到的读锁的次数；使用低16位表示写状态即获取到写锁的线程的可重入次数；</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">为什么要把一个 int 类型变量拆成两半，而不是用两个int型变量分别表示读锁和写锁的状态呢？</span><br><span class="line">这是因为无法用一次CAS同时操作两个int变量，所以用了一个int型的高16位和低16位分别表示读锁和写锁的状态。当state=0时，说明既没有线程持有读锁，也没有线程持有写锁；当state！=0时，要么有线程持有读锁，要么有线程持有写锁，两者不能同时成立，因为读和写互斥。这时再进一步通过sharedCount(state)和exclusiveCount(state)判断到底是读线程还是写线程持有了该锁，通过CAS操作实现读写分离；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>写锁的获取与释放：</p>
<ul>
<li><strong>获取写锁</strong>：写锁是一个支持重入的独占锁，tryAcquire()获取独占锁；如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁或者写锁已被其他线程获取，则当前线程进入等待状态；</li>
<li><strong>释放写锁</strong>：写锁的释放与ReentrantLock的释放过程基本类似，tryRelease()每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读、写线程能够继续访问读写锁，同时前次写线程的修改对后续的读线程可见。</li>
</ul>
</li>
<li><p>读锁的获取与释放：</p>
<p>读锁是一个支持重入的共享锁，它能够被多个线程同时获取；读状态是所有线程获取读锁的总和，而每个线程各自获取读锁的次数保存在ThreadLocal中，由线程自身维护。</p>
<ul>
<li><strong>获取读锁</strong>：tryAcquireShared() 获取共享锁，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入阻塞等待状态。如果当前线程获取了写锁或写锁未被占用，则当前线程增加读状态，成功获取锁。</li>
<li><strong>释放读锁</strong>：tryReleaseShared() 利用for循环通过自旋的方式不停的更改读锁状态直到更新为0，成功释放读锁。</li>
</ul>
</li>
<li><p>锁降级：指写锁可以降级为读锁。如果当前线程拥有写锁，在不释放写锁的情况下，是可以在获取读锁的，获取到读锁后再释放先前获取到的写锁。</p>
<ul>
<li><strong>锁降级的必要性</strong>：主要是为了<strong>保证数据的可见性</strong>，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放写锁之后，线程T才能获取写锁进行数据更新；</li>
</ul>
</li>
</ul>
<h4 id="17-Java-中用到的线程调度算法有哪些？"><a href="#17-Java-中用到的线程调度算法有哪些？" class="headerlink" title="17. Java 中用到的线程调度算法有哪些？"></a>17. Java 中用到的线程调度算法有哪些？</h4><p>有两种调度模型：<strong>分时调度模型和抢占式调度模型</strong>。 </p>
<ul>
<li>分时调度模型是指让所有的线程采用<strong>时间片轮转</strong>的方式轮流获得CPU的使用权，并且平均分配每个线程占用的CPU时间片；</li>
<li>JVM采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程使其占用 CPU。</li>
</ul>
<h4 id="18-为什么使用Executor框架而不是直接new-Thread-）"><a href="#18-为什么使用Executor框架而不是直接new-Thread-）" class="headerlink" title="18. 为什么使用Executor框架而不是直接new Thread(）"></a>18. 为什么使用Executor框架而不是直接new Thread(）</h4><ol>
<li>每次执行任务创建线程都new Thread()比较<strong>消耗性能</strong>；</li>
<li>调用new Thread()创建的线程<strong>缺乏管理，而且可以无限制的创建</strong>， 线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源；</li>
<li>直接使用new Thread() 启动的线程<strong>不利于扩展</strong>，比如定时执行、定期执行、线程中断等都不便实现。</li>
</ol>
<h4 id="19-【什么是阻塞队列？阻塞队列的实现原理是什么？阻塞队列的种类有哪些？】"><a href="#19-【什么是阻塞队列？阻塞队列的实现原理是什么？阻塞队列的种类有哪些？】" class="headerlink" title="19. 【什么是阻塞队列？阻塞队列的实现原理是什么？阻塞队列的种类有哪些？】"></a>19. 【什么是阻塞队列？阻塞队列的实现原理是什么？阻塞队列的种类有哪些？】</h4><p><strong>阻塞队列（BlockingQueue）</strong>：是一个支持两个附加操作的队列。 这两个附加的操作是：在队列为空时，获取元素的线程即消费者会等待队列变为非空。当队列满时，添加元素的线程即生产者会等待队列可用。</p>
<p><strong>阻塞队列的实现原理：</strong>当生产者线程试图向阻塞队列添加元素时，如果队列已满则线程会被阻塞；当消费者线程试图从中获取元素时，如果队列为空则该线程也会被阻塞；</p>
<p><strong>阻塞队列的类型有如下几种：</strong></p>
<ul>
<li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列。</li>
<li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列，但是不设置大小时就是Integer.MAX_VALUE。</li>
<li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。 </li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<h4 id="20-在-Java中CyclicBarriar循环栅栏和CountdownLatch倒计时器有什么区别？"><a href="#20-在-Java中CyclicBarriar循环栅栏和CountdownLatch倒计时器有什么区别？" class="headerlink" title="20. 在 Java中CyclicBarriar循环栅栏和CountdownLatch倒计时器有什么区别？"></a>20. 在 Java中CyclicBarriar循环栅栏和CountdownLatch倒计时器有什么区别？</h4><ol>
<li>CountDownLatch 简单的说就是<strong>一个线程等待</strong>，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行；</li>
<li>CyclicBarrier 是<strong>所有线程都进行等待</strong>，直到所有线程到达进入 await()方法之后，所有线程同时开始执行；</li>
<li>CountDownLatch 的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset() 方法重置实现多次使用。</li>
</ol>
<h4 id="21-SynchronizedMap-和-ConcurrentHashMap有什么区别？（待补充）"><a href="#21-SynchronizedMap-和-ConcurrentHashMap有什么区别？（待补充）" class="headerlink" title="21. SynchronizedMap 和 ConcurrentHashMap有什么区别？（待补充）"></a>21. SynchronizedMap 和 ConcurrentHashMap有什么区别？（待补充）</h4><ul>
<li>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map；</li>
<li>ConcurrentHashMap使用分段锁来保证在多线程下的性能，ConcurrentHashMap 中则是一次锁住一个桶，其默认将 hash 表分为16 个桶（segment），操作只锁当前需要用到的桶，即最多同时可以有 16 条线程操作 ConcurrentHashMap；</li>
</ul>
<h4 id="22-Java-线程池中-submit-和-execute-方法有什么区别？"><a href="#22-Java-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="22. Java 线程池中 submit() 和 execute()方法有什么区别？"></a>22. Java 线程池中 submit() 和 execute()方法有什么区别？</h4><p>两个方法都可以向线程池提交任务；</p>
<ul>
<li>execute()方法的返回类型是 void，它定义在 Executor 接口中，用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 </li>
<li>submit()方法定义在 ExecutorService 接口中，用于提交需要返回值的任务，线程池会返回一个持有计算结果的 Future 类型对象，可以通过这个Future对象判断任务是否执行成功。</li>
</ul>
<h4 id="23-ThreadLocal-是什么以及作用是什么？（待补充）"><a href="#23-ThreadLocal-是什么以及作用是什么？（待补充）" class="headerlink" title="23. ThreadLocal 是什么以及作用是什么？（待补充）"></a>23. ThreadLocal 是什么以及作用是什么？（待补充）</h4><p>ThreadLocal ，即线程本地变量。</p>
<p>如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量时，实际是操作自己本地拷贝里的变量，从而<strong>起到线程隔离的作用</strong>，避免了线程安全问题；</p>
<p>应用场景：数据库连接池、会话管理；</p>
<h5 id="23-1-ThreadLocal的实现原理（待补充）"><a href="#23-1-ThreadLocal的实现原理（待补充）" class="headerlink" title="23.1 ThreadLocal的实现原理（待补充）"></a>23.1 ThreadLocal的实现原理（待补充）</h5><h5 id="23-2-ThreadLocal的内存泄露问题（待补充）"><a href="#23-2-ThreadLocal的内存泄露问题（待补充）" class="headerlink" title="23.2 ThreadLocal的内存泄露问题（待补充）"></a>23.2 ThreadLocal的内存泄露问题（待补充）</h5><h4 id="25-如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#25-如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="25. 如果你提交任务时，线程池队列已满，这时会发生什么？"></a>25. 如果你提交任务时，线程池队列已满，这时会发生什么？</h4><ol>
<li>如果使用的是无界队列比如不设置大小的LinkedBlockingQueue，会继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务；</li>
<li>如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来， ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是AbortPolicy；</li>
</ol>
<h4 id="26-为什么不能直接调用run-方法，而要先调用start-再执行run-？"><a href="#26-为什么不能直接调用run-方法，而要先调用start-再执行run-？" class="headerlink" title="26. 为什么不能直接调用run()方法，而要先调用start()再执行run()？"></a>26. 为什么不能直接调用run()方法，而要先调用start()再执行run()？</h4><p>new Thread()后线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作；</p>
<h4 id="27-了解Fork-Join框架吗？（待补充）"><a href="#27-了解Fork-Join框架吗？（待补充）" class="headerlink" title="27. 了解Fork/Join框架吗？（待补充）"></a>27. 了解Fork/Join框架吗？（待补充）</h4><ul>
<li>Fork/Join框架是一个用于并行执行任务的框架，把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果，体现了分而治之的思想；</li>
<li><strong>工作窃取算法：</strong>某个线程从其他队列中窃取任务来进行执行的过程，一般是指做得快的线程（盗窃线程）抢慢的线程的任务来做；（为了减少锁竞争，使用双端队列，将快线程和慢线程各放在一端）</li>
</ul>
<h4 id="28-【JDK-1-6后对Synchronized的锁优化有哪些？】"><a href="#28-【JDK-1-6后对Synchronized的锁优化有哪些？】" class="headerlink" title="28. 【JDK 1.6后对Synchronized的锁优化有哪些？】"></a>28. 【JDK 1.6后对Synchronized的锁优化有哪些？】</h4><ol>
<li><strong>锁膨胀（锁升级）</strong><ul>
<li><strong>偏向锁</strong>：目的在于减少同一线程获取锁的代价；（<strong>当一个线程获得锁时，锁就进入偏向模式</strong>，当该线程再次请求锁时，无需再做任何同步操作，只需要检查锁标记位以及当前线程ID即可获取锁）；</li>
<li><strong>轻量级锁</strong>：由偏向锁升级而来，当<strong>存在第二个线程申请同一个锁对象</strong>时，偏向锁就会升级为轻量级锁，不存在两个线程同时竞争锁，可以是一前一后交替执行同步块；</li>
<li><strong>重量级锁</strong>：由轻量级锁升级而来，当<strong>同一时间有多个线程竞争同一个锁</strong>时，锁就会升级为重量级锁，其使用场景会在追求吞吐量、同步块或者同步方法执行时间较长的场景；</li>
</ul>
<strong>锁升级原理：</strong>在锁对象的对象头有一个threadid字段，在第一次访问时threadid为空，JVM让其持有偏向锁，并将threadid设置为其线程id，再次进入时先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致则升级为轻量级锁通过自旋方式获取锁，执行一定次数后如果还没有正常获取锁，则升级为重量级锁；</li>
<li><strong>锁消除</strong><ul>
<li>在虚拟机即时编译器运行时，对运行上下文进行扫描，消除不可能存在共享数据竞争的锁（例如去除的锁为私有变量时，并不存在竞争关系）</li>
</ul>
</li>
<li><strong>锁粗化</strong><ul>
<li>通过扩大锁同步的范围，避免反复对同一个对象加锁和释放锁</li>
</ul>
</li>
<li><strong>自旋锁与自适应自旋锁</strong><ul>
<li><strong>自旋锁</strong>：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取，该线程将会执行固定次数的循环，间隔一段时间后会再次尝试获取锁，如果获取失败则再次等待锁的释放，这种采用循环尝试加锁 -&gt; 等待的机制被称为自旋锁；</li>
<li><strong>自适应自旋锁</strong>：对自旋锁进一步优化，其自旋次数不再固定，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定；</li>
</ul>
</li>
</ol>
<h4 id="29-【为什么使用线程池？】"><a href="#29-【为什么使用线程池？】" class="headerlink" title="29. 【为什么使用线程池？】"></a>29. 【为什么使用线程池？】</h4><h5 id="✨29-0-创建线程有哪些方式？"><a href="#✨29-0-创建线程有哪些方式？" class="headerlink" title="✨29.0 创建线程有哪些方式？"></a>✨29.0 创建线程有哪些方式？</h5><ol>
<li>继承Thread类创建线程；</li>
<li>实现Runnable接口创建线程；</li>
<li>使用Callable和Future创建线程；（和Runnable接口不一样，Callable接口提供了一个call()作为线程执行体，call()可以有返回值，并且可以声明抛出异常）</li>
<li>使用线程池创建线程；</li>
</ol>
<p>使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗：</strong>通过重复利用已创建的线程降低线程创建和销毁造成的资源消耗；</li>
<li><strong>提高响应速度：</strong>当任务到达时，任务可以不需要等待线程创建就能立即执行；</li>
<li><strong>提高线程可管理性：</strong>使用线程池可以对线程进行统一的分配、调优和监控，避免了线程无限制的创建；</li>
</ul>
<h5 id="✨29-1-说下线程池实现类ThreadPoolExecutor核心参数配置"><a href="#✨29-1-说下线程池实现类ThreadPoolExecutor核心参数配置" class="headerlink" title="✨29.1 说下线程池实现类ThreadPoolExecutor核心参数配置"></a>✨29.1 说下线程池实现类ThreadPoolExecutor核心参数配置</h5><ul>
<li>【corePoolSize】：核心线程数量；定义了<strong>最小可以同时运行的线程数量</strong>，只要线程池一直运行核心线程就不会停止；</li>
<li>【maximumPoolSize】：线程池最大线程数量（等于核心线程数+非核心线程数），<strong>当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</strong>；</li>
<li>keepAliveTime：非核心线程的最长存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程（即非核心线程）不会立即销毁而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li>【workQueue】：阻塞队列，用来存放线程任务，<strong>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</strong>；</li>
<li>threadFactory：线程工厂，用于新建线程</li>
<li>handler：饱和策略（拒绝策略）<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong> ：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong> ：不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong> ： 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</li>
</ul>
<h5 id="✨29-2-线程池执行任务的流程（实现原理）？"><a href="#✨29-2-线程池执行任务的流程（实现原理）？" class="headerlink" title="✨29.2 线程池执行任务的流程（实现原理）？"></a>✨29.2 线程池执行任务的流程（实现原理）？</h5><ol>
<li>线程池执行execute() / submit()向线程池添加任务，当任务数小于核心线程数corePoolSize时，线程池中可以创建新的线程；</li>
<li>当任务数大于核心线程数corePoolSize时就向阻塞队列中添加任务；</li>
<li>如果阻塞队列已满，需要通过比较线程池最大线程数量maximumPoolSize后再在线程池创建新的非核心线程，<strong>当线程需求数量大于maximumPoolSize</strong>，说明当前设置线程池中线程已经无法处理新的任务，就会执行饱和策略。</li>
</ol>
<h5 id="29-3-常用的Java线程池类型有哪些？"><a href="#29-3-常用的Java线程池类型有哪些？" class="headerlink" title="29.3 常用的Java线程池类型有哪些？"></a>29.3 常用的Java线程池类型有哪些？</h5><ul>
<li><p>FixedThreadPool：可重用固定线程数的线程池，<code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为固定值</p>
</li>
<li><p>SingleThreadExecutor：只有一个线程的线程池，<code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为1</p>
<p><code>FixedThreadPool</code> 和<code>SingleThreadExecutor</code>使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列，可能会导致OOM</p>
</li>
<li><p>CachedThreadPool：会根据需要创建新线程的线程池，<code>corePoolSize</code> 被设置为0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下会导致耗尽CPU和内存资源，从而导致OOM</p>
</li>
<li><p>ScheduledThreadPoolExecutor：主要用来在给定的延迟后运行任务，或者定期执行任务。 这个在实际项目中基本不会被用到，也不推荐使用</p>
</li>
</ul>
<h5 id="29-4-线程池常用的阻塞队列有哪些？"><a href="#29-4-线程池常用的阻塞队列有哪些？" class="headerlink" title="29.4 线程池常用的阻塞队列有哪些？"></a>29.4 线程池常用的阻塞队列有哪些？</h5><p>详情见19关于阻塞队列的介绍；</p>
<h5 id="29-5-【如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？】"><a href="#29-5-【如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？】" class="headerlink" title="29.5 【如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？】"></a>29.5 【如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？】</h5><p>必然会导致线程池中的积压任务都丢失</p>
<p><strong>解决办法：</strong>在提交一个任务到线程池中之前，可以先在数据库中插入这个任务的信息，更新该任务的状态为未提交，提交成功之后更新其状态为已提交状态；当系统任务宕机重启后，后台线程去扫描数据库中的未提交和已提交状态的任务，可以把任务的信息读取出来重新提交到线程池中去，继续进行执行。</p>
<h2 id="✨JVM"><a href="#✨JVM" class="headerlink" title="✨JVM"></a>✨JVM</h2><h4 id="3-说下你平时工作用过的JVM常用基本配置参数有哪些？"><a href="#3-说下你平时工作用过的JVM常用基本配置参数有哪些？" class="headerlink" title="3. 说下你平时工作用过的JVM常用基本配置参数有哪些？"></a>3. 说下你平时工作用过的JVM常用基本配置参数有哪些？</h4><ul>
<li>-Xms：用于表示堆区的起始内存，等价于-XX：InitialHeapSize</li>
<li>-Xmx：用于表示堆区的最大内存，等价于-XX：MaxHeapSize，一旦堆区内存大小超过指定的最大内存时，将会抛出OutOfMemory异常（通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小从而提高性能</strong>）</li>
<li>-Xmn：用于表示堆区中新生代的大小</li>
<li>-Xss：用于表示每个线程的栈内存大小</li>
</ul>
<h4 id="4-强引用、软引用、弱引用、虚引用分别是什么？有什么区别？"><a href="#4-强引用、软引用、弱引用、虚引用分别是什么？有什么区别？" class="headerlink" title="4. 强引用、软引用、弱引用、虚引用分别是什么？有什么区别？"></a>4. 强引用、软引用、弱引用、虚引用分别是什么？有什么区别？</h4><ul>
<li>强引用：就是普通的对象引用关系，不会GC被回收</li>
<li>软引用：<strong>只有在内存不足时才会被GC回收</strong>，如果回收了软引用对象之后仍然没有足够内存，才会抛出OOM内存溢出异常</li>
<li>弱引用：当JVM进行GC垃圾回收时，<strong>无论内存是否充足一旦发现都会回收</strong>弱引用对象</li>
<li>虚引用：用来跟踪对象被垃圾回收的活动</li>
</ul>
<h4 id="5-常见发生OOM（out-of-memory）的原因及解决办法"><a href="#5-常见发生OOM（out-of-memory）的原因及解决办法" class="headerlink" title="5. 常见发生OOM（out of memory）的原因及解决办法"></a>5. 常见发生OOM（out of memory）的原因及解决办法</h4><ol>
<li><p><strong>Java heap space堆内存不足</strong></p>
<p>发生原因：</p>
<ol>
<li>代码中可能存在大对象分配；</li>
<li>可能存在内存泄漏问题，导致在多次GC之后还是无法找到一块足够大的内存容纳当前对象。</li>
</ol>
<p>解决办法：</p>
<ol>
<li>检查是否存在大对象的分配，最有可能的是大数组分配</li>
<li>通过jmap命令，把堆内存dump下来，使用性能分析工具分析检查是否存在内存泄漏的问题，如果没有找到明显的内存泄漏，使用 <strong>-Xmx</strong> 加大堆内存的初始容量</li>
</ol>
</li>
<li><p><strong>GC overhead limit exceeded垃圾回收时间过长</strong></p>
<p>发生原因：</p>
<p>当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误（<strong>发生在堆内存中</strong>）</p>
<p>解决方法：</p>
<ol>
<li><p>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。</p>
</li>
<li><p>dump内存，检查是否存在内存泄露，如果没有就加大堆内存。</p>
</li>
</ol>
</li>
<li><p><strong>unable to create new native threadfan方法栈溢出</strong></p>
<p>发生原因：</p>
<p>出现这种异常基本上都是创建的了大量的线程导致的</p>
<p>解决方法：</p>
<ol>
<li>通过 **-Xss **降低每个线程占用栈大小的容量</li>
</ol>
</li>
<li><p><strong>Metaspace元空间溢出</strong></p>
<p>发生原因：</p>
<ol>
<li>生成了大量的代理类，导致方法区被撑爆且无法卸载；</li>
</ol>
<p>解决方法：</p>
<ol>
<li>检查是否永久代空间或者元空间设置的过小</li>
<li>检查代码中是否存在大量的反射操作，dump之后通过性能分析工具检查是否存在大量由于反射生成的代理类</li>
</ol>
</li>
</ol>
<h4 id="✨8-【介绍下Java中的垃圾回收算法和垃圾回收器，各自的优缺点是什么？】"><a href="#✨8-【介绍下Java中的垃圾回收算法和垃圾回收器，各自的优缺点是什么？】" class="headerlink" title="✨8. 【介绍下Java中的垃圾回收算法和垃圾回收器，各自的优缺点是什么？】"></a>✨8. 【介绍下Java中的垃圾回收算法和垃圾回收器，各自的优缺点是什么？】</h4><p>定义：<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾；</p>
<p><strong>垃圾回收算法：</strong>标记-清除算法、标记-压缩算法、复制算法</p>
<ul>
<li><p><strong>标记-清除算法</strong></p>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象；<strong>（用于老年代回收）</strong></p>
<ul>
<li>标记：收集器从引用根节点开始遍历，标记所有被引用的对象，一般是在对象头中记录为可达对象</li>
<li>清除：收集器对堆内存从头到尾进行线性遍历，如果发现某个对象在其对象头中没有标记为可达对象时则将其回收<strong>（清除并不是真的置空，而是把需要清除的对象地址保存在一个空闲地址列表中，当有新对象需要加载时，判断被定位为垃圾的位置空间是否足够，如果够新对象就覆盖存放）</strong></li>
</ul>
<ul>
<li>缺点：效率不算高且在进行GC时停止整个应用程序；<strong>清除出来的空闲空间不连续的会产生内存碎片</strong>；需要维护空闲地址列表；</li>
</ul>
</li>
<li><p><strong>复制算法</strong></p>
<p>将内存分为大小相同的两块，每次使用其中的一块。在垃圾回收时将正在使用的内存块中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，最后交换两个内存块的角色完成垃圾回收。<strong>（用于新生代回收）</strong></p>
<ul>
<li>优点：复制过去以后<strong>能保证空间的连续性，不会出现内存碎片</strong></li>
<li>缺点：内存和时间花销极大，<strong>要求需要复制的存活对象的数量不能太大</strong></li>
</ul>
</li>
<li><p><strong>标记-压缩（标记-整理）算法</strong></p>
<p>根据老年代的特点提出的一种标记算法<strong>（用于老年代回收）</strong></p>
<ul>
<li><p>标记：和标记清除算法一样，从根节点开始标记所有被引用对象</p>
</li>
<li><p>压缩-清除：将所有的存活对象压缩到内存的一端并按顺序排放，之后清除端边界外所有的空间</p>
</li>
<li><p>优点：消除了标记清除算法中内存区域分散的缺点，需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可；消除了复制算法内存减半的代价</p>
</li>
<li><p>缺点：移动对象的同时如果对象被其他对象引用则还需要调整引用的地址；并且移动过程中需要全程暂停用户应用程序</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>垃圾回收器：</strong>Serial、ParNew、Paeallel Scavenge、Serial Old、Paeallel Old、CMS、G1</p>
<ul>
<li><p><strong>Serial</strong></p>
<p>采用复制算法，使用一条垃圾收集线程去<strong>串行回收</strong>，更重要GC时必须暂停其他所有的工作线程直到它收集结束，作为HotSpot中Client模式下的默认新生代垃圾回收器<strong>（通常客户端GC使用）</strong></p>
</li>
<li><p><strong>ParNew（常用的新生代回收器）</strong></p>
<p>采用复制算法、并行回收和STW机制的方式执行内存回收，可以看作是Serial收集器的多线程版本，作为HotSpot中Server模式下新生代的默认垃圾回收器<strong>（通常服务端GC使用）</strong></p>
</li>
<li><p><strong>Parallel Scavenge</strong></p>
<p>采用复制算法、并行回收和STW机制的方式执行内存回收，同样用于回收新生代，但与ParNew不同，其关注点是吞吐量（高效率的利用 CPU），而CMS 等的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间占总运行时间的比例。</p>
</li>
<li><p><strong>Serial Old</strong></p>
<p>Serial 的老年代版本，采用标记压缩算法，同样采用串行回收和STW机制。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 新生代Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
</li>
<li><p><strong>Parallel Old</strong></p>
<p>采用并行回收和STW机制，但内存回收算法使用标记-压缩算法，用于执行老年代垃圾回收，在JDK1.6后用于替代Serial Old收集器</p>
</li>
</ul>
<h5 id="【8-1-能详细说一下CMS的回收过程吗？CMS的问题是什么？】"><a href="#【8-1-能详细说一下CMS的回收过程吗？CMS的问题是什么？】" class="headerlink" title="【8.1 能详细说一下CMS的回收过程吗？CMS的问题是什么？】"></a>【8.1 能详细说一下CMS的回收过程吗？CMS的问题是什么？】</h5><ul>
<li><p><strong>CMS（重点）</strong></p>
<p>是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>使用 <strong>标记-清除算法</strong>实现的，整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> <strong>仅仅只是标记出GC Roots能直接关联到的对象</strong>，需要停顿用户线程，一旦标记完成后就会恢复之前被暂停的所有应用线程，此阶段速度非常快；</li>
<li><strong>并发标记：</strong> <strong>同时开启 GC 和用户线程，从GC Roots的直接关联对象开始遍历整个对象图</strong>。但在这个阶段结束并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程<strong>清理删除掉前面标记阶段判断已经死亡（未标记）的对象，释放内存空间</strong>。</li>
</ul>
</li>
<li><p><strong>CMS会产生的问题：</strong></p>
<ul>
<li>使用标记清除算法因此<strong>会产生内存碎片</strong>，在进行多次GC后才进行一次碎片整理，导致无法分配大对象的情况下会触发Full GC</li>
<li>在并发阶段虽然不会导致用户停顿，但是<strong>垃圾回收线程会占用一部分CPU资源导致CPU资源紧张</strong></li>
<li>无法处理浮动垃圾，<strong>如果在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些浮动垃圾对象进行标记</strong>，导致这些新产生的垃圾对象没有被及时回收</li>
</ul>
</li>
</ul>
<h5 id="【8-2-能详细说一下G1的回收过程吗？】"><a href="#【8-2-能详细说一下G1的回收过程吗？】" class="headerlink" title="【8.2 能详细说一下G1的回收过程吗？】"></a>【8.2 能详细说一下G1的回收过程吗？】</h5><ul>
<li><p><strong>G1（重点）</strong></p>
<p>Carbage First是一个并行回收器，<strong>把堆内存分割为多个大小相等的区域</strong>，有计划地避免在堆中进行全区域的垃圾回收，跟踪各个区域里的垃圾堆积的价值大小（指回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表，根据允许的收集时间，优先回收价值最大(回收能获得的空间大小)的区域</strong>；</p>
<p>G1回收器特点：</p>
<ul>
<li><strong>并行与并发</strong>：<ul>
<li>并行性：回收期间可以有多个GC线程同时工作，缩短用户线程Stop-The-World停顿时间。</li>
<li>并发性：可以与用户线程交替执行，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><strong>分代收集</strong>：G1<strong>将堆空间分为若干个大小相等的Region区域</strong>，这些区域包含了逻辑上的年轻代和老年代，不再要求年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量；与之前的各类回收器不同，G1回收器<strong>同时兼顾了年轻代和老年代的收集</strong></li>
<li><strong>空间整合</strong>：内存的回收以区域作为基本单位，每个区域（Region）内部局部使用复制算法，但整体上可看作是标记压缩算法，这两种算法都可以进行碎片整理</li>
<li><strong>可预测的停顿（软实时）</strong>：<strong>能让使用者明确指定一个特定长度的时间片段内消耗在垃圾回收上的时间</strong>，每次根据允许的收集时间，优先回收价值最大的区域，保证在有限时间内获取尽可能高的收集效率</li>
<li><strong>在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大（在有限的时间内能尽量回收尽可能多的垃圾对象）的Region</strong></li>
</ul>
</li>
</ul>
<h5 id="8-3-如何利用G1垃圾回收器解决大内存机器的新生代GC过慢的问题？"><a href="#8-3-如何利用G1垃圾回收器解决大内存机器的新生代GC过慢的问题？" class="headerlink" title="8.3 如何利用G1垃圾回收器解决大内存机器的新生代GC过慢的问题？"></a>8.3 如何利用G1垃圾回收器解决大内存机器的新生代GC过慢的问题？</h5><p>针对G1垃圾回收器，<strong>可以设置一个期望的每次GC的停顿时间</strong>，比如我们可以设置一个20ms。 那么G1基于Region内存划分原理，就可以在运行一段时间之后，比如就针对2G内存的Region进行垃圾回收，此时就仅仅停顿 20ms，然后回收掉2G的内存空间腾出来部分内存，接着还可以继续让系统运行。</p>
<h4 id="9-【生产环境服务器变慢，诊断思路和性能评估能谈谈吗？】"><a href="#9-【生产环境服务器变慢，诊断思路和性能评估能谈谈吗？】" class="headerlink" title="9. 【生产环境服务器变慢，诊断思路和性能评估能谈谈吗？】"></a>9. 【生产环境服务器变慢，诊断思路和性能评估能谈谈吗？】</h4><ol>
<li>查看整机指令：</li>
</ol>
<p><strong>top：</strong>输出各指标详细信息</p>
<p><strong>uptime：</strong>系统性能命令精简版</p>
<ol start="2">
<li>查看CPU指令：</li>
</ol>
<p><strong>vmstat -n 参数1 参数2</strong>（参数1是采样的间隔时间，第二个参数是采样的次数）：查看各线程占用CPU情况</p>
<ul>
<li>procs<ul>
<li>r：运行和等待CPU时间片的进程数，原则上整个系统的运行队列不能超过总核数的2倍</li>
<li>b：等待资源的进程数</li>
</ul>
</li>
<li>cpu<ul>
<li>us：用户进程消耗CPU时间百分比，us值高则用户进程消耗CPU时间多，如果长期大于50%需要优化程序</li>
<li>sy：内核进程消耗CPU时间百分比</li>
<li>us+sy参考值为80%，如果大于80%说明可能存在CPU不足</li>
</ul>
</li>
</ul>
<p><strong>mpstat -P ALL 参数</strong>：查看所有CPU核信息（参数为采样的间隔时间）</p>
<p><strong>pidstat -u -p 参数 PID</strong>：查看指定线程使用CPU的用量分解信息（参数为采样的间隔时间）</p>
<ol start="3">
<li>查看内存情况：</li>
</ol>
<p><strong>free -m</strong>：查看系统内存详细信息</p>
<p><strong>pidstat -r -p 参数 PID</strong>：指定线程使用内存的用量分解信息（参数为采样的间隔时间）</p>
<ol start="4">
<li>查看磁盘io情况：</li>
</ol>
<p><strong>iostat -xdk 参数1 参数2</strong>（参数1是采样的间隔时间，第二个参数是采样的次数）：用于磁盘io性能评估</p>
<p><strong>pidstat -d -p 参数 PID</strong>：指定线程磁盘io的用量分解信息（参数为采样的间隔时间）</p>
<h4 id="10-1【生产环境出现CPU占用过高，请谈谈你的分析思路和定位】"><a href="#10-1【生产环境出现CPU占用过高，请谈谈你的分析思路和定位】" class="headerlink" title="10.1【生产环境出现CPU占用过高，请谈谈你的分析思路和定位】"></a>10.1【生产环境出现CPU占用过高，请谈谈你的分析思路和定位】</h4><p><strong>排查分析步骤如下：</strong></p>
<ol>
<li>定位耗费CPU的进程：先用<strong>top -c</strong>显示进程列表，输入<strong>P</strong>按照CPU使用率排序找出CPU占比最高的进程</li>
<li>定位耗费CPU的线程：<strong>top -Hp 进程ID（PID）</strong>，再输入<strong>P</strong>按照CPU使用率排序找出CPU占比最高的线程</li>
<li>将需要的线程ID（PID）转换为十六进制格式（英文小写格式）</li>
<li><strong>jstack 进程ID | grep tid（十六进制线程ID英文小写）-A60</strong>打印该线程相关信息，定位是哪段代码导致CPU占用过高</li>
</ol>
<h4 id="10-2-【线上机器的一个进程用kill命令杀不死该怎么办？】"><a href="#10-2-【线上机器的一个进程用kill命令杀不死该怎么办？】" class="headerlink" title="10.2 【线上机器的一个进程用kill命令杀不死该怎么办？】"></a>10.2 【线上机器的一个进程用kill命令杀不死该怎么办？】</h4><ol>
<li><strong>ps aux</strong>观察STAT那一栏，如果是Z则确定为僵尸进程</li>
<li><strong>ps -ef | grep 进程id</strong>，找到该僵尸进程的父进程PPID，<strong>kill -9 PPID</strong>强制杀掉父进程即可</li>
</ol>
<h4 id="10-3-【排查OOM异常问题的步骤】"><a href="#10-3-【排查OOM异常问题的步骤】" class="headerlink" title="10.3 【排查OOM异常问题的步骤】"></a>10.3 【排查OOM异常问题的步骤】</h4><ol>
<li>先用**top **指令查询服务器系统状态，实时显示系统中各个进程的资源占用状况</li>
<li>找出当前Java进程的PID：<strong>ps aux | grep java</strong></li>
<li>查看当前GC的状况：<strong>jstat -gcutil pid interval</strong></li>
<li><strong>jmap -histo:live pid</strong>：统计存活对象的分布情况，从高到低查看占据内存最多的对象</li>
<li><strong>jmap -dump:format=b,file=文件名 [pid]</strong> 生成当前的堆转储快照dump文件</li>
<li>使用性能分析工具对dump文件进行分析</li>
</ol>
<h4 id="10-4-【服务器存储空间快满了，在不影响服务正常运行的情况下如何解决？】"><a href="#10-4-【服务器存储空间快满了，在不影响服务正常运行的情况下如何解决？】" class="headerlink" title="10.4 【服务器存储空间快满了，在不影响服务正常运行的情况下如何解决？】"></a>10.4 【服务器存储空间快满了，在不影响服务正常运行的情况下如何解决？】</h4><ol>
<li><strong>df -h</strong>先查看磁盘使用情况，排查是否为日志过多导致，是的话就删除一些冗余日志</li>
<li><strong>du -h &gt;fs_du.log</strong>查看各个目录占用的磁盘空间大小，看看是否那个目录下有大量小文件</li>
</ol>
<h4 id="10-5-【线上出现系统缓慢的排查思路】"><a href="#10-5-【线上出现系统缓慢的排查思路】" class="headerlink" title="10.5 【线上出现系统缓慢的排查思路】"></a>10.5 【线上出现系统缓慢的排查思路】</h4><ol>
<li><p>通过 <code>top</code>命令查看CPU情况，如果CPU比较高，则通过<code>top -Hp &lt;pid&gt;</code>命令查看当前进程的各个线程运行情况，找出CPU过高的线程之后，将其线程id转换为十六进制的表现形式，然后在jstack日志中查看该线程主要在进行的工作。这里又分为两种情况：</p>
<ul>
<li>如果是正常的用户线程，则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消耗CPU；</li>
<li>如果该线程是系统进程，则通过<code>jstat -gcutil &lt;pid&gt; &lt;period&gt; &lt;times&gt;</code>命令监控当前系统的GC状况，然后通过<code>jmap dump:format=b,file=&lt;filepath&gt; &lt;pid&gt;</code>导出系统当前的内存数据。导出之后将内存情况放到分析工具中进行分析即可得出内存中主要是什么对象比较消耗内存，进而可以处理相关代码；</li>
</ul>
</li>
<li><p>如果通过 <code>top</code> 命令看到CPU并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于另外三种情况导致的问题，具体的可以根据具体情况分析：</p>
<ul>
<li>如果是接口调用比较耗时，并且是不定时出现，则可以通过压测的方式加大阻塞点出现的频率，从而通过<code>jstack</code>查看堆栈信息，找到阻塞点；</li>
<li>如果是某个功能突然出现停滞的状况，这种情况也无法复现，此时可以通过多次导出<code>jstack</code>日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程；</li>
<li>如果通过<code>jstack</code>可以查看到死锁状态，则可以检查产生死锁的两个线程的具体阻塞点，从而处理相应的问题。</li>
</ul>
</li>
</ol>
<h4 id="11-【介绍下JVM的类加载机制（类的生命周期）】"><a href="#11-【介绍下JVM的类加载机制（类的生命周期）】" class="headerlink" title="11. 【介绍下JVM的类加载机制（类的生命周期）】"></a>11. 【介绍下JVM的类加载机制（类的生命周期）】</h4><p>类的加载过程分为三部分：Loading加载→Linking连接（连接阶段包括Verification验证→Preparation准备→Resolution解析）→Initialization初始化→使用和卸载</p>
<h5 id="类的加载过程一：Loading加载"><a href="#类的加载过程一：Loading加载" class="headerlink" title="类的加载过程一：Loading加载"></a>类的加载过程一：Loading加载</h5><ul>
<li><strong>加载的理解：</strong><ul>
<li>将Java类的.class字节码文件读入到机器内存中，并在内存中构建出与加载类对应的类模板Class对象</li>
</ul>
</li>
<li><strong>加载完成的操作：</strong><ul>
<li>通过一个类的全限定名（即全类名）获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>创建<code>java.lang.Class</code>类的实例，作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
</ul>
<h5 id="类的加载过程二：Linking连接"><a href="#类的加载过程二：Linking连接" class="headerlink" title="类的加载过程二：Linking连接"></a>类的加载过程二：Linking连接</h5><ul>
<li>验证<ul>
<li>目的在于<strong>确保Class文件的字节流中包含信息符合当前JVM要求</strong>，保证加载的字节码是合法、合理并符合规范的</li>
<li>主要包括四种验证方式：文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
</li>
<li>准备<ul>
<li><strong>为类变量分配内存并且设置该类变量的默认初始值</strong></li>
<li><strong>注意：不包括用final修饰的static</strong>，因为final在编译的时候就会分配了，准备阶段会显式初始化；也<strong>不会为实例变量分配初始化</strong>，因为类变量会分配在方法区中，而实例变量会随着对象一起分配到堆中；</li>
</ul>
</li>
<li>解析<ul>
<li><strong>将常量池内的符号引用转换为直接引用</strong></li>
<li>解析操作会随着JVM在执行完初始化之后再执行</li>
<li>解析主要针对类或接口、字段、类方法、接口方法、方法类型等</li>
</ul>
</li>
</ul>
<h5 id="类的加载过程三：Initialization初始化"><a href="#类的加载过程三：Initialization初始化" class="headerlink" title="类的加载过程三：Initialization初始化"></a>类的加载过程三：Initialization初始化</h5><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程，注意<code>&lt;clinit&gt;()</code>不等同于类的构造器，虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
<li>如果类存在直接父类，在初始化该类时，发现其父类还没有被加载和初始化，那么必须先加载并初始化其父类；</li>
</ul>
<h5 id="✨11-1-什么是类加载器？常用的类加载器有哪些？"><a href="#✨11-1-什么是类加载器？常用的类加载器有哪些？" class="headerlink" title="✨11.1 什么是类加载器？常用的类加载器有哪些？"></a>✨11.1 什么是类加载器？常用的类加载器有哪些？</h5><p>JVM支持两种类型的类加载器，分别为引导类加载器Bootstrap ClassLoader、自定义类加载器User-Defined ClassLoader（注意所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器）</p>
<p><strong>常见的3个类加载器：</strong></p>
<ol>
<li><strong>启动类加载器</strong>（引导类加载器Bootstrap ClassLoader）<ul>
<li>嵌套在JVM内部，这个加载器<strong>用来加载Java核心库</strong>(JAVA_HOME、jre、lib、rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</li>
<li>并不继承自ClassLoader抽象类，没有父加载器</li>
<li>加载扩展类或应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>
</li>
<li><strong>扩展类加载器</strong>（Extension ClassLoader）<ul>
<li>派生于ClassLoader抽象类、父类加载器为启动类加载器</li>
<li>从JDK的安装目录的jre/lib/ext子目录（扩展目录）下<strong>加载类库</strong>，如果用户创建的JAR放在此目录下也会自动由扩展类加载器加载</li>
</ul>
</li>
<li><strong>应用程序类加载器</strong>（系统类加载器，AppClassLoader）<ul>
<li>派生于ClassLoader抽象类、父类加载器为启动类加载器</li>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li><strong>是程序中默认的类加载器</strong>，一般Java应用的类都是由它来完成加载</li>
</ul>
</li>
</ol>
<h4 id="12-ParNew-CMS的GC，如何保证只做Young-GC，JVM参数如何配置？"><a href="#12-ParNew-CMS的GC，如何保证只做Young-GC，JVM参数如何配置？" class="headerlink" title="12. ParNew+CMS的GC，如何保证只做Young GC，JVM参数如何配置？"></a>12. ParNew+CMS的GC，如何保证只做Young GC，JVM参数如何配置？</h4><p>合理分配Eden、Survivor、老年代的内存大小，合理设置一些参数即可，参考答案如下：</p>
<ul>
<li><p>加大分代年龄，比如进入老年代的年龄默认从15加到30；</p>
</li>
<li><p>修改新生代和老年代比例，比如新生代老年代比例从默认的1:2改成2:1 </p>
</li>
<li><p>修改Eden区和Survivor区比例，比如从默认8:1:1改成6:2:2；</p>
</li>
</ul>
<h4 id="✨13-如何判断一个对象是否存活？（JVM垃圾回收的时候如何确定垃圾？）"><a href="#✨13-如何判断一个对象是否存活？（JVM垃圾回收的时候如何确定垃圾？）" class="headerlink" title="✨13. 如何判断一个对象是否存活？（JVM垃圾回收的时候如何确定垃圾？）"></a>✨13. 如何判断一个对象是否存活？（JVM垃圾回收的时候如何确定垃圾？）</h4><p>判断一个对象是否存活的两种方法（用于垃圾标记阶段）：引用计数法、可达性算法</p>
<ul>
<li><p><strong>引用计数法（Java没有采用）</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<ul>
<li><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
<li><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行，即将对象进行回收。<strong>（值得注意的是JDK9及后续版本中各个类中的 finalize方法会被逐渐弃用移除）</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="14-【Young-GC、Old-GC和Full-GC分别在什么情况下会发生？】"><a href="#14-【Young-GC、Old-GC和Full-GC分别在什么情况下会发生？】" class="headerlink" title="14. 【Young GC、Old GC和Full GC分别在什么情况下会发生？】"></a>14. 【Young GC、Old GC和Full GC分别在什么情况下会发生？】</h4><ul>
<li><strong>发生Young GC的情况：新生代的Eden区满了之后就会触发，采用复制算法来回收新生代的垃圾。</strong></li>
<li><strong>发生Major GC（Old GC）的情况：即老年代空间也不够放入更多对象了，这时候就要执行Old GC对老年代进行垃圾回收。</strong><ol>
<li>执行Young GC之前进行检查，如果“老年代可用的连续内存空间” &lt; “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后升入老年代的对象大小可能超过了老年代当前可用内存空间，此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC；</li>
<li>执行Young GC之后有一批对象需要放入老年代，如果老年代没有足够的内存空间存放这些对象了，此时立即触发一次Old GC；</li>
<li>老年代内存使用率超过了某个设定值，默认为92%，也会直接触发Old GC；</li>
</ol>
</li>
</ul>
<p><strong>注意：一般Old GC很可能就是在Young GC之前触发或者在Young GC之后触发的，其实在上述几种条件达到的时候，JVM触发的实际上就是一次Full GC（Young GC+Old GC）</strong></p>
<h4 id="15-【什么是双亲委派机制？为什么需要双亲委派机制？】"><a href="#15-【什么是双亲委派机制？为什么需要双亲委派机制？】" class="headerlink" title="15. 【什么是双亲委派机制？为什么需要双亲委派机制？】"></a>15. 【什么是双亲委派机制？为什么需要双亲委派机制？】</h4><p>定义：当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类在自己负责加载的范围内没找到这个类而不能加载，那么就会下推加载权利给自己的子类加载器，由子类去完成类的加载；</p>
<p>使用双亲委派机制的原因：</p>
<ul>
<li><strong>可以避免多层级的加载器结构重复加载某些类，保证类的唯一性</strong></li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<h5 id="15-1-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#15-1-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="15.1 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>15.1 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h5><ol>
<li>Tomcat每个WebApp的类加载器优先自行加载应用目录下的class，并不是先委派传导给上层类加载器去加载，当自己加载不了才委派给父加载器；</li>
</ol>
<p>原因如下：</p>
<ul>
<li>对于各个webapp中的class和lib需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况</li>
<li>使用单独的classloader去装载tomcat自身的类库以免其他恶意或无意的破坏，处于安全性考虑</li>
</ul>
<h4 id="17-什么情况下用-运算符进行字符串连接比调用-StringBuffer-StringBuilder-对象的-append-方法连接字符串性能更好？"><a href="#17-什么情况下用-运算符进行字符串连接比调用-StringBuffer-StringBuilder-对象的-append-方法连接字符串性能更好？" class="headerlink" title="17. 什么情况下用+运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？"></a>17. 什么情况下用+运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？</h4><ol>
<li><strong>字符串拼接操作总结：</strong></li>
</ol>
<ul>
<li><p><strong>常量与常量</strong>，或者<strong>两者都是常量引用</strong>的拼接结果在常量池，原理是编译器优化，常量池中不存在相同内容的常量（注意使用<strong>final修饰的变量</strong>也算是常量）</p>
</li>
<li><p>只要<strong>其中有一个是变量</strong>，拼接结果就直接在堆中而不在常量池，原理是StringBuilder</p>
</li>
<li><p>通过<strong>StringBuilder的append()方式</strong>添加字符串的效率要远高于使用String的字符串+拼接方式，StringBuilder的append()方式自始至终只创建过一个StringBuilder对象，在实际开发中建议使用构造器new StringBuilder(num)指定数组长度优化执行效果</p>
</li>
<li><p><strong>字符串+拼接方式</strong>其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象。</p>
</li>
</ul>
<ol start="2">
<li>intern()的使用</li>
</ol>
<ul>
<li><p>作用：<strong>判断字符串常量池中是否存在该字符串，如果存在则返回常量池中该字符串地址，如果不存在则将此字符串放入常量池中并返回此对象的地址</strong></p>
</li>
<li><p>如果在任意字符串上调用intern()方法，那么其返回结果所指向的那个类实例必须和直接以常量形式出现的字符串实例完全相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern() == &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>String的intern()使用总结：</strong></p>
<ul>
<li>JDK 6时将字符串对象尝试放入字符串常量池，如果字符串常量池有则不会放入，返回已有的字符串常量池中的对象的地址；<strong>如果没有，则把此对象复制一份放入字符串常量池并返回字符串常量池中的对象地址</strong></li>
<li>JDK 7以后将字符串对象尝试放入字符串常量池，如果字符串常量池有则不会放入，返回已有的字符串常量池中的对象的地址；<strong>如果没有，则把对象的引用地址复制一份放入字符串常量池并返回字符串常量池中的引用地址</strong></li>
</ul>
</li>
</ul>
<p><strong>拓展题目</strong>：</p>
<ol>
<li>new String(“ab”)会创建几个对象？</li>
</ol>
<p>答：创建了两个对象，一个对象是new关键字在堆空间创建的，另一个对象是字符串常量池中的对象ab</p>
<ol start="2">
<li>new String(“a”) + new String(“b”)又会创建几个对象？</li>
</ol>
<p>答：创建了六个对象，对象1是new StringBuilder()，对象2是new String(“a”)，对象3是字符串常量池中的“a”，对象4是new String(“b”)，对象5是字符串常量池中的“b”，对象6是StringBuilder.toString()的new String(“ab”)<strong>（注意toString()的调用，在字符串常量池中没有生成对象“ab”)</strong></p>
<h4 id="19-什么情况下会发生栈内存溢出？"><a href="#19-什么情况下会发生栈内存溢出？" class="headerlink" title="19. 什么情况下会发生栈内存溢出？"></a>19. 什么情况下会发生栈内存溢出？</h4><p>当<strong>线程请求的栈深度超过了虚拟机允许的最大深度</strong>时，会抛出StackOverflow异常，当方法递归调用时可能会出现该问题。可以通过调整参数-XSS来调整虚拟机栈的大小；</p>
<h4 id="20-谈谈JVM中的常量池？"><a href="#20-谈谈JVM中的常量池？" class="headerlink" title="20. 谈谈JVM中的常量池？"></a>20. 谈谈JVM中的常量池？</h4><p>JVM常量池主要分为：Class文件常量池、运行时常量池、全局字符串常量池、基本类型包装类对象常量池</p>
<p><strong>要注意的事项：</strong></p>
<ol>
<li>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时Hotspot虚拟机对方法区的实现为永久代</li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是 hotspot 中的永久代 。</strong></li>
<li>JDK1.8 hotspot 移除了永久代用元空间取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间。</li>
</ol>
<h4 id="21-【说一下JVM调优的命令】"><a href="#21-【说一下JVM调优的命令】" class="headerlink" title="21. 【说一下JVM调优的命令】"></a>21. 【说一下JVM调优的命令】</h4><ul>
<li><p><strong>jps</strong>：显示系统内所有正在运行的虚拟机进程（包括虚拟机执行主类名称、进程的唯一id）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-q：只输出进程唯一id（即PID），省略主类名称</span><br><span class="line">-m：输出进程启动时传递给主类main()函数的参数</span><br><span class="line">-l：输出主类的全名（如果进程执行的是jar包则输出jar路径）</span><br><span class="line">-v：输出进程启动时显式指定的JVM参数</span><br></pre></td></tr></table></figure></li>
<li><p><strong>jstat</strong>：显示虚拟机运行时状态信息</p>
<ul>
<li><p><strong>jstat -gc PID</strong>：查看某个进程的堆内存状况（包括Eden区、Survivor区、老年代的容量，已用空间，垃圾回收时间等）</p>
<p>运行该命令后所显示的列参数解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S0C：这是From Survivor区的大小 </span><br><span class="line">S1C：这是To Survivor区的大小 </span><br><span class="line">S0U：这是From Survivor区当前使用的内存大小 </span><br><span class="line">S1U：这是To Survivor区当前使用的内存大小 </span><br><span class="line">EC：这是Eden区的大小 </span><br><span class="line">EU：这是Eden区当前使用的内存大小 </span><br><span class="line">OC：这是老年代的大小 </span><br><span class="line">OU：这是老年代当前使用的内存大小 </span><br><span class="line">MC：这是方法区（元空间）的大小</span><br><span class="line">MU：这是方法区（永久代、元数据区）的当前使用的内存大小 </span><br><span class="line">YGC：这是系统运行迄今为止的Young GC次数 </span><br><span class="line">YGCT：这是Young GC的耗时 </span><br><span class="line">FGC：这是系统运行迄今为止的Full GC次数 </span><br><span class="line">FGCT：这是Full GC的耗时 </span><br><span class="line">GCT：这是所有GC的总耗时</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>jmap</strong>：通常用于生成heap dump（堆内存转储快照）文件</p>
<ul>
<li><strong>jmap -heap PID</strong>：打印与堆内存相关的一些参数设置，以及当前堆内存里各个区域的基本情况（总容量、剩余容量等）</li>
<li><strong>jmap -histo PID</strong>：打印堆中对象统计信息，按照对象占用内存空间的大小，降序排列当前jvm中的对象对内存占用的情况</li>
<li><strong>jmap -dump:live,format=b,file=&lt;filename&gt; PID</strong>：会在当前目录下生成一个堆转储快照文件，其中包含这一时刻JVM堆内存里所有存活对象的快照</li>
</ul>
</li>
<li><p><strong>jhat</strong>：与jmap搭配使用，用于分析jmap生成的堆内存转储快照文件</p>
<ul>
<li><strong>jhat dump.hprof -port 7000</strong>：可启动jhat服务器，在浏览器上通过图形化的方式去分析堆内存里的对象分布情况</li>
</ul>
</li>
<li><p><strong>jstack</strong>：用于生成虚拟机当前时刻的线程快照文件（即每一条线程正在执行的方法堆栈的集合）</p>
<ul>
<li><strong>jstack -l vmid</strong>：除了堆栈外还显示关于锁的附加信息</li>
</ul>
</li>
</ul>
<h4 id="22-【内存泄漏、内存溢出是什么以及怎么解决？】"><a href="#22-【内存泄漏、内存溢出是什么以及怎么解决？】" class="headerlink" title="22. 【内存泄漏、内存溢出是什么以及怎么解决？】"></a>22. 【内存泄漏、内存溢出是什么以及怎么解决？】</h4><ol>
<li><strong>内存溢出（OOM）</strong>：指没有空闲内存，并且垃圾收集器也无法提供更多的内存的情况</li>
</ol>
<ul>
<li><p><strong>内存溢出产生原因：</strong></p>
<ul>
<li><p>元空间区域大小设置过小；不断动态生成了过多的类塞满元空间，且大量的类即使Full GC后还不能被回收；</p>
</li>
<li><p>堆区导致内存溢出的原因：<strong>（根本原因即对象太多且都是存活的，即使GC后还是没有空间放下新的对象）</strong></p>
<ul>
<li>系统承载高并发请求，因为<strong>请求量过大系统负载过高</strong>，导致大量对象都是存活的，无法继续放入新的对象；</li>
<li>系统有<strong>内存泄漏</strong>的问题，很多对象都是存活的，没有及时取消对他们的引用，但导致内存实在放不下更多对象；</li>
</ul>
</li>
</ul>
<p><strong>可能发生OOM的区域：</strong>方法区/元空间、堆区、虚拟机栈</p>
</li>
</ul>
<ol start="2">
<li><strong>内存泄漏（Memory Leak）</strong>：指对象不会再被程序使用，但是垃圾收集器又不能回收它们的情况（内存泄漏可能会导致内存溢出，但不是必然的）</li>
</ol>
<ul>
<li><p><strong>内存泄漏例子：</strong></p>
<ul>
<li><p>单例模式</p>
<p>单例的生命周期和应用程序等长，所有单例程序中如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则可能会导致内存溢出的产生</p>
</li>
<li><p><strong>提供close()的资源未及时关闭</strong></p>
<p>数据库连接（dataSource.getConnection()）、网络连接（Socket）和IO流必须手动close，否则是不能被回收的</p>
</li>
</ul>
</li>
</ul>
<h4 id="✨23-【介绍下JVM的内存区域（运行时数据区）】"><a href="#✨23-【介绍下JVM的内存区域（运行时数据区）】" class="headerlink" title="✨23. 【介绍下JVM的内存区域（运行时数据区）】"></a>✨23. 【介绍下JVM的内存区域（运行时数据区）】</h4><ul>
<li><p>各线程私有（生命周期与线程生命周期保持一致）：</p>
<ul>
<li><p><strong>本地方法栈</strong></p>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中本地方法栈和虚拟机栈合二为一统称为栈空间。</p>
</li>
<li><p><strong>虚拟机栈</strong></p>
<p>此内存区域的作用是用来<strong>保存每个方法内的局部变量等数据，并参与方法调用的返回</strong>，如果线程执行了一个方法，就会对这个方法调用创建对应的一个<strong>栈帧</strong>并入栈，同时会在栈帧的局部变量表中存放局部变量（栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法返回地址等；），方法执行完毕后就将对应栈帧出栈；</p>
<p><strong>Java 虚拟机栈会出现两种错误：</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError错误。</li>
</ul>
</li>
<li><p><strong>程序计数器</strong>（唯一不会出现OOM的区域）</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于<strong>用来存储指向下一条指令（将要执行的代码）的地址，即记录当前线程执行到的位置</strong>，当线程被切换回来的时候能够知道该线程上次运行到哪。</li>
</ul>
</li>
</ul>
</li>
<li><p>线程间共享（生命周期与虚拟机的生命周期保持一致）：</p>
<ul>
<li><p><strong>堆</strong></p>
<ul>
<li>堆区作用：<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong>（从 JDK 1.7 开始已经默认开启<strong>逃逸分析</strong>，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存）</li>
</ul>
<ul>
<li><strong>年轻代和老年代</strong><ul>
<li>堆区可以划分为年轻代和老年代，年轻代又可划分为Eden区、两块大小相同的Survivor区（又称为from区和to区，to区总为空），几乎所有的Java对象都是在Eden区被new出来的，绝大部分的Java对象的销毁也都在新生代进行；老年代存放新生代中经历多次GC仍然存活的对象；</li>
<li><strong>对象分配过程：</strong><ol>
<li>大部分new的对象先放到Eden区，当Eden区的空间填满而程序又需要创建对象时，JVM的<strong>Minor GC（Young GC）</strong>将对Eden区进行垃圾回收，将Eden去中不再被其他对象所引用的对象销毁，再加载新的对象放到Eden区，然后将Eden区中的剩余的存活对象移动到from区；</li>
<li>如果再次Minor GC，此时上次幸存下来放到from区的对象，如果没有被回收就会被放到to区；</li>
<li>如果再次经历垃圾回收，此时会重新回到from区，接下来再去to区，不断循环此过程直到计数器到达设置值（默认为15次），如果还没有被回收就从年轻代移动到老年代；</li>
<li>老年代空间不足时会触发<strong>Major GC（也可认为发生了Full GC）</strong>，如果Major GC之后空间还不足就报OOM异常了</li>
</ol>
</li>
<li><strong>【对象分配原则】：</strong><ul>
<li>优先分配到新生代的Eden区</li>
<li>大对象（需要大量连续内存空间的对象，如长字符串或数组）直接分配到老年代</li>
<li>长期存活（指达到晋升老年代的年龄阈值）的对象将分配到老年代</li>
<li>如果一次Young GC后存活的对象过多而Survivor区无法容纳，就直接进入老年代</li>
<li>如果<strong>Survivor区中相同年龄的所有对象大小总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到-XX:MaxTenuringThreshold要求的年龄阈值<strong>（动态对象年龄判断机制）</strong></li>
<li>在每次发生Minor GC之前，JVM必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立则会进行一次能确保安全的Minor GC；如果不满足则会查看是否允许担保失败，允许的话就比较老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小，大于平均值则进行一次有风险的Minor GC，如果小于平均值或不允许担保失败则进行一次Full GC<strong>（空间分配担保机制）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区（元空间）</strong></p>
<ul>
<li><p>方法区作用：<strong>用于存储已被虚拟机加载的类型信息（包括域信息、方法信息）、编译期生成的各种字面量与符号引用（存放在运行时常量池中）、即时编译器编译后的JIT代码缓存等</strong></p>
</li>
<li><p>栈、堆和方法区的交互关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>person是<strong>方法局部变量</strong>，存放在Java虚拟机栈该方法对应栈帧的局部变量表中，指向在堆空间中new Person()创建的<strong>对象实例数据</strong>，在对象实例数据中有到对象数据类型的指针，指向在方法区中的<strong>对象类型数据</strong>Person；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="24-【Java对象创建过程的五个步骤】"><a href="#24-【Java对象创建过程的五个步骤】" class="headerlink" title="24.【Java对象创建过程的五个步骤】"></a>24.【Java对象创建过程的五个步骤】</h4><h5 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h5><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</p>
<h5 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h5><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>，对象所需的内存大小在类加载完成后便可确定。分配方式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：</strong></p>
<ul>
<li>指针碰撞 ：<ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ：<ul>
<li>适用场合 ： 堆内存不规整（即有内存碎片）的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p><strong>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。</strong>而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题：</strong></p>
<p>在创建对象的时候还有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h5 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h5><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h5 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h5><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些设置信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h5 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init() 方法"></a>Step5:执行 init() 方法</h5><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="✨👏Spring"><a href="#✨👏Spring" class="headerlink" title="✨👏Spring"></a>✨👏Spring</h2><h4 id="✨1-【什么是控制反转（IoC）？什么是依赖注入（DI）？】"><a href="#✨1-【什么是控制反转（IoC）？什么是依赖注入（DI）？】" class="headerlink" title="✨1. 【什么是控制反转（IoC）？什么是依赖注入（DI）？】"></a>✨1. 【什么是控制反转（IoC）？什么是依赖注入（DI）？】</h4><p><strong>控制反转（Inversion of Control）</strong>是一种是面向对象编程中的一种设计思想，目的是用来减低计算机代码之间的耦合度。其基本思想是：<strong>借助于“第三方”实现具有依赖关系的对象之间的解耦</strong>。</p>
<ul>
<li>控制体现在<strong>全部对象交给“第三方”IoC容器控制，由IoC容器来控制对象的创建</strong>；</li>
<li>反转体现在<strong>由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，依赖对象的获取关系被反转了</strong></li>
</ul>
<p><strong>依赖注入（dependency injection）</strong>是在编译阶段不知道所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>；</p>
<p>注意：控制反转是一种设计思想，依赖注入是一种设计模式，<strong>IoC框架使用依赖注入作为实现控制反转的具体方式</strong>，在Spring Framework中使用过函数和setter注入；</p>
<h4 id="2-Spring容器：BeanFactory和ApplicationContext有什么区别？"><a href="#2-Spring容器：BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="2. Spring容器：BeanFactory和ApplicationContext有什么区别？"></a>2. Spring容器：BeanFactory和ApplicationContext有什么区别？</h4><ol>
<li>BeanFactory和ApplicationContext是IoC容器的两种实现方式，其中<strong>BeanFactory</strong>是Spring内部的使用接口，一般不提供给开发人员进行使用，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<strong>ApplicationContext</strong>接口是BeanFactory的子接口，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能，如继承MessageSource支持国际化、统一的资源文件访问方式、提供在监听器中注册bean的事件、同时加载多个配置文件等；</li>
<li><strong>BeanFactroy</strong>采用的是延迟加载形式来注入Bean，在加载配置文件时不会创建对象，在获取对象时才会创建对象；<strong>ApplicationContext</strong>在容器启动时一次性创建所有的Bean，在加载配置文件时就会把配置文件对象进行创建；</li>
</ol>
<h4 id="3-Spring-框架中都用到了哪些设计模式？"><a href="#3-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="3. Spring 框架中都用到了哪些设计模式？"></a>3. Spring 框架中都用到了哪些设计模式？</h4><p>（1）代理模式：<strong>Spring AOP 就是基于动态代理的</strong></p>
<p>（2）单例模式：Spring 中 bean 的默认作用域就是Singleton的。 </p>
<p>（3）模板方法模式：Spring 中 jdbcTemplate、hibernateTemplate等<strong>以 Template 结尾的对数据库操作的类</strong>就使用到了模板模式。 </p>
<p>（4）委派模式：Srping 提供了 DispatcherServlet 来对请求进行分发。</p>
<p>（5）工厂模式：通过 <strong>BeanFactory</strong> 或 <strong>ApplicationContext</strong> 创建 bean 对象 </p>
<p>（6）观察者模式: <strong>Spring 事件驱动模型</strong></p>
<p>（7）适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配Controller</p>
<h4 id="✨4-【-什么是AOP？了解AOP实现动态代理的两种方式吗？】"><a href="#✨4-【-什么是AOP？了解AOP实现动态代理的两种方式吗？】" class="headerlink" title="✨4.【 什么是AOP？了解AOP实现动态代理的两种方式吗？】"></a>✨4.【 什么是AOP？了解AOP实现动态代理的两种方式吗？】</h4><p>AOP（Aspect Oriented Programming）是面向切面编程，目的是为了<strong>解耦</strong>，基本单元是切面，即将公共的代码逻辑，比如统一处理日志、异常等，抽象出来变成一个切面然后注入到目标对象(具体代码)中去，通过动态代理的方式将需要注入切面的对象进行代理，在进行调用时将公共的逻辑直接添加进去而不需要修改原有业务的逻辑代码，只需要在原来业务逻辑基础上做一些增强功能即可；</p>
<p><strong>名词解释：</strong></p>
<ul>
<li><strong>切面</strong>：关注点模块化，这个关注点可能会横切多个对象，可以使用通用类基于模式的方式或者在普通类中以@Aspect注解方式来实现；</li>
<li><strong>连接点</strong>：在程序执行过程中某个特定的点，一个连接点总是代表一个方法的执行；</li>
<li><strong>切点</strong>：匹配连接点的断言，通知和切点表达式相关联，并且在满足这个切点的连接点上运行特定通知</li>
<li><strong>通知</strong>：在切面的某个特定的连接点上执行的动作，使用before、after注解等实现；</li>
</ul>
<p><strong>aop常用注解：</strong></p>
<ul>
<li>@Before：前置通知，在目标方法之前执行</li>
<li>@After：后置通知，在目标方法之后执行（始终会执行）</li>
<li>@AfterReturning：返回后通知，执行方法结束前执行（异常则不执行）</li>
<li>@AfterThrowing：异常通知，出现异常时执行</li>
<li>@Around：环绕通知，环绕目标方法执行</li>
</ul>
<p><strong>aop两种实现方式：</strong></p>
<ul>
<li><p>静态代理（也称为编译时增强）</p>
<p>使用AOP框架提供命令进行编译，在编译阶段就生成AOP代理类</p>
</li>
<li><p>动态代理（也称为运行时增强）</p>
<p>在运行时在内存中生成AOP动态代理类</p>
<ul>
<li><strong>JDK动态代理</strong>：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口，使用Proxy类去创建代理对象，其核心是InvocationHandler接口和Proxy类；</li>
<li><strong>CGLIB动态代理</strong>：如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类，<strong>CGLIB类库在运行时动态生成目标类的一个子类作为代理对象</strong>（注意：CGLIB通过继承方式进行动态代理，若目标类标记为final，则它是无法使用CGLIB做动态代理的）</li>
</ul>
<p>【<strong>JDK动态代理与Cglib动态代理区别？</strong>】</p>
<ol>
<li>当要代理的对象是实现了某个接口的，Spring AOP会使用<strong>JDK动态代理</strong>，生成一个实现相同接口的代理类；</li>
<li>当某个类是没有实现接口的，Spring AOP会使用<strong>Cglib动态代理</strong>，生成这个类的一个子类，子类动态生成字节码覆盖该类的一些方法，在方法中加入增强代码；</li>
</ol>
</li>
</ul>
<h5 id="4-1-利用AOP实现Web日志处理"><a href="#4-1-利用AOP实现Web日志处理" class="headerlink" title="4.1 利用AOP实现Web日志处理"></a>4.1 利用AOP实现Web日志处理</h5><ol>
<li>在pom.xml引入aop相关依赖；</li>
<li>创建一个WebLogAspect类，在webLog方法上加上@Pointcut注解定义横切点，再配合aop相关注解实现切面逻辑；</li>
</ol>
<h4 id="5-1-【Spring是如何管理Bean的？Spring的Bean作用域有哪些？】"><a href="#5-1-【Spring是如何管理Bean的？Spring的Bean作用域有哪些？】" class="headerlink" title="5.1 【Spring是如何管理Bean的？Spring的Bean作用域有哪些？】"></a>5.1 【Spring是如何管理Bean的？Spring的Bean作用域有哪些？】</h4><p>Spring通过IoC容器来管理Bean，我们可以通过xml或者注解方式配置，来指导IoC容器对Bean的管理；</p>
<p>以下是管理Bean时常用的一些注解：</p>
<ol>
<li><p>@ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。</p>
</li>
<li><p>@Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。</p>
</li>
<li><p>@Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。</p>
</li>
<li><p>@Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。</p>
<ul>
<li><p>✨<strong>Spring中的Bean的作用域</strong>：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton<strong>（默认作用域）</strong></td>
<td>在Spring容器中仅存在一个实例，即Bean以单例的形式存在。</td>
</tr>
<tr>
<td align="left">prototype</td>
<td>每次调用getBean()时，都会执行new操作，为每个bean请求提供一个新的实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td>每次HTTP请求都会创建一个新的Bean，请求完成以后bean失效并被GC回收。</td>
</tr>
<tr>
<td align="left">session</td>
<td>同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</td>
</tr>
<tr>
<td align="left">globalSession</td>
<td>同一个全局的Session共享一个Bean，一般用于Portlet环境。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>【Spring中的Bean是线程安全的吗？】</strong></p>
<p>Spring中的Bean是否是线程安全的需要分情况讨论：</p>
<ul>
<li><p>对于原型Bean，每次都创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>
</li>
<li><p>对于单例Bean，所有线程都共享一个单例实例Bean，因此存在资源的竞争。如果单例Bean是一个无状态Bean，也就是每个线程中对全局变量、静态变量只有读操作而无写操作即不保存数据，那么这个单例Bean是线程安全的。若有多个线程同时执行写操作，就变成需要保存数据的有状态Bean，可以<strong>使用ThreadLocal解决线程安全问题</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。</p>
</li>
</ol>
<h4 id="5-2-什么是Bean的自动装配，它有哪些方式？"><a href="#5-2-什么是Bean的自动装配，它有哪些方式？" class="headerlink" title="5.2 什么是Bean的自动装配，它有哪些方式？"></a>5.2 什么是Bean的自动装配，它有哪些方式？</h4><p>bean的自动装配：指的是bean的属性值在进行注入时通过某种特定的规则和方式去容器中查找，并设置到具体的对象属性中，它主要有以下几种方式：</p>
<ul>
<li>no：缺省不自动装配，通过ref属性手动设定，在项目中最常见；</li>
<li>byName：根据属性名称自动装配，如果一个bean的名称和其他bean属性名称一样将会兼容并自动装配</li>
<li>byType：根据数据类型自动装配，如果一个bean的数据类型和其他bean数据类型一样将会兼容并自动装配</li>
</ul>
<h4 id="6-【简述Bean的生命周期】（待补充）"><a href="#6-【简述Bean的生命周期】（待补充）" class="headerlink" title="6. 【简述Bean的生命周期】（待补充）"></a>6. 【简述Bean的生命周期】（待补充）</h4><ol>
<li>实例化bean对象，通过反射的方式进行对象的创建，此时的创建只是在堆空间中申请空间，属性都是默认值；</li>
<li>设置对象属性，给对象中的属性进行值的设置工作；</li>
<li>检查Aware相关接口并设置相关依赖；</li>
<li>BeanPostProcessor的前置处理，对生成的bean对象进行前置的处理工作；</li>
<li>检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法；</li>
<li>检查是否配置有自定义的init-method方法，如果当前bean对象定义了初始化方法，那么在此处调用初始化方法；</li>
<li>BeanPostProcessor后置处理，对生成的bean对象进行后置的处理工作；</li>
<li>注册必要的Destruction相关回调接口</li>
</ol>
<h4 id="✨7-1-【介绍一下SpringMVC的工作流程】"><a href="#✨7-1-【介绍一下SpringMVC的工作流程】" class="headerlink" title="✨7.1 【介绍一下SpringMVC的工作流程】"></a>✨7.1 【介绍一下SpringMVC的工作流程】</h4><ol>
<li>客户端发送请求至前端控制器DispatcherServlet；</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器，解析请求对应的Handler（即Controller）；</li>
<li>处理器映射器根据注解或xml配置找到具体的Handler，生成处理器对象及拦截器后一并返回给DispatcherServlet；</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器，HandlerAdapter经过适配，调用相应Handler的具体处理器方法；</li>
<li>Handler执行完成返回ModelAndView给HandlerAdapter，HandlerAdapter再将Controller的执行结果ModelAndView返回给DispatcherServlet；</li>
<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器，ViewResolver解析后返回具体的View给DispatcherServlet；</li>
<li>DispatcherServlet根据View进行视图渲染后返回响应给请求的用户。</li>
</ol>
<h4 id="7-2-简单介绍Spring-MVC的核心组件"><a href="#7-2-简单介绍Spring-MVC的核心组件" class="headerlink" title="7.2 简单介绍Spring MVC的核心组件"></a>7.2 简单介绍Spring MVC的核心组件</h4><ul>
<li>DispatcherServlet：前端控制器，是请求的入口，负责协调各个组件工作；</li>
<li>HandlerMapping：处理器映射器，是请求的处理器匹配器，负责为请求找到合适的处理器执行链，包含处理器和拦截器们；</li>
<li>HandlerAdapter：处理器适配器，因为处理器Handler的类型是Object，需要有一个调用者来实现Handler是怎样被执行去具体执行处理器的；</li>
<li>ViewResolver：视图解析器，负责获取视图View对象；</li>
<li>HandlerExceptionResolver：处理器异常解析器，将处理器执行时发生的异常，解析成对应的ModelAndView结果；</li>
</ul>
<h4 id="✨8-【Spring循环依赖是怎么产生的？Spring是如何解决的循环依赖】（待补充）"><a href="#✨8-【Spring循环依赖是怎么产生的？Spring是如何解决的循环依赖】（待补充）" class="headerlink" title="✨8. 【Spring循环依赖是怎么产生的？Spring是如何解决的循环依赖】（待补充）"></a>✨8. 【Spring循环依赖是怎么产生的？Spring是如何解决的循环依赖】（待补充）</h4><p>例子：有一个A对象，创建A的时候发现A对象依赖B，然后去创建B对象的时候，又发现B对象依赖A，即就是A依赖B的同时B也依赖了A，这就产生了最简单的循环依赖；</p>
<p>Spring对循环依赖的处理有三种情况：</p>
<ol>
<li>构造器的循环依赖：这种依赖Spring无法处理，直接抛出BeanCurrentlyInCreationException异常；</li>
<li><strong>单例模式下的setter循环依赖：通过三级缓存处理循环依赖</strong>；</li>
<li>非单例循环依赖：无法处理</li>
</ol>
<h5 id="8-1-Spring是如何解决的循环依赖？"><a href="#8-1-Spring是如何解决的循环依赖？" class="headerlink" title="8.1 Spring是如何解决的循环依赖？"></a>8.1 Spring是如何解决的循环依赖？</h5><p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）, 二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p>
<h5 id="8-2-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"><a href="#8-2-为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？" class="headerlink" title="8.2 为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？"></a>8.2 为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</h5><p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p>
<h4 id="9-1-【Spring的事务实现原理是什么？其如何管理事务？常用的事务传播机制和事务隔离级别有哪些？】"><a href="#9-1-【Spring的事务实现原理是什么？其如何管理事务？常用的事务传播机制和事务隔离级别有哪些？】" class="headerlink" title="9.1 【Spring的事务实现原理是什么？其如何管理事务？常用的事务传播机制和事务隔离级别有哪些？】"></a>9.1 【Spring的事务实现原理是什么？其如何管理事务？常用的事务传播机制和事务隔离级别有哪些？】</h4><p>Spring可以让用户以统一的编程模型进行事务管理，Spring支持两种事务编程模型：</p>
<ol>
<li><p><strong>编程式事务</strong></p>
<p>Spring提供了TransactionTemplate模板，利用该模板可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。</p>
</li>
<li><p><strong>声明式事务</strong></p>
<p>Spring声明式事务管理允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，只需要在需要做事务管理的方法上增加**@Transactional注解**，以声明事务特征即可。在@Transactional注解中如果不配置<code>rollbackFor</code>属性，那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上<code>rollbackFor=Exception.class</code>，可以让事务在遇到非运行时异常时也回滚；</p>
<ul>
<li><p>对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。</p>
<ul>
<li>当它标注在类上时，代表这个类所有公共非静态（public）的方法都将启用事务功能。</li>
<li>当它标注在方法上时，代表这个方法将启用事务功能。</li>
</ul>
<p>在@Transactional注解上，我们可以使用isolation属性声明<strong>事务隔离级别</strong>，使用propagation属性声明<strong>事务传播机制</strong></p>
<p>✨<strong>常用事务传播机制</strong>如下：<strong>（规定多个事务方法相互调用时，事务如何在这些方法之间进行传播）</strong></p>
<ul>
<li><strong>REQUIRED</strong>：如果当前存在事务就加入该事务，如果当前不存在事务就新建一个新事务<strong>（默认事务传播机制）</strong>；</li>
<li>SUPPORTS：如果当前存在事务就加入该事务，如果当前不存在事务则以非事务方式执行；</li>
<li>MANDATORY：如果当前存在事务就加入该事务，如果当前不存在事务则抛出异常；</li>
<li><strong>REQUIRE_NEW</strong>：无论当前是否存在事务都创建一个新事务，如果当前存在事务就挂起当前事务；</li>
<li><strong>NESTED</strong>：如果当前存在事务就创建一个嵌套事务，如果当前不存在事务就按照REQUIRED属性执行；</li>
<li>NOT_SUPPORTED：以非事务方式执行，如果当前存在事务则挂起该事务；</li>
</ul>
<p><strong>常用事务隔离级别</strong>如下：</p>
<p>Spring的事务隔离级别与数据库的隔离级别一样；（当Spring和数据库的隔离级别不一致时，以Spring的配置为主）</p>
</li>
</ul>
</li>
</ol>
<h4 id="9-2-Spring事务什么时候会失效？"><a href="#9-2-Spring事务什么时候会失效？" class="headerlink" title="9.2 Spring事务什么时候会失效？"></a>9.2 Spring事务什么时候会失效？</h4><ol>
<li>bean对象没有被Spring容器管理；</li>
<li>方法的访问修饰符不是public；</li>
<li>数据源没有配置事务管理器；</li>
<li>数据库不支持事务；</li>
<li>自身调用问题；</li>
</ol>
<h4 id="✨10-【说一说你知道的Spring-MVC注解】"><a href="#✨10-【说一说你知道的Spring-MVC注解】" class="headerlink" title="✨10.【说一说你知道的Spring MVC注解】"></a>✨10.【说一说你知道的Spring MVC注解】</h4><p><strong>@RequestMapping：</strong></p>
<p>作用：用来处理请求地址映射的，也就是说将具体的处理器方法映射到url路径上。</p>
<p>属性：</p>
<ul>
<li>method：是让你指定请求的method的类型，比如常用的有get和post。（也可以直接使用派生注解@GetMapping或@PostMapping）</li>
<li>value：是指请求的实际地址，如果是多个地址就用{}来指定就可以啦。</li>
<li>produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。</li>
<li>consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。</li>
<li>headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。</li>
<li>params：指定request中一定要有的参数值，它才会使用该方法处理请求。</li>
</ul>
<p><strong>@RequestParam：</strong></p>
<p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解，用于获取查询参数。</p>
<p>属性：</p>
<ul>
<li>value是请求参数中的名称。</li>
<li>required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。</li>
</ul>
<p><strong>@RequestBody：</strong></p>
<p>作用：作用在形参列表上，用于将前台发送过来固定格式的数据封装为对应的JavaBean对象。</p>
<p>属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。</p>
<p><strong>@ResponseBody：</strong></p>
<p>作用：作用在方法上，表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用。</p>
<p><strong>@PathVariable：</strong></p>
<p>作用：该注解是用于绑定url中的占位符，用于获取路径参数；</p>
<h4 id="✨11-说一下你知道的Spring-SpringBoot注解？SpringBoot的自动装配原理？"><a href="#✨11-说一下你知道的Spring-SpringBoot注解？SpringBoot的自动装配原理？" class="headerlink" title="✨11. 说一下你知道的Spring / SpringBoot注解？SpringBoot的自动装配原理？"></a>✨11. 说一下你知道的Spring / SpringBoot注解？SpringBoot的自动装配原理？</h4><p><strong>@SpringBootApplication：</strong></p>
<ul>
<li>@SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan注解的集合<ul>
<li><p><strong>@EnableAutoConfiguration：打开自动装配功能</strong></p>
<ul>
<li><p>✨<strong>SpringBoot的自动装配原理</strong></p>
<p>@SpringBootApplication注解中组合了一个@EnableAutoConfiguration注解，作用是打开自动装配，而这个注解中又包含了一个@Import注解，在这个注解中引入了一个实现了ImportSelector接口的类，在对应的selectImports()方法中会读取META-INF目录下的spring.factories文件中需要被自动装配的所有配置类，然后通过META-INF下面的spring-autoconfigure-metadata.properties文件做条件过滤，最后返回的就是需要自动装配的相关的对象；</p>
</li>
</ul>
</li>
<li><p>@ComponentScan： 默认情况下会扫描当前包及其子包下所有被该注解修饰的Java类；</p>
</li>
<li><p>@Configuration：标识为一个Java配置类，允许在Spring上下文中注册额外的 bean 或导入其他配置类；</p>
</li>
</ul>
</li>
</ul>
<p><strong>@Autowired：</strong></p>
<ul>
<li>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中</li>
</ul>
<p><strong>@Component、@Repository、@Service、@Controller：</strong></p>
<p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 Spring组件。如果一个 Bean 不知道属于哪个层，可以使用@Component注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 的控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<p><strong>@RestController：</strong></p>
<p>@RestController注解是@Controller和@ResponseBody的合集，表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器（用于返回Json）。</p>
<p><strong>全局处理 Controller 层异常注解：</strong></p>
<ol>
<li><strong>@ControllerAdvice</strong> : 注解定义全局异常处理类</li>
<li><strong>@ExceptionHandler</strong> : 注解声明异常处理方法</li>
</ol>
<h4 id="12-SpringBoot项目需要单独的web容器吗？"><a href="#12-SpringBoot项目需要单独的web容器吗？" class="headerlink" title="12. SpringBoot项目需要单独的web容器吗？"></a>12. SpringBoot项目需要单独的web容器吗？</h4><p>可以不需要，在SpringBoot项目中添加spring-boot-starter-web依赖，这个依赖中内嵌了Tomcat容器；</p>
<h4 id="✨13-单例模式的创建方式"><a href="#✨13-单例模式的创建方式" class="headerlink" title="✨13. 单例模式的创建方式"></a>✨13. 单例模式的创建方式</h4><h2 id="👏MyBatis"><a href="#👏MyBatis" class="headerlink" title="👏MyBatis"></a>👏MyBatis</h2><h4 id="1-什么是ORM框架？"><a href="#1-什么是ORM框架？" class="headerlink" title="1. 什么是ORM框架？"></a>1. 什么是ORM框架？</h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<h4 id="✨2-MyBatis-中-和-的区别是什么？"><a href="#✨2-MyBatis-中-和-的区别是什么？" class="headerlink" title="✨2. MyBatis 中 #{}和 ${}的区别是什么？"></a>✨2. MyBatis 中 #{}和 ${}的区别是什么？</h4><ol>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>Mybatis在处理#{}时，会把sql中的#{}替换为？，调用PrepareStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值；</li>
<li>使用#{}可以有效的防止sql注入问题，提高系统安全性；</li>
</ol>
<h4 id="3-MyBatis-有几种分页方式？分页方式区别是什么？"><a href="#3-MyBatis-有几种分页方式？分页方式区别是什么？" class="headerlink" title="3. MyBatis 有几种分页方式？分页方式区别是什么？"></a>3. MyBatis 有几种分页方式？分页方式区别是什么？</h4><p><strong>逻辑分页：</strong> 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
<p><strong>物理分页：</strong> 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<p><strong>两种分页方式区别：</strong></p>
<ul>
<li><strong>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据</strong>。 这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>
<li><strong>物理分页是从数据库查询指定条数的数据</strong>，弥补了一次性全部查出所有数据的缺点。</li>
</ul>
<h4 id="4-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#4-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="4. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>4. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>MyBatis仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一查询，collection 指的就是一对多查询，可通过设置 lazyLoadingEnabled=true / false决定是否延迟加载。 </p>
<p><strong>延迟加载的原理</strong>：使用cglib创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现a.getB()是null值时，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把B查询上来，然后再调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。</p>
<h4 id="5-【说一下-MyBatis-的一级缓存和二级缓存？】"><a href="#5-【说一下-MyBatis-的一级缓存和二级缓存？】" class="headerlink" title="5. 【说一下 MyBatis 的一级缓存和二级缓存？】"></a>5. 【说一下 MyBatis 的一级缓存和二级缓存？】</h4><p><strong>一级缓存：</strong>Mybatis的一级缓存是指Session缓存，默认开启一级缓存，其作用域默认是一个SqlSession，也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中，第二次以后是直接去缓存中取；当 Session flush 或 close 之后，MyBatis会把SqlSession的缓存清空。</p>
<p><strong>二级缓存：</strong>Mybatis的二级缓存是指mapper映射文件。二级缓存的作用域是同一个namespace下的mapper映射文件内容，由多个SqlSession共享。Mybatis需要手动设置启动二级缓存。</p>
<h4 id="6-当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#6-当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="6. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>6. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h4><ul>
<li>方法一：<strong>通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</strong>。</li>
<li>方法二：通过映射字段名和实体类属性名的一一对应的关系。</li>
</ul>
<h4 id="8-模糊查询-like-语句该怎么写"><a href="#8-模糊查询-like-语句该怎么写" class="headerlink" title="8. 模糊查询 like 语句该怎么写?"></a>8. 模糊查询 like 语句该怎么写?</h4><ul>
<li>方法一：在 Java 代码中添加 sql 通配符，通过#{}赋值。</li>
<li>方法二：在 sql 语句中拼接通配符（注意这种写法会引起 sql 注入问题）</li>
</ul>
<h4 id="9-Mybatis是如何将sql执行结果封装为目标对象并返回的？-都有哪些映射形式？"><a href="#9-Mybatis是如何将sql执行结果封装为目标对象并返回的？-都有哪些映射形式？" class="headerlink" title="9. Mybatis是如何将sql执行结果封装为目标对象并返回的？ 都有哪些映射形式？"></a>9. Mybatis是如何将sql执行结果封装为目标对象并返回的？ 都有哪些映射形式？</h4><ul>
<li>第一种是使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映射关系。</li>
<li>第二种是使用 sql 列的别名功能，将数据库表中列的别名书写为对象属性名。</li>
</ul>
<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h4 id="10-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#10-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="10. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>10. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h4><p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；<strong>如果没有配置 namespace，那么 id 不能重复</strong>； 原因就是 namespace+id 是作为Mapper的 key 使用的，如果没有 namespace，就剩下 id，那么id 重复会导致数据互相覆盖。</p>
<h4 id="11-什么是-MyBatis-的接口绑定？有哪些实现方式？"><a href="#11-什么是-MyBatis-的接口绑定？有哪些实现方式？" class="headerlink" title="11. 什么是 MyBatis 的接口绑定？有哪些实现方式？"></a>11. 什么是 MyBatis 的接口绑定？有哪些实现方式？</h4><p>接口绑定：就是在 MyBatis 中定义任意接口，然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以了；</p>
<p>接口绑定有两种实现方式：</p>
<ul>
<li>一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含 Sql 语句来绑定；（不便于修改）</li>
<li>另外一种就是通过 xxxMapper.xml 里面写 SQL语句来绑定, 在这种情况下，要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。</li>
</ul>
<h4 id="12-【使用MyBatis的-mapper接口调用时有哪些注意事项？】"><a href="#12-【使用MyBatis的-mapper接口调用时有哪些注意事项？】" class="headerlink" title="12. 【使用MyBatis的 mapper接口调用时有哪些注意事项？】"></a>12. 【使用MyBatis的 mapper接口调用时有哪些注意事项？】</h4><ol>
<li>Mapper接口方法名和mapper.xml中定义的每个 sql 的 id 相同；</li>
<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同； </li>
<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</li>
<li>Mapper.xml 文件中的 namespace 即是mapper接口的类路径（即全类名）。</li>
</ol>
<h4 id="13-【通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问这个-Dao-接口的工作原理是什么？Dao-接口里的方法参数不同时方法能重载吗？】"><a href="#13-【通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问这个-Dao-接口的工作原理是什么？Dao-接口里的方法参数不同时方法能重载吗？】" class="headerlink" title="13. 【通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问这个 Dao 接口的工作原理是什么？Dao 接口里的方法参数不同时方法能重载吗？】"></a>13. 【通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问这个 Dao 接口的工作原理是什么？Dao 接口里的方法参数不同时方法能重载吗？】</h4><ul>
<li><p>Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code>；在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>
</li>
<li><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p>
</li>
<li><p>Dao 接口里的方法可以重载，但是 XML 里面的 ID 不允许重复，因为通过 Dao 寻找 XML对应的 sql 时以全限名+方法名的保存和寻找策略。即<strong>多个接口对应的映射必须只有一个</strong>，且需要满足以下条件：</p>
<ul>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种方式；</li>
</ul>
</li>
</ul>
<h4 id="14-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#14-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="14. Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>14. Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h4><p>Mybatis 有三种基本的 Executor 执行器：SimpleExecutor、ReuseExecutor、 BatchExecutor。</p>
<ol>
<li>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对 象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象， 而是放置于Map。</li>
<li>BatchExecutor：完成批处理。</li>
</ol>
<h2 id="✨消息队列RabbitMQ"><a href="#✨消息队列RabbitMQ" class="headerlink" title="✨消息队列RabbitMQ"></a>✨消息队列RabbitMQ</h2><h4 id="1-说说Broker服务节点、Queue队列、Exchange交换机"><a href="#1-说说Broker服务节点、Queue队列、Exchange交换机" class="headerlink" title="1. 说说Broker服务节点、Queue队列、Exchange交换机"></a>1. 说说Broker服务节点、Queue队列、Exchange交换机</h4><ul>
<li>Broker：一般情况下一个Broker可以看作一个RabbitMQ的服务器</li>
<li>Queue：RabbitMQ用于存储消息的内部对象，多个消费者可以订阅同一队列，这时队列中的消息会以轮询方式给多个消费者进行处理；</li>
<li>Exchange：生产者将消息发送给交换机，由交换机将消息路由到一个或者多个队列中，当路由不到时，返回给生产者或直接丢弃</li>
</ul>
<h4 id="2-如何进行消息队列的技术选型？"><a href="#2-如何进行消息队列的技术选型？" class="headerlink" title="2. 如何进行消息队列的技术选型？"></a>2. 如何进行消息队列的技术选型？</h4><h5 id="2-1-为什么使用消息队列？"><a href="#2-1-为什么使用消息队列？" class="headerlink" title="2.1 为什么使用消息队列？"></a>2.1 为什么使用消息队列？</h5><ul>
<li><strong>解耦</strong>：传统的软件开发模式，各个模块之间相互调用，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，数据耦合度高，<strong>使用消息队列的发布-订阅模式可以避免模块之间直接调用</strong>，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</li>
<li><strong>异步</strong>：消息队列提供了异步处理机制，在很多时候应用不想也不需要立即处理消息，<strong>允许应用把一些消息放入消息中间件中，并不立即处理它，在之后需要的时候再慢慢处理（减少响应所需的时间）</strong>。</li>
<li><strong>削峰</strong>：<strong>高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃</strong>。在电商网站的秒杀抢购这种突发性流量很强的业务场景中，消息队列的强大缓冲能力可以很好的起到削峰作用。</li>
</ul>
<h5 id="2-2-消息队列有什么缺点？"><a href="#2-2-消息队列有什么缺点？" class="headerlink" title="2.2 消息队列有什么缺点？"></a>2.2 消息队列有什么缺点？</h5><ul>
<li><strong>系统可用性降低</strong>：因为如果MQ出故障了就相当于整个系统就崩溃了</li>
<li><strong>系统复杂性提高</strong>：MQ存在消息重复消费、处理消息丢失情况、保证消息传递顺序性等问题</li>
<li><strong>数据一致性问题</strong>：消息队列可以实现异步确实可以提高系统响应速度。但是万一消息的真正消费者并没有正确消费消息就会导致数据不一致的情况</li>
</ul>
<h5 id="2-3-【Kafka、RabbitMQ、RocketMQ、ActiveMQ之间的区别】"><a href="#2-3-【Kafka、RabbitMQ、RocketMQ、ActiveMQ之间的区别】" class="headerlink" title="2.3 【Kafka、RabbitMQ、RocketMQ、ActiveMQ之间的区别】"></a>2.3 【Kafka、RabbitMQ、RocketMQ、ActiveMQ之间的区别】</h5><table>
<thead>
<tr>
<th>特 性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td>10万级别，这是kafka最大的优点，就是吞吐量高。     一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降     这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td>
<td>topic从几十个到几百个的时候，吞吐量会大幅度下降     所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>微秒级，这是rabbitmq的一大特点，延迟是最低的</td>
<td>ms级</td>
<td>延迟在ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>非常高，分布式架构</td>
<td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td></td>
<td>经过参数优化配置，可以做到0丢失</td>
<td>经过参数优化配置，消息可以做到0丢失</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ领域的功能极其完备</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>优劣势总结</td>
<td>非常成熟，功能强大，在业内大量的公司以及项目中都有应用     偶尔会有较低概率丢失消息     而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本     而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td>
<td>erlang语言开发，性能极其好，延时很低；     吞吐量到万级，MQ功能比较完备     而且开源提供的管理界面非常棒，用起来很好用     社区相对比较活跃，几乎每个月都发布几个版本分     在国内一些互联网公司近几年用rabbitmq也比较多一些     但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。     而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。     而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td>
<td>接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障     日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景     而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控     社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码     还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td>
<td>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展     同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量     而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略     这个特性天然适合大数据实时计算以及日志收集</td>
</tr>
</tbody></table>
<h4 id="3-引入MQ后如何保证其高可用性？"><a href="#3-引入MQ后如何保证其高可用性？" class="headerlink" title="3. 引入MQ后如何保证其高可用性？"></a>3. 引入MQ后如何保证其高可用性？</h4><ul>
<li>RabbitMQ的高可用性<ul>
<li>普通集群模式（只是用来提高吞吐量，可用性无法保证且可能产生大量数据传输）</li>
<li><strong>镜像集群模式</strong>：跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息拷贝到多个实例的queue里进行消息同步；</li>
</ul>
</li>
</ul>
<h4 id="4-【如何保证消息不被重复消费（如何保证消息消费时的幂等性）？】"><a href="#4-【如何保证消息不被重复消费（如何保证消息消费时的幂等性）？】" class="headerlink" title="4. 【如何保证消息不被重复消费（如何保证消息消费时的幂等性）？】"></a>4. 【如何保证消息不被重复消费（如何保证消息消费时的幂等性）？】</h4><ul>
<li><strong>在生产的每一条消息添加业务id作为唯一标识</strong>，使用 redis 将消费过的消息唯一标识存储起来，然后在消费端业务执行之前判断 redis 中是否已经存在这个标识，如果已经存在代表处理过了，不存在就放进 redis 并根据要求设置过期时间接着执行业务。</li>
<li><strong>将业务id作为数据库表的唯一索引</strong></li>
<li><strong>给业务表加一个version字段</strong>，每次更新把version作为条件，更新之后version+1。由于MySQL的innoDB是行锁，当其中一个请求成功更新之后，另一个请求才能进来，由于版本号version已经变成 2，更新的 SQL 语句影响行数为0，从而不会影响数据库数据</li>
</ul>
<h4 id="5-【如何保证RabbitMQ消息的可靠性传输（如何处理消息丢失的问题）？】"><a href="#5-【如何保证RabbitMQ消息的可靠性传输（如何处理消息丢失的问题）？】" class="headerlink" title="5. 【如何保证RabbitMQ消息的可靠性传输（如何处理消息丢失的问题）？】"></a>5. 【如何保证RabbitMQ消息的可靠性传输（如何处理消息丢失的问题）？】</h4><ul>
<li><p><strong>生产者端数据丢失</strong></p>
<ul>
<li>可以选择<strong>使用RabbitMQ提供的事务功能</strong>，就是生产者在发送数据之前开启事务然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，这时就可以回滚事务，然后尝试重新发送，如果收到了消息那么就可以提交事务。但这种方式有明显的缺点，即当RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。</li>
<li>可以<strong>开启confirm模式</strong>。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了。如果RabbitMQ没能处理这个消息，会回调你一个nack消息，告诉你这个消息失败了，你可以进行重试。而且可以结合这个机制知道在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</li>
</ul>
<p>事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后RabbitMQ会回调告知成功与否。 <strong>一般在生产者这块避免丢失，都是用confirm机制</strong>。</p>
</li>
<li><p><strong>MQ数据丢失</strong></p>
<p><strong>设置消息持久化到磁盘</strong>，设置持久化有两个步骤：</p>
<ul>
<li><strong>创建queue时将其设置为持久化的</strong>，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里面的数据。</li>
<li><strong>发送消息的时候将消息的deliveryMode设置为2，这样消息就会被设为持久化方式</strong>，此时RabbitMQ就会将消息持久化到磁盘上。 必须要同时开启这两个才可以，RabbitMQ 哪怕是挂了，再次重启也会从磁盘上重启恢复这个 queue 里的数据。</li>
</ul>
<p>而且持久化可以跟生产者的confirm机制配合起来，避免出现消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上就挂了，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前RabbitMQ挂了导致数据丢了，生产者收不到ack回调也会进行消息重发。</p>
</li>
<li><p><strong>消费者端数据丢失</strong></p>
<p><strong>使用RabbitMQ提供的basicAck机制</strong>，首先关闭RabbitMQ的自动ack，然后<strong>每次在确保处理完这个消息之后，在代码里手动调用ack</strong>。这样就可以避免消息还没有处理完就返回ack。</p>
</li>
</ul>
<h4 id="6-【如何保证消息的有序性？（即如何保证顺序消费）】"><a href="#6-【如何保证消息的有序性？（即如何保证顺序消费）】" class="headerlink" title="6. 【如何保证消息的有序性？（即如何保证顺序消费）】"></a>6. 【如何保证消息的有序性？（即如何保证顺序消费）】</h4><p>RabbitMQ 产生该问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。为了解决这个问题我们可以<strong>给 RabbitMQ 创建多个 queue，每个消费者固定消费一个 queue 的消息</strong>，生产者发送消息的时候，同一个订单号的消息发送到同一个 queue 中，由于同一个 queue 的消息是一定会保证是有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性。</p>
<h4 id="7-【-如何解决消息积压的情况？】"><a href="#7-【-如何解决消息积压的情况？】" class="headerlink" title="7.【 如何解决消息积压的情况？】"></a>7.【 如何解决消息积压的情况？】</h4><ul>
<li><strong>临时紧急扩容，快速处理堆积信息</strong>：先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停掉，写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue，接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据，<strong>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据，等快速消费完积压数据之后，就恢复原先部署架构，重新用原先的consumer机器来消费消息</strong>；</li>
<li><strong>丢弃+批量重导</strong>：如果消息积压在MQ里，并且长时间都没处理掉，导致MQ都快写满了，这种情况肯定是<strong>临时扩容方案执行太慢，这种时候只好采用 “丢弃+批量重导” 的方式来解决了。首先临时写个程序，连接到MQ里面消费数据，消费一个丢弃一个，快速消费掉积压的消息，降低MQ的压力，然后在流量低峰期时去手动查询重导丢失的这部分数据。</strong></li>
</ul>
<h4 id="8-MQ处理消息失败了怎么办？"><a href="#8-MQ处理消息失败了怎么办？" class="headerlink" title="8. MQ处理消息失败了怎么办？"></a>8. MQ处理消息失败了怎么办？</h4><p>一般生产环境中，都会在使用MQ的时候设计两个队列：一个是核心业务队列，一个是死信队列。核心业务队列，就是比如专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。<strong>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中</strong>。</p>
<h4 id="9-RabbitMQ和Kafka有什么区别？"><a href="#9-RabbitMQ和Kafka有什么区别？" class="headerlink" title="9. RabbitMQ和Kafka有什么区别？"></a>9. RabbitMQ和Kafka有什么区别？</h4><p><strong>它们之间主要有如下的区别：</strong></p>
<ol>
<li><p>应用场景方面</p>
<p>RabbitMQ：用于实时的，对可靠性要求较高的消息传递上。</p>
<p>Kafka：用于处于活跃的流式数据，大数据量的数据处理上。</p>
</li>
<li><p>架构模型方面</p>
<p>RabbitMQ：以broker为中心，有消息的确认机制。</p>
<p>Kafka：以consumer为中心，没有消息的确认机制。</p>
</li>
<li><p>吞吐量方面</p>
<p>RabbitMQ：支持消息的可靠传递，支持事务，不支持批量操作，基于存储的可靠性要求，存储可以采用内存或硬盘，吞吐量小。</p>
<p>Kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。</p>
</li>
<li><p>集群负载均衡方面</p>
<p>RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持。</p>
<p>Kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。</p>
</li>
</ol>
<h4 id="10-RabbitMQ的构造"><a href="#10-RabbitMQ的构造" class="headerlink" title="10. RabbitMQ的构造"></a>10. RabbitMQ的构造</h4><p>（1）<strong>Publisher：生产者</strong>，生产消息，就是投递消息的一方。消息一般包含两个部分：消息体（payload）和标签（Label）<br>（2）<strong>Consumer：消费者</strong>，消费消息，也就是接收消息的一方。消费者连接到RabbitMQ服务器并订阅到队列上。消费消息时只消费消息体，丢弃标签。<br>（3）<strong>Broker：服务节点</strong>，表示消息队列服务器实体。一般情况下一个Broker可以看做一个RabbitMQ服务器。<br>（4）<strong>Queue：消息队列</strong>，用来存放消息。一个消息可投入一个或多个队列，多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。<br>（5）<strong>Exchange：交换器</strong>，接收生产者发送的消息，根据路由键将消息路由到绑定的队列上。</p>
<ul>
<li>✨交换机的类型：<ul>
<li>direct：消息中的路由键（RoutingKey）如果和绑定中的 bindingKey 完全匹配，交换机就将消息发到对应的队列中。是基于完全匹配、单播的模式；</li>
<li>fanout：把发送到交换机的消息路由到所有绑定该交换机的队列中，是基于广播的模式；</li>
<li>topic：通过模式匹配的方式对消息进行路由，将路由键和某个路由模式进行匹配，此时队列需要绑定到一个模式上。</li>
</ul>
</li>
</ul>
<p>（6）<strong>Routing Key： 路由键</strong>，用于指定这个消息的路由规则，需要与交换器类型和绑定键(Binding Key)联合使用才能最终生效。<br>（7）<strong>Binding：绑定</strong>，通过绑定将交换器和队列关联起来，一般会指定一个BindingKey，通过BindingKey，交换器就知道将消息路由给哪个队列了。<br>（8）<strong>Connection ：网络连接</strong>，比如一个TCP连接，用于连接到具体broker<br>（9）<strong>Channel： 信道</strong>，AMQP 命令都是在信道中进行的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，一个TCP连接可以用多个信道。客户端可以建立多个channel，每个channel表示一个会话任务。<br>（10）<strong>Message：消息</strong>，由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。<br>（11）<strong>Virtual host：虚拟主机</strong>，用于逻辑隔离，表示一批独立的交换器、消息队列和相关对象。一个Virtual host可以有若干个Exchange和Queue，同一个Virtual host不能有同名的Exchange或Queue。最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段；</p>
<h4 id="11-生产者生产消息与消费者消费消息的过程"><a href="#11-生产者生产消息与消费者消费消息的过程" class="headerlink" title="11. 生产者生产消息与消费者消费消息的过程"></a>11. 生产者生产消息与消费者消费消息的过程</h4><ul>
<li><p><strong>生产者生产消息：</strong>Producer 先连接到Broker，建立连接Connection，开启一个信道Channel后，Producer 声明一个交换器和队列并设置好各自相关属性，通过绑定键将交换器和队列绑定起来；Producer 发送消息到 Broker，其中包含路由键、交换器等信息，交换器根据接收到的路由键查找匹配的队列，如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者，消息发送完毕后关闭信道；</p>
</li>
<li><p><strong>消费者接收消费消息：</strong>Consumer先连接到Broker，建立连接Connection，开启一个信道Channel，向 Broker 请求消费相应队列中消息，设置响应的回调函数。等待 Broker 回应并投递相应队列中的消息后接收消息。消费者在消费消息后，会给消息队列发送一个确认Ack确认已经收到消息，之后从队列中删除已经确定消费的消息，消息消费完毕后关闭信道；</p>
</li>
</ul>
<h2 id="消息队列Kafka"><a href="#消息队列Kafka" class="headerlink" title="消息队列Kafka"></a>消息队列Kafka</h2><h4 id="1-Kafka如何保证消息消费的顺序性？"><a href="#1-Kafka如何保证消息消费的顺序性？" class="headerlink" title="1. Kafka如何保证消息消费的顺序性？"></a>1. Kafka如何保证消息消费的顺序性？</h4><ul>
<li>对于Kafka ，生产者在写数据时可以指定一个key，具有相同key的数据会被分发到同一个partition中，且partition 中的消息在写入时都是有序的，可以在里面保证消息的顺序性，但是不同partition之间的消息是不保证有序的</li>
<li>对于topic的一个 partition 只能被同组内部的一个consumer去消费，在单线程处理情况下只要保证消息在MQ内部是由顺序的即可保证消费也是有顺序的；在多线程处理情况下，可以预先设置N个Queue，具有相同key的数据都放到同一个内存Queue中，然后开启N个线程，每个线程分别消费一个内存Queue的数据即可保证顺序性；</li>
</ul>
<h4 id="2-Kafka如何保证高可用？"><a href="#2-Kafka如何保证高可用？" class="headerlink" title="2. Kafka如何保证高可用？"></a>2. Kafka如何保证高可用？</h4><p>Kafka的基本架构组成是由多个broker组成一个集群，每个broker是一个节点（由一个或多个topic组成）；当创建一个topic时，这个topic会被划分为多个partition，每个partition只存放topic的一部分数据，可以存放在不同的broker上，<strong>在Kafka 0.8后提供了replica副本机制，每个partition上的数据都会同步到其他机器上形成自己的多个replica副本，所有replica会选举一个leader出来，消息的生产者和消费者只与这个leader打交道，其他replica作为follower，写的时候leader会负责将数据同步到所有的follower上，读的时候直接读leader上的数据即可</strong></p>
<h4 id="3-Kafka如何保证消息不丢失？"><a href="#3-Kafka如何保证消息不丢失？" class="headerlink" title="3. Kafka如何保证消息不丢失？"></a>3. Kafka如何保证消息不丢失？</h4><ul>
<li><p><strong>生产者端数据丢失</strong></p>
<p>对于生产者端数据丢失的主要情况：生产者发送消息给Kafka，由于网络等原因导致消息丢失</p>
<p>解决办法：<strong>通过在producer端设置acks=all来处理</strong>，这个参数是要求leader接收到消息后需要等到所有的follower都同步到消息之后才认为本次写成功，如果没满足这个条件则生产者会自动不断地重试；</p>
</li>
<li><p><strong>MQ数据丢失</strong></p>
<p>对于MQ数据丢失的主要情况：某个partition的leader在宕机时刚好有数据还没同步到follower，当选举某个follower成为leader后就会丢失一部分数据</p>
<p>解决办法：<strong>通过设置如下4个参数来避免</strong></p>
<ul>
<li>给topic设置replication.factor参数必须大于1，即要求每个partition必须有至少2个副本</li>
<li>在Kafka服务端设置min.insync.replicas参数必须大于1，即leader至少能感知到有一个follower还跟自己保持联系，确保leader宕机了还有一个有相同数据的follower节点</li>
<li>在producer端设置acks=all，及要求每条数据写入所有replica之后才能认为是写成功</li>
<li>在producer端设置retries=MAX，即一旦写入失败就无限重试</li>
</ul>
</li>
<li><p><strong>消费者端数据丢失</strong></p>
<p>对于生产者端数据丢失的主要情况：消息还没处理完Kafka就自动提交了offset，认为消费者已经处理完这条消息，如果消费者开始处理消息时宕机则这条消息就丢失了</p>
<p>解决办法：<strong>关闭自动提交offset，在消费者处理完成后再手动提交offset</strong></p>
</li>
</ul>
<h4 id="4-描述下Kafka中的leader-replica和follower-replica的区别"><a href="#4-描述下Kafka中的leader-replica和follower-replica的区别" class="headerlink" title="4. 描述下Kafka中的leader replica和follower replica的区别"></a>4. 描述下Kafka中的leader replica和follower replica的区别</h4><p>只有leader副本才能对外提供读写服务，响应客户端的请求，follower副本知识采用pull的方式被动地同步leader副本中的数据，并且在leader副本所在的broker宕机后随时准备选举为leader副本，不过leader和follower的消息序列在实际场景中可能不一致，确保一致性的主要手段是高水平机制（HW），但高水平值无法保证leader连续变更场景下的数据一致性，后续引入了leader epoch机制来修复高水平值的弊端；</p>
<h4 id="5-为什么Kafka不支持读写分离？"><a href="#5-为什么Kafka不支持读写分离？" class="headerlink" title="5. 为什么Kafka不支持读写分离？"></a>5. 为什么Kafka不支持读写分离？</h4><p>在Kafka中生产者写入消息和消费者读取消息的操作都是与leader副本进行交互的，实现的是一种主读主写的生产消费模型，不支持主写从读</p>
<p>读写分离存在的2个缺点：</p>
<ul>
<li><strong>数据一致性问题：</strong>数据从主节点复制到从节点必然会有一个延时的时间窗口导致主从节点之间的数据不一致；</li>
<li><strong>延时问题：</strong>Kafka的主从同步需要经历网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘这几个阶段，需要耗费大量的时间</li>
</ul>
<h2 id="✨👏MySQL（索引及其优化、事务、SQL调优、SQL语句编写、数据库表设计）"><a href="#✨👏MySQL（索引及其优化、事务、SQL调优、SQL语句编写、数据库表设计）" class="headerlink" title="✨👏MySQL（索引及其优化、事务、SQL调优、SQL语句编写、数据库表设计）"></a>✨👏MySQL（索引及其优化、事务、SQL调优、SQL语句编写、数据库表设计）</h2><h4 id="1-简单描述-MySQL-中的各种索引（主键索引，唯一索引，联合索引）的区别"><a href="#1-简单描述-MySQL-中的各种索引（主键索引，唯一索引，联合索引）的区别" class="headerlink" title="1. 简单描述 MySQL 中的各种索引（主键索引，唯一索引，联合索引）的区别"></a>1. 简单描述 MySQL 中的各种索引（主键索引，唯一索引，联合索引）的区别</h4><p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<ul>
<li>普通索引(由关键字 KEY 或 INDEX 定义的索引)允许被索引的数据列包含重复的值，不附加任何限制条件，只用于提高查询效率，可以创建在任何数据类型中</li>
<li>使用unique约束可以设置为唯一索引，限制该索引的值必须是唯一的，但允许有空值；<strong>在一张表中可以有多个唯一性索引；</strong></li>
<li>主键，是一种特殊的唯一索引，在唯一性索引的基础上增加not null的约束，<strong>在一张表中只能定义一个主键索引</strong>，主键用于唯一标识一条记录，使用关键字PRIMARY KEY来创建。 </li>
<li>联合索引可以覆盖多个数据列闯进啊一个索引，如像 INDEX(columnA, columnB)索引，索引指向创建时对应的多个字段，<strong>在查询时只有查询条件使用了这些字段中的第一个字段时才会被使用（最左前缀原则）</strong>。 </li>
</ul>
<h5 id="【1-1-索引的设计原则有哪些？】"><a href="#【1-1-索引的设计原则有哪些？】" class="headerlink" title="【1.1 索引的设计原则有哪些？】"></a>【1.1 索引的设计原则有哪些？】</h5><ul>
<li>适合索引得列是出现在where子句中的列，或者连接子句中指定的列；</li>
<li>在选择索引列是越短越好，可以指定某些列的一部分，没必要用全部字段的值；</li>
<li>不要给表中的每一个字段都创建索引，选择那些区分度较大的列创建；</li>
<li>定义有外键的数据列一定要创建索引；</li>
<li>更新频繁的字段不要有索引；</li>
<li>组合索引的列的个数不建议太多；</li>
<li>大文本、大对象不要创建索引；</li>
</ul>
<h5 id="✨1-2-数据库索引失效的情况？"><a href="#✨1-2-数据库索引失效的情况？" class="headerlink" title="✨1.2 数据库索引失效的情况？"></a>✨1.2 数据库索引失效的情况？</h5><ul>
<li>使用!=或者&lt;&gt;导致索引失效</li>
<li>在索引列使用函数也是不走索引的</li>
<li>对索引列进行运算（+、-、*、/）也不走索引</li>
<li>把%放在匹配字段前产生的模糊搜索是不走索引的，放在后面才会走索引</li>
<li>NOT IN、NOT EXISTS会导致索引失效</li>
</ul>
<h5 id="1-3-使用索引查询一定能提高查询的性能吗？"><a href="#1-3-使用索引查询一定能提高查询的性能吗？" class="headerlink" title="1.3 使用索引查询一定能提高查询的性能吗？"></a>1.3 使用索引查询一定能提高查询的性能吗？</h5><p>不一定，索引本身需要额外的空间来存储，每当记录在表中增减或索引列被修改时，索引本身也会被修改，可能导致部分索引失效，那些不必要的是小索引反而会使查询反应变慢降低查询性能；</p>
<h4 id="✨2-【介绍一下数据库中的事务特性和隔离级别-】"><a href="#✨2-【介绍一下数据库中的事务特性和隔离级别-】" class="headerlink" title="✨2. 【介绍一下数据库中的事务特性和隔离级别?】"></a>✨2. 【介绍一下数据库中的事务特性和隔离级别?】</h4><p>事务（transaction）是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p>
<p><strong>数据库事务ACID特性：</strong> </p>
<ol>
<li>原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态；</li>
<li>隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务；</li>
<li>持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</li>
</ol>
<p><strong>数据并发问题分类：</strong> </p>
<ol>
<li><p>脏读：对于两个事务T1和T2，T1读取了被T2更新但还没有提交的字段，若T2回滚，T1读取的内容就是临时且无效的； </p>
</li>
<li><p>不可重复读：对于两个事务T1和T2，T1读取了一个字段，之后T2更新了该字段，T1再次读取的同一个字段值就不同了； </p>
</li>
<li><p>幻读：对于两个事务T1和T2，T1从一个表读取了一个字段，之后T2在该表插入了一些新的行，T1再次读取同一个表就会多出几行；</p>
</li>
<li><p>脏写：对于两个事务T1和T2，T1修改了另一个未提交事务的T2修改过的数据</p>
</li>
</ol>
<p>✨<strong>数据库事务隔离级别：</strong></p>
<ol>
<li>read uncommitted：读未提交(只可解决脏写)</li>
<li>read committed：读已提交(可避免脏读)</li>
<li>repeatable read：可重复读，是<strong>MySQl的默认隔离级别</strong>(可避免脏读、不可重复读但不可避免幻读，实际上采用<strong>MVCC+临键锁</strong>也可以把幻读也避免了)</li>
<li>serializable：可串行化(可避免脏读、不可重复读、幻读)</li>
</ol>
<h5 id="✨【2-1-数据库并发场景有哪些？事务隔离是如何实现的？】"><a href="#✨【2-1-数据库并发场景有哪些？事务隔离是如何实现的？】" class="headerlink" title="✨【2.1 数据库并发场景有哪些？事务隔离是如何实现的？】"></a>✨【2.1 数据库并发场景有哪些？事务隔离是如何实现的？】</h5><p>数据库并发场景有三种，分别是：</p>
<ol>
<li>读读：不存在任何问题，也不需要并发控制；</li>
<li>读写：有线程安全问题，可能造成事务隔离性问题；</li>
<li>写写：有线程安全问题，可能存在更新丢失问题；</li>
</ol>
<p><strong>MVCC</strong>：多版本并发控制，是一种用来<strong>解决读写冲突的无锁并发控制机制</strong>，即为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，<strong>读操作只读该事务开始前的数据库快照</strong>，MVCC可以解决的问题如下：</p>
<ol>
<li><p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；</p>
<p>例如：使用MVCC来进行实现，在B事务开始修改账户且事务未提交时，当A事务需要读取账户余额时，此时会读取到B事务修改操作之前的账户余额的副本数据，但是如果A事务也需要修改账户余额数据就必须要等待B事务提交事务。</p>
</li>
<li><p>解决并发读写造成的脏读、幻读和不可重复读等事务隔离问题，但是不能解决并发写写更新丢失问题；</p>
</li>
</ol>
<p><strong>注意：MVCC只在REPEATABLE READ和READ COMMITIED两个隔离级别下工作。其他两个隔离级别都和 MVCC不兼容</strong> ，因为READ UNCOMMITIED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁所以这两个级别不需要考虑事务隔离；</p>
<h5 id="2-2-MVCC的实现原理是什么？（待补充）"><a href="#2-2-MVCC的实现原理是什么？（待补充）" class="headerlink" title="2.2 MVCC的实现原理是什么？（待补充）"></a>2.2 MVCC的实现原理是什么？（待补充）</h5><ul>
<li><p>两种隔离界别下的核心处理逻辑就是<strong>判断所有版本中哪个版本是当前事务可见的处理</strong>。针对这个问题InnoDB在设计上增加了<strong>ReadView</strong>的设计，ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，用于判定该事务可见到的数据版本。</p>
<ul>
<li><p>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView，从而做到保证每次提交后的数据是处于当前的可见状态；</p>
</li>
<li><p>使用REPEATABLE READ 隔离级别下的ReadView在事务开始后第一次读取数据时生成一个ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读。</p>
</li>
</ul>
</li>
</ul>
<h4 id="✨3-【MyISAM和InnoDB存储引擎的区别有哪些？】"><a href="#✨3-【MyISAM和InnoDB存储引擎的区别有哪些？】" class="headerlink" title="✨3. 【MyISAM和InnoDB存储引擎的区别有哪些？】"></a>✨3. 【MyISAM和InnoDB存储引擎的区别有哪些？】</h4><ol>
<li><p><strong>是否支持事务：</strong>InnoDB 支持事务，MyISAM 不支持事务。</p>
</li>
<li><p><strong>是否支持外键：</strong>InnoDB 支持外键，而 MyISAM 不支持外键。</p>
</li>
<li><p><strong>使用索引类型：</strong>InnoDB 有聚簇索引和非聚簇索引，MyISAM 只有非聚簇索引。（索引是存储在磁盘中的）</p>
<h5 id="3-1-【讲一讲聚簇索引和非聚簇索引？】"><a href="#3-1-【讲一讲聚簇索引和非聚簇索引？】" class="headerlink" title="3.1  【讲一讲聚簇索引和非聚簇索引？】"></a>3.1  【讲一讲聚簇索引和非聚簇索引？】</h5><p>MySQL的索引类型跟存储引擎是相关的，innodb的数据文件和索引文件全部都放在ibd文件中，而myisam的数据文件放在myd文件中，而索引放在myi文件中，<strong>区分聚簇索引和非聚簇索引只要判断数据和索引是否存储在一起即可</strong>；</p>
<p><strong>聚簇索引（主键索引）</strong>：叶子节点存储了整行数据，即数据节点将数据与索引放到了一起，找到索引也就找到了数据；</p>
<p><strong>非聚簇索引（非主键索引、二级索引）</strong>：叶子节点只存储了该行对应的索引，不存储表中的数据；</p>
<p>在通常情况下聚簇索引查询只会查一次，而非聚簇索引需要回表查询多次，回表操作属于随机IO，需要回表次数越多就越倾向于使用全表扫描；</p>
<h5 id="3-2-非聚簇索引一定会回表查询吗？"><a href="#3-2-非聚簇索引一定会回表查询吗？" class="headerlink" title="3.2 非聚簇索引一定会回表查询吗？"></a>3.2 非聚簇索引一定会回表查询吗？</h5><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询，查一次即可（一个索引包含所有需要查询字段的值被称为覆盖索引）；</p>
</li>
<li><p><strong>读写效率：</strong>InnoDB读的效率低于MyISAM，但是写的效率高于MyISAM，InnoDB不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    </p>
</li>
<li><p><strong>锁的粒度：</strong>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁；</p>
</li>
<li><p>InnoDB支持自动增加列AUTO_INCREMENT属性，支持MVCC模式的读写，而MyISAM都不支持；</p>
</li>
<li><p>清空整个表的时候，InnoDB会一行一行地删除，而MyISAM则会新建表；</p>
</li>
</ol>
<h4 id="4-数据库设计三范式了解吗？"><a href="#4-数据库设计三范式了解吗？" class="headerlink" title="4. 数据库设计三范式了解吗？"></a>4. 数据库设计三范式了解吗？</h4><ul>
<li>键和相关属性概念<ul>
<li>超键：能唯一标识元组的属性集，超键包含候选键和主键（一个属性，或多个属性组合在一起都可以作为一个超键）</li>
<li>候选键（码）：没有冗余属性的超键（最小超键）</li>
<li>主键（主码）：用户可以从候选键中选择一个作为主键，是数据表中对存储数据对象予以唯一和完整标识的数据列或属性的组合</li>
<li>外键：在一个表中存在的另一个表的主键</li>
<li>主属性：包含在任一候选键中的属性</li>
<li>非主属性：不包含在任一候选键中的属性</li>
</ul>
</li>
<li><strong>设计三范式</strong><ul>
<li>第一范式：要确保数据表中<strong>每个字段的值必须具有原子性</strong>，每个字段都是不可再次拆分的源自数据项；（对属性的原子性约束）</li>
<li>第二范式：在满足第一范式的基础上，要求满足数据表里的<strong>每一条数据记录都是可唯一标识的</strong>，而且<strong>所有非主键字段都必须完全依赖主键，不能只依赖主键的一部分</strong>（对记录的惟一性约束）</li>
<li>第三范式：在满足第二范式基础上，要求数据表中的所有非主键字段不能依赖于其他非主键字段，即<strong>非主键属性之间不能有依赖关系，必须相互独立，每个都和主键直接相关</strong>；（对字段冗余性的约束）</li>
<li>巴斯科德范式：在满足第三范式的基础上，<strong>只有一个候选键，或它的每个候选键都是单属性</strong></li>
</ul>
</li>
<li><strong>SQL约束种类</strong><ul>
<li>NOT NULL：用于控制字段的内容一定不为空</li>
<li>UNIQUE：用于控制字段内容不能重复，一个表允许有多个Unique约束</li>
<li>PRIMARY KEY：也用于控制字段内容不能重复，但一个表只允许出现一个</li>
<li>FOREIGN KEY：用于连接多个表的动作，防止非法数据插入外键列</li>
</ul>
</li>
</ul>
<h4 id="5-你了解MySQL的日志吗？"><a href="#5-你了解MySQL的日志吗？" class="headerlink" title="5. 你了解MySQL的日志吗？"></a>5. 你了解MySQL的日志吗？</h4><ul>
<li><p>事务日志</p>
<ul>
<li><p><strong>redo日志</strong>：重做日志</p>
<ol>
<li><p>作用：用来保证事务的持久性，内存先往日志中写入修改内容再写入磁盘，只有日志写入成功了才算事务提交成功，进而进行刷盘操作；</p>
</li>
<li><p>特点：</p>
<ol>
<li>在执行事务的过程中每执行一条sql语句就产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，即使用顺序io进行写入磁盘操作；</li>
<li>redo日志是存储引擎层产生的，在事务执行的过程中一直不断地往redo日志顺序记录；</li>
</ol>
</li>
<li><p><strong>redo的整体流程：</strong></p>
<ol>
<li><p>硬盘中要修改的data先加载到内存的缓冲池中，data修改后在内存中直接更新data buffer；</p>
</li>
<li><p>redo log的写入并不是直接写入磁盘的，data buffer会先写入内存中的redo log buffer中记录更新信息，之后以一定的频率刷入到真正在磁盘中的redo log file中实现持久化；</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>undo日志</strong>：回滚日志</p>
<ol>
<li>作用：用来保证事物的原子性和一致性，在事务中<strong>更新数据之前</strong>会先写入一个undo日志；</li>
<li>特点：<ol>
<li>undo是逻辑日志。回滚数据只是将数据库逻辑恢复到原来的样子，所有修改都被逻辑地取消；</li>
<li>可通过undo来完成<strong>MVCC</strong>（多版本并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照）；</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="6-【-Innodb如何实现mysql的事务】"><a href="#6-【-Innodb如何实现mysql的事务】" class="headerlink" title="6.【 Innodb如何实现mysql的事务】"></a>6.【 Innodb如何实现mysql的事务】</h4><p>事务进⾏过程中，每次sql语句执⾏，都会记录undo log和redo log，然后更新数据形成脏⻚，然后redo log按照时间或者空间等条件进⾏落盘，undo log和脏⻚按照checkpoint进⾏落盘，全部都成功落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发⽣崩溃，则⾸先检查checkpoint记录获取信息，使⽤相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤undo log进⾏事务回滚。事务执⾏COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚继续按照checkpoint进⾏落盘。如果此时发⽣了崩溃，则只使⽤redo log恢复数据。</p>
<h4 id="✨7-说一说索引的底层原理实现？"><a href="#✨7-说一说索引的底层原理实现？" class="headerlink" title="✨7. 说一说索引的底层原理实现？"></a>✨7. 说一说索引的底层原理实现？</h4><p>MySQL底层使用B+Tree作为数据结构</p>
<h5 id="7-1-【为什么索引结构默认使用B-Tree，而不是B-Tree呢？】"><a href="#7-1-【为什么索引结构默认使用B-Tree，而不是B-Tree呢？】" class="headerlink" title="7.1 【为什么索引结构默认使用B+Tree，而不是B-Tree呢？】"></a>7.1 【为什么索引结构默认使用B+Tree，而不是B-Tree呢？】</h5><ul>
<li><strong>B+树按照节点类型可分为</strong>：<ul>
<li>叶子节点：B+树最底层的节点，存储行记录；</li>
<li>非叶子节点：存储索引键和页面指针，不存储行记录本身；</li>
</ul>
</li>
<li><strong>B+树的性质：</strong><ol>
<li>所有的非叶子节点不用来保存数据而是保存数据的索引，可以看成是索引部分，节点中仅含其子树中的最大或最小关键字；</li>
<li>所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且<strong>叶子节点本身按照关键字的大小自小而大顺序链接</strong>；</li>
<li>在B+树中，数据对象的插入和删除仅在叶节点上进行，其有2个头指针，一个是树的根节点，一个是最小关键字的叶节点；</li>
</ol>
</li>
<li><strong>B+树如何进行记录检索？</strong><br>从B+树的根节点开始，逐层检索直到找到叶子节点，即找到对应的数据页为止，将数据页加载到内存中，页目录中的槽采用<strong>二分查找</strong>的方式先找到一个粗略的记录分组，然后再在分组中通过<strong>链表遍历</strong>的方式查找记录；</li>
</ul>
<h4 id="8-【为什么MySQL索引结构默认使用B-树而不是B树、Hash，二叉树，红黑树？】"><a href="#8-【为什么MySQL索引结构默认使用B-树而不是B树、Hash，二叉树，红黑树？】" class="headerlink" title="8. 【为什么MySQL索引结构默认使用B+树而不是B树、Hash，二叉树，红黑树？】"></a>8. 【为什么MySQL索引结构默认使用B+树而不是B树、Hash，二叉树，红黑树？】</h4><p>✨<strong>与B-Tree相比较</strong>：</p>
<ol>
<li><strong>B+树的磁盘读写代价更低</strong>：B+树的内部节点并没有指向关键字具体信息的指针，而是保存在叶子节点，因此其内部节点相比B树更小，如果把同一内部节点的关键字存放在同一盘块中，那么B+树所能容纳关键字数量更多，一次性能读入内存的关键字就更多，降低IO读写次数；</li>
<li><strong>由于B+树的数据都存储在叶子节点中适合在区间查询</strong>，分支节点均为索引不存储数据，并且叶子结点之间用链表方式相连，每个叶子节点都指向相邻的叶子节点的地址，因此进行范围查找时只需遍历一遍叶子节点即可，但B树因为其分支节点同样存储着数据，要找到具体数据需要进行一次中序遍历按序去遍历所有节点才行；</li>
</ol>
<p>✨<strong>与Hash索引（Memory数据库）比较：</strong></p>
<p>Hash索引基于哈希表实现，只有精确匹配所有的索引查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个hashcode，并且Hash索引将所有的hashcode存储在索引表中，同时在索引表中保存指向每个数据行的指针；</p>
<ol>
<li>基于Hash表实现，只有Memory存储引擎显式支持哈希索引，其他存储引擎都不支持；</li>
<li>Hash索引不是按照索引值顺序存储的，不能像B+树索引一样利用索引完成排序；</li>
<li><strong>Hash索引始终索引所有列的全部内容，不支持部分索引列的匹配查找</strong>；</li>
<li>在有大量重复键值的情况下存在哈希碰撞问题，Hash索引的效率会很低；</li>
</ol>
<p><strong>与二叉树、红黑树比较：</strong></p>
<ul>
<li>二叉树的高度不均匀不能自平衡，查找效率跟树的高度有关，并且IO代价高</li>
<li>红黑树的高度随着数据量的增加而增加，IO代价高</li>
</ul>
<h4 id="9-为什么需要注意联合索引中的顺序？"><a href="#9-为什么需要注意联合索引中的顺序？" class="headerlink" title="9. 为什么需要注意联合索引中的顺序？"></a>9. 为什么需要注意联合索引中的顺序？</h4><p>在联合索引中如果想要命中索引，需要按照建立索引时的字段顺序有序使用，否则无法命中索引（一般情况下将查询需求频繁或者字段选择性高的列放在前面）</p>
<h5 id="9-1【知道MySQL的最左前缀原则吗？】"><a href="#9-1【知道MySQL的最左前缀原则吗？】" class="headerlink" title="9.1【知道MySQL的最左前缀原则吗？】"></a>9.1【知道MySQL的最左前缀原则吗？】</h5><p>最左前缀原则就是<strong>最左优先</strong>，在创建多列索引时，要根据业务需求，where子句中使用最频繁的几列字段放在最左边，一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配；</p>
<h5 id="9-2-了解前缀索引吗？（待补充）"><a href="#9-2-了解前缀索引吗？（待补充）" class="headerlink" title="9.2 了解前缀索引吗？（待补充）"></a>9.2 了解前缀索引吗？（待补充）</h5><p>前缀索引是只把长字段前面的公共部分作为一个索引，可以避免索引字段过长占用内存空间和不利于维护，但要注意order by不支持前缀索引；</p>
<h5 id="9-3-了解索引下推吗？（待补充）"><a href="#9-3-了解索引下推吗？（待补充）" class="headerlink" title="9.3 了解索引下推吗？（待补充）"></a>9.3 了解索引下推吗？（待补充）</h5><p>索引下推是通过把索引过滤条件下推到存储引擎，来减少 MySQL 存储引擎访问基表的次数以及 MySQL 服务层访问存储引擎的次数；</p>
<h5 id="✨9-4-【怎么通过执行计划查看MySQL语句有没有用到索引？】"><a href="#✨9-4-【怎么通过执行计划查看MySQL语句有没有用到索引？】" class="headerlink" title="✨9.4 【怎么通过执行计划查看MySQL语句有没有用到索引？】"></a>✨9.4 【怎么通过执行计划查看MySQL语句有没有用到索引？】</h5><p>通过<code>EXPLAIN 具体SQL语句</code>来进行查看</p>
<ul>
<li><strong>type</strong>：提供了判断查询是否高效的重要依据，可以通过type字段判断此次查询是全表扫描还是索引扫描，如以下几种情况：const（主键索引或唯一二级索引进行等值匹配的情况），ref（普通二级索引列与常量进行等值匹配），index（扫描全表索引的覆盖索引），一般要求必须为ref以上，最好为const，不能为all</li>
<li><strong>possible_keys</strong>：显示在查询时可选用的各个索引</li>
<li><strong>key</strong>：显示MySQL在当前查询时真正使用到的索引</li>
<li><strong>rows</strong>：MySQL查询优化器根据统计信息，SQL要查找到结果需要扫描读取的数据行数的预估值，直观显示SQL语句的效率好坏</li>
</ul>
<h5 id="9-5-为什么建议使用自增长主键作为索引？"><a href="#9-5-为什么建议使用自增长主键作为索引？" class="headerlink" title="9.5 为什么建议使用自增长主键作为索引？"></a>9.5 为什么建议使用自增长主键作为索引？</h5><p>因为自增主键是连续的，在插入过程中尽量减少页分裂并且能减少数据的移动，每次插入都是插入到最后，即能减少分裂和移动的频率；</p>
<h4 id="10-【-了解MySQL数据库锁的实现原理吗？】"><a href="#10-【-了解MySQL数据库锁的实现原理吗？】" class="headerlink" title="10.【 了解MySQL数据库锁的实现原理吗？】"></a>10.【 了解MySQL数据库锁的实现原理吗？】</h4><ul>
<li><p>从数据操作类型划分：</p>
<ul>
<li>读锁（共享锁，即S锁）：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不会阻塞，共享锁可以加上多个；</li>
<li>写锁（排他锁，即X锁）：当前写操作没有完成前会阻断其他写锁和读锁，确保在给定时间内只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源，排他锁只可以加一个</li>
</ul>
</li>
<li><p>从锁的粒度划分：</p>
<ul>
<li><p>表锁（对当前操作的整张表加锁，锁定粒度最大，开销小加锁快，不会出现死锁，但是锁冲突概率高，MyIsam和InnoDB引擎都支持）</p>
<p><strong>意向锁</strong>：一种不与行锁冲突的表锁，为了协调行锁和表锁的关系，表明“某个事务正在某些行持有了锁或该事务准备去持有锁”，可以分为意向排他锁和意向共享锁；</p>
</li>
<li><p>行锁（只针对当前操作的行进行加锁，锁定粒度最小，锁冲突概率低，但是锁的开销大，加锁慢，容易出现<strong>死锁</strong>情况，InnoDB引擎支持）</p>
<p><strong>记录锁</strong>：为某行记录加锁，封住该行的索引记录而不是真正的数据记录；</p>
<p><strong>间隙锁（gap key）</strong>：不允许别的事务在指定记录前面的间隙插入新记录，<strong>不是针对某一记录加锁而是锁定一个范围</strong>，gap锁可以用于防止幻读；</p>
<p><strong>插入意向锁</strong>：事务在等待时在内存中生成的锁结构，表明有事务想在某个间隙中插入新记录但是现在在等待，本质上是一种gap锁，只在insert操作时产生；</p>
<p><strong>临键锁（Next-key log）</strong>：在锁住某条记录的同时，又阻止其他事务在该记录前边的间隙插入新纪录；<strong>（本质上说是记录锁和间隙锁的结合）</strong></p>
</li>
<li><p>页锁（一次锁定相邻的一组记录，会出现死锁，InnoDB和BDB引擎都支持，锁定粒度介于行锁和表锁之间）</p>
</li>
</ul>
</li>
<li><p>✨从对待锁的态度划分：</p>
<ul>
<li><p><strong>悲观锁</strong>：假定会发生并发冲突，在获取数据时会先加锁确保数据不会被别的线程修改，共享资源每次只给一个线程使用，其他线程阻塞，直到事务提交后才把资源转让给其他线程，适用于多写的使用场景；<strong>（使用数据库锁机制实现）</strong></p>
</li>
<li><p><strong>乐观锁</strong>：假定不会发生并发冲突，只有在对数据进行更新操作时，才会对数据加锁判断之前数据是否有被修改，不采用数据库自身的锁机制，而是通过程序来实现，适用于多读的应用类型提高吞吐量；<strong>（使用版本号或者时间戳机制，或CAS算法实现）</strong></p>
<ul>
<li><p><strong>数据版本号（Version）机制</strong></p>
<p>通过为数据库表增加一个<strong>数字类型的 “version” 字段</strong>来实现。当读取数据时，将version字段的值一同读出，<strong>数据每更新一次，version值加1</strong>。当我们提交更新的时候，将数据库表对应记录的当前版本信息与更新前取出来的version值进行比对，如果数据库表当前版本号与更新前取出来的version值相等，则予以更新，否则认为是版本冲突。</p>
</li>
<li><p><strong>时间戳机制</strong></p>
<p>同样是在数据库表中增加一个字段，<strong>字段类型使用时间戳（timestamp）</strong>, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则予以更新，否则就是版本冲突。</p>
</li>
<li><p><strong>CAS算法</strong></p>
<p>CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不会做任何操作。这处理思想和乐观锁的冲突检查+数据更新的原理是一样的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="10-1-隔离级别与锁的关系"><a href="#10-1-隔离级别与锁的关系" class="headerlink" title="10.1 隔离级别与锁的关系"></a>10.1 隔离级别与锁的关系</h5><ul>
<li>在Read Committed级别下，读操作需要加共享锁，但在语句执行完以后要释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但在事务提交之前并不释放共享锁，即必须等待事务执行完毕以后才释放共享锁；</li>
</ul>
<h5 id="10-2-优化锁的方法"><a href="#10-2-优化锁的方法" class="headerlink" title="10.2 优化锁的方法"></a>10.2 优化锁的方法</h5><ul>
<li>使用较低的隔离级别缩小锁的锁定范围</li>
<li>使用索引去访问数据使得加锁更加精确，减少锁冲突</li>
<li>不同程序访问一组表时尽量约定一个相同的顺序访问各表，减少死锁的机会</li>
<li>数据查询时非必要不要加锁，而采用MVCC实现事务查询</li>
</ul>
<h4 id="11-【分库分表相关内容】（后续需要再了解）"><a href="#11-【分库分表相关内容】（后续需要再了解）" class="headerlink" title="11. 【分库分表相关内容】（后续需要再了解）"></a>11. 【分库分表相关内容】（后续需要再了解）</h4><h5 id="11-1-什么是分库分表？"><a href="#11-1-什么是分库分表？" class="headerlink" title="11.1 什么是分库分表？"></a>11.1 什么是分库分表？</h5><p><strong>分库</strong> 就是将一个数据库中的数据（最多支撑到并发2000，健康单库并发在每秒1000左右）分散到多个不同的数据库上。</p>
<p>下面这些操作都涉及到了分库：</p>
<ul>
<li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li>
<li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li>
</ul>
<h5 id="11-2-如何对数据库进行垂直拆分或水平拆分？"><a href="#11-2-如何对数据库进行垂直拆分或水平拆分？" class="headerlink" title="11.2 如何对数据库进行垂直拆分或水平拆分？"></a>11.2 如何对数据库进行垂直拆分或水平拆分？</h5><p><strong>分表</strong> 就是对单表的数据（一般单表到几百万）进行拆分，把一个表的数据放到多个表中，查询的时候就查一个表，可以是垂直拆分，也可以是水平拆分：</p>
<ul>
<li><strong>水平拆分：</strong>把一个表的数据放到多个库的多个表中，但是每个库的表结构都一样，只是每个库存放的数据是不同的，所有库表的数据加起来就是全部数据；<strong>（即水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表）</strong><ul>
<li>水平拆分的意义：就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</li>
</ul>
</li>
<li><strong>垂直拆分：</strong>把一个有很多字段的表给拆分成多个表或者是多个库上去，每个库表的结构都不一样，每个库表都包含部分字段，一般来说会将访问频率很高的字段放到一个表中，然后将较多的访问频率很低的字段放到其他表中；<strong>（即垂直拆分是对数据表列的拆分，把一张字段比较多的表拆分为多张表）</strong><ul>
<li>垂直拆分的意义：数据库也是有缓存的，访问频率高的字段越少，就可以在缓存中缓存更多的行，性能就越好。</li>
</ul>
</li>
</ul>
<h5 id="11-3-分库分表会带来什么问题？"><a href="#11-3-分库分表会带来什么问题？" class="headerlink" title="11.3 分库分表会带来什么问题？"></a>11.3 分库分表会带来什么问题？</h5><ul>
<li><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li>
<li><strong>分布式事务</strong> ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了，需要使用分布式事务。</li>
<li><strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li>
</ul>
<h5 id="11-4-如何设计才可以让系统从未分库分表动态切换到分库分表上？"><a href="#11-4-如何设计才可以让系统从未分库分表动态切换到分库分表上？" class="headerlink" title="11.4 如何设计才可以让系统从未分库分表动态切换到分库分表上？"></a>11.4 如何设计才可以让系统从未分库分表动态切换到分库分表上？</h5><ul>
<li>停机迁移方案</li>
<li><strong>不停机双写迁移方案</strong><ul>
<li>简单来说，就是在线上系统里面同时对老库和新库执行增删改的操作，这就是所谓的双写。然后新系统部署上线后，用数据迁移工具读取老库数据写入到新库。如果读出来的数据在新库里没有，或者这条数据的最后修改的时间比新库的数据新才会写入，简单来说，就是不允许用老数据覆盖新数据。导完一轮之后，有可能数据还是存在不一致，那么程序自动做一轮校验，对比新老库每个表的每条数据，如果有不一样的就针对那些不一样的地方从老库读数据再次写。经过反复循环，直到两个库每个表的数据都完全一致为止。</li>
</ul>
</li>
</ul>
<h5 id="11-5-分库分表之后全局id怎么生成？"><a href="#11-5-分库分表之后全局id怎么生成？" class="headerlink" title="11.5 分库分表之后全局id怎么生成？"></a>11.5 分库分表之后全局id怎么生成？</h5><ul>
<li><p><strong>使用snowflake算法</strong>（其他id生成策略还有数据库自增id、UUID和时间戳）</p>
<p>其核心思想是：使用41bit作为时间戳位，10bit作为工作进程位置（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个预留符号恒为0。</p>
</li>
</ul>
<h4 id="✨12-【如何处理MySQL的慢查询？】"><a href="#✨12-【如何处理MySQL的慢查询？】" class="headerlink" title="✨12. 【如何处理MySQL的慢查询？】"></a>✨12. 【如何处理MySQL的慢查询？】</h4><ol>
<li><p>开启慢查询日志，准确定位到具体是哪个sql语句出现了问题；</p>
</li>
<li><p>分析sql语句，观察是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了很多结果中并不需要的列，对语句进行分析以及重写；</p>
</li>
<li><p>分析语句的执行计划，查看其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能地命中索引；</p>
</li>
<li><p>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行水平分表或垂直分表；</p>
</li>
</ol>
<h4 id="13-【什么是读写分离？】"><a href="#13-【什么是读写分离？】" class="headerlink" title="13. 【什么是读写分离？】"></a>13. 【什么是读写分离？】</h4><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上，一般情况下，我们都会选择一主多从的架构，也就是<strong>一台主数据库负责写，其他的从数据库负责读</strong>。主库和从库之间会进行数据同步以保证从库中数据的准确性。</p>
<h5 id="13-1-读写分离会带来什么问题？如何解决主从同步的延时问题？"><a href="#13-1-读写分离会带来什么问题？如何解决主从同步的延时问题？" class="headerlink" title="13.1 读写分离会带来什么问题？如何解决主从同步的延时问题？"></a>13.1 读写分离会带来什么问题？如何解决主从同步的延时问题？</h5><p>主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p>
<p>参考解决方案如下：</p>
<ul>
<li><strong>强制将读请求路由到主库处理。</strong>可以将那些必须获取最新数据的读请求都交给主库处理，但违背读写分离的初衷。</li>
<li><strong>延迟读取</strong>。对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行读请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</li>
<li><strong>分库</strong>。将主库拆分为几个主库降低写并发，降低主从延时影响。</li>
</ul>
<h5 id="13-2-如何实现读写分离？"><a href="#13-2-如何实现读写分离？" class="headerlink" title="13.2 如何实现读写分离？"></a>13.2 如何实现读写分离？</h5><ol>
<li>部署多个数据库，选择其中的一个作为主数据库，其他的作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理，主库自动把数据同步到从库上去。</li>
</ol>
<p>落实到项目本身的话，常用的方式有两种：</p>
<ol>
<li><p><strong>代理方式</strong></p>
<p>在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p>
</li>
<li><p><strong>组件方式</strong></p>
<p>可以通过引入第三方组件<strong>Sharding-JDBC</strong>来帮助我们实现读写请求</p>
</li>
</ol>
<h5 id="✨13-3-【了解MySQL主从复制原理吗？】"><a href="#✨13-3-【了解MySQL主从复制原理吗？】" class="headerlink" title="✨13.3 【了解MySQL主从复制原理吗？】"></a>✨13.3 【了解MySQL主从复制原理吗？】</h5><p><strong>MySQL binlog( 即二进制日志文件)</strong> 主要记录了 MySQL 数据库中数据的所有变化（数据库执行的所有 DDL 和 DML 语句），其主要目的在于复制和恢复。因此，我们<strong>根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中</strong>。</p>
<p>具体的过程如下：</p>
<ol>
<li>主库将数据库中数据的变化写入到 binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I/O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li>
<li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>
</ol>
<h4 id="14-Sql语句优化方式有哪些？"><a href="#14-Sql语句优化方式有哪些？" class="headerlink" title="14. Sql语句优化方式有哪些？"></a>14. <strong>Sql语句优化方式有哪些？</strong></h4><p><strong>优化表结构</strong></p>
<ul>
<li><strong>尽量使用数字型字段</strong>。若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>**尽可能的使用 <code>varchar</code> 代替 <code>char</code>**。可变长字段存储空间小，可以节省存储空间，但在能确定字段长度时使用<code>char</code>效率更高。</li>
<li><strong>当索引列大量重复数据时，可以把索引删除掉</strong>。比如有一列是性别，只有男、女，这样的索引是无效的。</li>
</ul>
<p><strong>优化查询</strong></p>
<ul>
<li>应尽量避免在 where 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用 <code>or</code> 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。建议使用 <code>union</code> 替换 <code>or</code></li>
<li>应尽量避免在 where 子句中对字段进行 <code>null</code> 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li><code>in</code> 和 <code>not in</code> 也要慎用，否则会导致全表扫描</li>
<li>优化嵌套查询时可以将子查询尽量替换为多表连接查询（<code>JOIN</code>）</li>
<li>任何查询都不要出现<code>select *</code>！</li>
<li>确定<code>on</code>或<code>using</code>子句上是否有索引</li>
<li>确保<code>group by</code>和<code>order by</code>只有一个表中的列确保使用索引</li>
</ul>
<p><strong>优化索引</strong></p>
<ul>
<li>尽量使用复合索引，而少使用单列索引</li>
<li>最左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列</li>
<li>对查询进行优化，要尽量避免全表扫描，<strong>首先应考虑在 <code>where</code> 及 <code>order by</code> 涉及的列上建立索引</strong></li>
</ul>
<p><strong>优化数据库结构</strong></p>
<ul>
<li>将字段很多的表垂直分解成多个表，将使用频率低的字段分离出来形成新表；</li>
<li>建立中间表。将需要通过联合查询的数据插入到中间表中，将原来的联合查询改为对中间表的查询；</li>
<li>增加冗余字段，减少表与表之间需要连接查询的情况；</li>
</ul>
<h4 id="15-MySQL-数据库作发布系统的存储，一天五万条以上的增量，-预计运维三年-怎么优化？"><a href="#15-MySQL-数据库作发布系统的存储，一天五万条以上的增量，-预计运维三年-怎么优化？" class="headerlink" title="15. MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？"></a>15. MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？</h4><ol>
<li><p>设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。 </p>
</li>
<li><p>选择合适的表字段数据类型和存储引擎，适当的添加索引。 </p>
</li>
<li><p>MySQL 库主从读写分离。 </p>
</li>
<li><p>找规律分表，减少单表中的数据量提高查询速度。</p>
</li>
<li><p>添加缓存机制，比如 memcached，redis 等。</p>
</li>
</ol>
<h4 id="16-【锁优化策略有哪些思路？】"><a href="#16-【锁优化策略有哪些思路？】" class="headerlink" title="16. 【锁优化策略有哪些思路？】"></a>16. 【锁优化策略有哪些思路？】</h4><ol>
<li><p>读写分离 </p>
</li>
<li><p>分段加锁 </p>
</li>
<li><p>减少锁持有的时间 </p>
</li>
<li><p>多个线程尽量以相同的顺序去获取资源</p>
</li>
</ol>
<p><strong>注意：</strong>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放锁次数过多，反而效率不如一次加一把大锁。</p>
<h4 id="17-【MySQL的CPU突然飙升到500-要怎么处理？】"><a href="#17-【MySQL的CPU突然飙升到500-要怎么处理？】" class="headerlink" title="17. 【MySQL的CPU突然飙升到500%要怎么处理？】"></a>17. 【MySQL的CPU突然飙升到500%要怎么处理？】</h4><ol>
<li><p>先用操作系统命令top观察是否为MySQLd占用导致的，如果不是找出占用高的进程进行相关处理；</p>
</li>
<li><p>如果是MySQLd造成的，show processlist看里面跑的session情况，找到消耗资源高的sql，explain查看执行计划，观察是否为index缺失，或者是数据量太大造成的；</p>
</li>
<li><p>如果每个sql消耗资源都不多，是突然间有大量session连进来导致CPU飙升，则需要分析连接数激增的原因再做相应调整，如限制连接数等；</p>
</li>
</ol>
<h4 id="18-MySQL为什么需要主从同步？"><a href="#18-MySQL为什么需要主从同步？" class="headerlink" title="18. MySQL为什么需要主从同步？"></a>18. MySQL为什么需要主从同步？</h4><ol>
<li>使用主从复制让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作；（主从读写分离）</li>
<li>做数据的热备；（主备）</li>
<li>架构的扩展，随着业务量增大IO访问频率过高，单机无法满足，此时做多库的存储，降低磁盘IO访问的频率，能提高单个机器的IO性能；</li>
</ol>
<h2 id="✨👏缓存Redis"><a href="#✨👏缓存Redis" class="headerlink" title="✨👏缓存Redis"></a>✨👏缓存Redis</h2><h4 id="1-【Redis-的持久化机制有哪些？各自的优缺点？】（怎么保证redis挂掉之后再重启数据可以进行恢复？）"><a href="#1-【Redis-的持久化机制有哪些？各自的优缺点？】（怎么保证redis挂掉之后再重启数据可以进行恢复？）" class="headerlink" title="1. 【Redis 的持久化机制有哪些？各自的优缺点？】（怎么保证redis挂掉之后再重启数据可以进行恢复？）"></a>1. 【Redis 的持久化机制有哪些？各自的优缺点？】（怎么保证redis挂掉之后再重启数据可以进行恢复？）</h4><ol>
<li><strong>RDB（Redis DataBase）</strong>：用数据集快照的方式（半持久化存储）<strong>在指定的时间间隔内将内存中的数据集快照写入一个临时文件（全量备份）</strong>，持久化结束后，用这个临时文件替换磁盘中上次持久化的文件，达到数据恢复。</li>
</ol>
<ul>
<li>优点：<ul>
<li>RDB文件紧凑进行全量备份，适合用于进行备份和灾难恢复。（redis中执行flushall和shutdown命令的时候会触发RDB）</li>
<li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作，但创建子线程也需要占用内存</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</li>
</ul>
</li>
<li>缺点：<ul>
<li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以<strong>在快照持久化期间修改的数据不会被保存，可能丢失数据</strong>。</li>
<li>数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>AOF（Append-only file）</strong>：指以 redis 命令请求协议的格式（完全持久化存储）保存为aof文件，<strong>将每一个收到的写命令都通过write函数追加到aof文件中（增量备份）</strong>，通俗的理解就是日志记录。</li>
</ol>
<ul>
<li>优点：<ul>
<li>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</li>
<li>AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li>
<li>AOF日志文件的命令通过易读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</li>
</ul>
</li>
<li>缺点：<ul>
<li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大，且数据集大时会比RDB启动慢；</li>
</ul>
</li>
</ul>
<p><strong>如果AOF和RDB同时存在的时候，Redis会优先使用从AOF文件来还原数据库状态，因为AOF中的数据更加完整</strong></p>
<p><strong>如何选择合适的持久化方式：</strong></p>
<ul>
<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以不开启持久化；</li>
<li>如果数据比较重要，不想再从其他地方获取，但可以承受数分钟的数据丢失比如缓存等，那么可以只使用RDB；</li>
<li>如果是用作内存数据库，要使用Redis的持久化，RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据备份，AOF可以保证数据不丢失；</li>
</ul>
<h4 id="2-【Redis-的同步机制了解么？】（待补充）"><a href="#2-【Redis-的同步机制了解么？】（待补充）" class="headerlink" title="2. 【Redis 的同步机制了解么？】（待补充）"></a>2. 【Redis 的同步机制了解么？】（待补充）</h4><p>Redis第一次同步时，主节点做一次bgsave， 并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接收完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h5 id="2-1-Redis的主从同步是如何实现的？"><a href="#2-1-Redis的主从同步是如何实现的？" class="headerlink" title="2.1 Redis的主从同步是如何实现的？"></a>2.1 Redis的主从同步是如何实现的？</h5><p>Redis使用psync命令完成主从数据同步，同步过程分为全量复制和部分复制。全量复制一般用于初次复制的场景，部分复制则用于处理因网络中断等原因造成数据丢失的场景。</p>
<h4 id="3-【用过哪些常用的Redis命令？】"><a href="#3-【用过哪些常用的Redis命令？】" class="headerlink" title="3. 【用过哪些常用的Redis命令？】"></a>3. 【用过哪些常用的Redis命令？】</h4><ul>
<li><p>启动redis服务：<strong>redis-server ../redis.conf</strong></p>
</li>
<li><p>在远程 redis 服务上登录：<strong>redis-cli -h host -p port -a password</strong></p>
</li>
<li><p>检查给定 key 是否存在：<strong>exists key</strong></p>
</li>
<li><p>为给定 key 设置过期时间，以秒计：<strong>expire key seconds</strong></p>
</li>
<li><p>移除 key 的过期时间，key 将持久保持：<strong>persist key</strong></p>
</li>
<li><p>查找所有符合给定模式( pattern)的 key：<strong>keys pattern</strong></p>
</li>
<li><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)：<strong>ttl key</strong></p>
</li>
<li><p>如果 key 已经存在并且是一个字符串，将指定的 value 追加到该 key 原来值的末尾：<strong>append key value</strong></p>
</li>
<li><p>将key中存储的数字值增/减1：<strong>incr/decr key</strong></p>
</li>
<li><p>将key中存储的数字值增减自定义值：<strong>incrby/decrby key 步长</strong></p>
</li>
<li><p>根据value选择非阻塞删除：<strong>unlink key</strong>（仅将key从keyspace元数据中删除，真正的删除会在后续异步操作）</p>
</li>
</ul>
<p><strong>与String字符串相关命令：</strong></p>
<ul>
<li><p>当且仅当所有给定的key都不存在时，同时设置一个或多个key-value对：<strong>msetnx key1 value1 key2 value2 (具有原子性，有一个失败则都会失败)</strong></p>
</li>
<li><p>设置键值的同时将 key 的过期时间设为 seconds (以秒为单位)：<strong>setnx key seconds value</strong></p>
</li>
<li><p>获取范围内的值：<strong>getrange key 起始位置 结束位置</strong></p>
</li>
<li><p>用value覆写key所存储的字符串值中的字符，从起始位置开始：<strong>setrange key 起始位置 value</strong></p>
</li>
<li><p>获取key对应旧值的同时设置为新值value：<strong>getset key value</strong></p>
</li>
</ul>
<p><strong>与List列表相关命令：</strong></p>
<ul>
<li>从左边/右边插入一个或多个值：<strong>lpush/rpush key value1 value2</strong></li>
<li>从左边/右边弹出一个值（值在键在）：<strong>lpop/rpop key</strong></li>
<li>从key1列表右边弹出值后，将该值插到key2列表左边：<strong>rpoplpush key1 key2</strong></li>
<li>按照索引下标获取范围内的元素：<strong>lrange key start stop</strong>（0左边第一个，-1右边第一个，0 -1表示获取所有）</li>
<li>按照索引下标获取指定位置的元素：<strong>lindex key index</strong></li>
<li>获取列表长度：<strong>llen key</strong></li>
<li>在value的前面/后面插入值：<strong>linsert key before/after value newValue</strong></li>
<li>从左边开始删除n个相同的value：<strong>lrem key n value</strong></li>
<li>将列表key下标为index的值替换成value：<strong>lset key index value</strong></li>
</ul>
<p><strong>与Set无序集合相关命令：</strong></p>
<ul>
<li>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略：<strong>sadd key value1 value2</strong></li>
<li>取出该集合中的所有值：<strong>smembers key</strong></li>
<li>判断集合key是否含有对应的value：<strong>sismember key value</strong>（有则为1，没有为0）</li>
<li>返回该集合的元素个数：<strong>scard key</strong></li>
<li>删除集合中的某个元素：<strong>srem key value1 value2</strong></li>
<li>随机从集合中弹出一个值：<strong>spop key</strong></li>
<li>随机从集合中取出n个值，不会从集合中删除：<strong>srandmember key n</strong></li>
<li>把集合中一个值从集合1移动到集合2：<strong>smove 集合1 集合2 value</strong></li>
<li>返回两个集合的交集元素：<strong>sinter key1 key2</strong></li>
<li>返回两个集合的并集元素：<strong>sunion key1 key2</strong></li>
<li>返回两个集合的差集元素（key1中有的而key2没有的）：<strong>sdiff key1 key2</strong></li>
</ul>
<p><strong>与Hash哈希表相关命令：</strong></p>
<ul>
<li><p>给key集合中的field键赋值为value：<strong>hset key field value</strong></p>
</li>
<li><p>从key集合的field中取出对应的value：<strong>hget key field</strong></p>
</li>
<li><p>批量设置hash值：<strong>hmset key field1 value1 field2 value2</strong></p>
</li>
<li><p>查看key中给定的field是否存在：<strong>hexists key field</strong></p>
</li>
<li><p>列出该key集合中所有的field：<strong>hkeys key</strong></p>
</li>
<li><p>列出该key结合中所有的value：<strong>hvals key</strong></p>
</li>
<li><p>为key中的域field的值加上指定增量：<strong>hincrby key field 指定增量</strong></p>
</li>
<li><p>将哈希表key中的域field的值设置为value，当且仅当域field不存在：<strong>hsetnx key field value</strong></p>
</li>
</ul>
<p><strong>与Zset有序集合相关命令：</strong></p>
<ul>
<li><p>将一个或多个member元素及其score值加入到有序集key中：<strong>zadd key score1 value1 score2 value2</strong></p>
</li>
<li><p>返回有序集合key中下标在start和stop之间的元素，并让分数一起和值返回到结果集：<strong>zrange key start stop withscores</strong></p>
</li>
<li><p>返回有序集合key中所有score值介于min和max之间的成员，有序集合成员按score</p>
</li>
<li><p>递增排列：<strong>zrangebyscore key min max</strong></p>
</li>
<li><p>递减排序：<strong>zrevrangebyscore key max min</strong></p>
</li>
<li><p>为元素的score加上增量：<strong>zincrby key 增量 value</strong></p>
</li>
<li><p>删除有序集合key中指定值的元素：<strong>zrem key value</strong></p>
</li>
<li><p>统计集合指定区间内的元素个数：<strong>zcount key min max</strong></p>
</li>
<li><p>返回该值在集合中的排名，从0开始：<strong>zrank key value</strong></p>
</li>
</ul>
<h4 id="4-【是否使用过-Redis集群，集群的工作原理是什么？】"><a href="#4-【是否使用过-Redis集群，集群的工作原理是什么？】" class="headerlink" title="4.【是否使用过 Redis集群，集群的工作原理是什么？】"></a>4.【是否使用过 Redis集群，集群的工作原理是什么？】</h4><ul>
<li>Redis Sentinal着眼于高可用和读写分离，在master宕机时会自动将slave提升为master，继续提供服务。<strong>（一主多从情况下每台Redis服务器都存储相同的数据，存在浪费内存的问题）</strong></li>
<li>Redis Cluster着眼于扩展性，在单个Redis内存不足时，使用 Cluster进行<strong>分布式存储（至少配置6个节点以上，3主3从，其中主节点提供读写操作，从节点作为备用节点不提供请求只作为故障转移使用；自动将数据进行分片，每个master节点存储不同的内容）</strong>。<ul>
<li>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0-16383个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据，当有节点宕机时，其上的数据均分到其余存活的节点上；</li>
</ul>
</li>
</ul>
<h5 id="4-1-Redis-Cluster模式的工作原理能说一下吗？"><a href="#4-1-Redis-Cluster模式的工作原理能说一下吗？" class="headerlink" title="4.1 Redis Cluster模式的工作原理能说一下吗？"></a>4.1 Redis Cluster模式的工作原理能说一下吗？</h5><ul>
<li>Redis Cluster节点间通信机制<ul>
<li><p><strong>redis cluster节点间采取gossip协议进行通信</strong>，跟集中式不同，不是将集群元数据（节点信息，故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的；优点是元数据的更新比较分散不是集中在一个地方，更新请求会陆续打到所有节点上去更新，有一定的延时降低了压力，但缺点也在于元数据更新有延时，可能导致集群的一些操作会有一些滞后；</p>
</li>
<li><p><strong>10000端口</strong></p>
<p>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他节点接收到ping之后返回pong响应；</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-Redis-cluster如何实现数据分布？"><a href="#4-Redis-cluster如何实现数据分布？" class="headerlink" title="4.Redis cluster如何实现数据分布？"></a>4.Redis cluster如何实现数据分布？</h5><ul>
<li><p><strong>redis cluster的hash slot算法</strong></p>
<p>redis cluster有固定的16384个哈希槽，对每个key计算CRC值，然后对16384取模，可以获取key对应的hash slot，redis cluster中每个master都会持有部分槽，比如有3个master那可能每个master持有5000多个hash slot，每增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot均分到其他master上；</p>
</li>
</ul>
<h5 id="4-3-Redis-cluster方案什么情况下会导致整个集群不可用？"><a href="#4-3-Redis-cluster方案什么情况下会导致整个集群不可用？" class="headerlink" title="4.3 Redis cluster方案什么情况下会导致整个集群不可用？"></a>4.3 Redis cluster方案什么情况下会导致整个集群不可用？</h5><p>有 A，B，C 三个节点的集群，在没有复制模型的情况下如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用，但是会把失败节点上的槽均匀分布到其他节点上；</p>
<h4 id="5-【Redis-sentinel的工作原理？】"><a href="#5-【Redis-sentinel的工作原理？】" class="headerlink" title="5. 【Redis sentinel的工作原理？】"></a>5. 【Redis sentinel的工作原理？】</h4><ol>
<li>每个sentinel以每秒钟1次的频率向他所知的master、slave以及其他sentinel实例发送一个ping命令；</li>
<li>如果一个实例最后一次有效回复ping命令的时间超过down-after-milliseconds选项所指定的值，则该实例会被当前sentinel标记为主观下线；</li>
<li>如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒1次的频率确认master的确进入了主观下线状态；</li>
<li>当大于配置文件指定值数量的sentinel在指定的时间范围内确认master的确进入了主观下线状态，则master会被标记为客观下线；</li>
<li>当master被sentinel标记为客观下线，sentinel向下线的master的所有slave发送info命令的频率从10秒1次改为每秒1次；</li>
<li>若没有足够数量的sentinel统一认为master已经下线，master的客观下线状态就会变回主观下线；若master重新向sentinel的ping命令返回有效回复，master的主观下线状态就会被移除；</li>
<li>sentinel节点会与其他sentinel节点进行沟通，若都允许了主备切换，则投票选举一个sentinel节点进行主备切换操作，在slave节点中选举一个作为新的master节点，其他slave节点挂载到新的master节点上并自动复制新的master节点的数据；<ul>
<li><strong>从slave中选举一个新的master的标准：</strong><ul>
<li>与master断开连接的时长：若断开连接的时长已经超过down-after-milliseconds的10倍+master宕机的时长，则认为该slave不适合选举为master；</li>
<li>slave优先级：slave priority越低，优先级越高；</li>
<li>复制offset：slave复制了越多数据，其offset越靠后，优先级越高；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="6-【怎么理解-Redis-事务？】"><a href="#6-【怎么理解-Redis-事务？】" class="headerlink" title="6. 【怎么理解 Redis 事务？】"></a>6. 【怎么理解 Redis 事务？】</h4><ul>
<li>Redis事务并不是传统意义上理解的事务，Redis事务的执行并不是原子性的，可以理解为<strong>是一个打包的批量执行脚本但批量指令并非原子化的操作</strong>，中间某条指令的失败不会导致前面已执行指令的回滚，也不会造成后续执行不再执行；</li>
<li>Redis事务中所有命令都会序列化、按顺序地执行，事务在执行的过程中不会被其他客户端发送来的命令请求所打断；<strong>（总是带有隔离性）</strong></li>
<li>在事务开启之前，如果客户端与服务器之间网络断开，则其后所有待执行的语句都不会被服务器执行，如果网络中断发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行；</li>
</ul>
<p><strong>事务相关的命令：</strong>MULTI、EXEC、DISCARD、WATCH</p>
<ul>
<li>MULTI用于开启一个事务，MULTI执行后客户端向服务器发送任意多条命令，这些命令不会立即被执行而是被放到一个队列中，当EXEC命令被调用时所有队列中的命令才会被执行；</li>
<li>EXEC用于执行所有事务块内命令，返回事务块内所有命令的返回值，<strong>截至此处一个事务已经结束</strong>；</li>
<li>DISCARD用于取消事务；</li>
<li>WATCH用于监视一个或多个key，一旦有一个键被修改或删除，之后的事务就不会执行，监控一直持续到EXEC命令；UNWATCH用于取消WATCH对所有key的监控；</li>
</ul>
<h4 id="7-【MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点数据？】"><a href="#7-【MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点数据？】" class="headerlink" title="7. 【MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？】"></a>7. 【MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？】</h4><p>Redis内存数据集大小上升到一定大小的时候，就实行数据淘汰策略。 </p>
<p><strong>Redis 提供 6 种回收策略（淘汰策略）：</strong></p>
<ul>
<li> <strong>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</strong></li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li>
<li><strong>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</strong> </li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ul>
<h4 id="8-Redis的线程模型是什么？为啥单线程还能有很高的效率？"><a href="#8-Redis的线程模型是什么？为啥单线程还能有很高的效率？" class="headerlink" title="8. Redis的线程模型是什么？为啥单线程还能有很高的效率？"></a>8. Redis的线程模型是什么？为啥单线程还能有很高的效率？</h4><h5 id="8-1-【Redis单线程模型】"><a href="#8-1-【Redis单线程模型】" class="headerlink" title="8.1 【Redis单线程模型】"></a>8.1 【Redis单线程模型】</h5><p><strong>Redis 内部使用文件事件处理器 file event handler是单线程的，所以 Redis 才叫做单线程的模型</strong>。文件事件处理器的结构包含4个部分：①多个socket；②IO多路复用程序；③文件事件分派器；④事件处理器，它采用 <strong>IO 多路复用机制</strong>同时监听多个 socket，将产生事件的 socket 压入内存队列中，文件事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的工作流程如下：</p>
<ul>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
<li>文件事件处理器是单线程模式运行的，但是通过IO多路复用机制监听多个socket，并根据socket目前执行的任务来为套接字关联不同的事件处理器，可以实现高性能的网络通信模型。又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。</li>
</ul>
<h5 id="8-2-为什么Redis是单线程模型效率也能这么高？"><a href="#8-2-为什么Redis是单线程模型效率也能这么高？" class="headerlink" title="8.2 为什么Redis是单线程模型效率也能这么高？"></a>8.2 为什么Redis是单线程模型效率也能这么高？</h5><p>1）纯内存操作</p>
<p>2）核心是基于非阻塞的IO多路复用机制</p>
<p>3）单线程反而避免了多线程的上下文频繁切换问题，预防了多线程可能产生的竞争问题</p>
<h5 id="8-3-Redis-6-0前为什么选择单线程？"><a href="#8-3-Redis-6-0前为什么选择单线程？" class="headerlink" title="8.3 Redis 6.0前为什么选择单线程？"></a>8.3 Redis 6.0前为什么选择单线程？</h5><ol>
<li>单线程编程简单可维护，不需要像多线程所有的底层数据结构都必须实现成线程安全；</li>
<li>单线程可以规避进程内频繁的线程切换开销</li>
<li>避免同步机制的开销</li>
</ol>
<h5 id="8-4-Redis-6-0后为什么要引入多线程呢？"><a href="#8-4-Redis-6-0后为什么要引入多线程呢？" class="headerlink" title="8.4 Redis 6.0后为什么要引入多线程呢？"></a>8.4 Redis 6.0后为什么要引入多线程呢？</h5><ol>
<li>可以充分利用服务器CPU资源，目前单线程只能利用一个核去处理任务</li>
<li>多线程任务可以分摊Reids同步IO读写负荷</li>
</ol>
<h5 id="8-5-Redis开启多线程后是否会存在线程并发安全问题？"><a href="#8-5-Redis开启多线程后是否会存在线程并发安全问题？" class="headerlink" title="8.5 Redis开启多线程后是否会存在线程并发安全问题？"></a>8.5 Redis开启多线程后是否会存在线程并发安全问题？</h5><p>Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍是单线程顺序执行，所以并不需要考虑线程并发安全问题；</p>
<h4 id="9-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#9-假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="9. 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>9. 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的，如果将它们全部找出来？</h4><p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<h5 id="9-1-如果这个-redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？"><a href="#9-1-如果这个-redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？" class="headerlink" title="9.1 如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？"></a>9.1 如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</h5><p>由于redis 是单线程的，使用keys 指令会导致线程阻塞一段时间，线上服务会停顿直到指令执行完毕后服务才能恢复。这个时候可以使用 scan 指令，<strong>scan 指令可以无阻塞的提取出指定模式的 key 列表</strong>，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令要长。</p>
<h4 id="10-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#10-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="10. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>10. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h4><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些，避免出现缓存雪崩。</p>
<h4 id="11-【使用过-Redis-做消息队列么，你是怎么用的？】"><a href="#11-【使用过-Redis-做消息队列么，你是怎么用的？】" class="headerlink" title="11. 【使用过 Redis 做消息队列么，你是怎么用的？】"></a>11. 【使用过 Redis 做消息队列么，你是怎么用的？】</h4><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当sleep一会再重试。</p>
<h5 id="11-1-可不可以不用-sleep-呢？"><a href="#11-1-可不可以不用-sleep-呢？" class="headerlink" title="11.1 可不可以不用 sleep 呢？"></a>11.1 可不可以不用 sleep 呢？</h5><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到有消息到来</p>
<h5 id="11-2-能不能生产一次消费多次呢？"><a href="#11-2-能不能生产一次消费多次呢？" class="headerlink" title="11.2 能不能生产一次消费多次呢？"></a>11.2 能不能生产一次消费多次呢？</h5><p>使用 pub/sub 主题订阅模式，可以实现 1:N 的消息队列。</p>
<h5 id="11-3-pub-sub-有什么缺点？"><a href="#11-3-pub-sub-有什么缺点？" class="headerlink" title="11.3 pub/sub 有什么缺点？"></a>11.3 pub/sub 有什么缺点？</h5><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<h5 id="11-4-Redis-如何实现延时队列？"><a href="#11-4-Redis-如何实现延时队列？" class="headerlink" title="11.4 Redis 如何实现延时队列？"></a>11.4 Redis 如何实现延时队列？</h5><p>使用sorted set，拿时间戳作为score，消息内容作为 key ，生产者调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p>
<h4 id="12-【了解Redis过期键的删除策略吗？（即Redis的过期策略）】"><a href="#12-【了解Redis过期键的删除策略吗？（即Redis的过期策略）】" class="headerlink" title="12. 【了解Redis过期键的删除策略吗？（即Redis的过期策略）】"></a>12. 【了解Redis过期键的删除策略吗？（即Redis的过期策略）】</h4><ol>
<li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器 timer，让定时器在键的过期时间来临时，立即执行对键的删除操作。 </li>
<li><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期，就返回该键。（<strong>即只会在取出 key 的时候才对数据进行过期检查</strong>）</li>
<li><strong>定期删除</strong>：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。（<strong>即每隔一段时间随机抽取一批 key 执行删除过期 key 操作</strong>）</li>
</ol>
<h5 id="12-1-如何设置Redis的过期删除策略比较合理？"><a href="#12-1-如何设置Redis的过期删除策略比较合理？" class="headerlink" title="12.1 如何设置Redis的过期删除策略比较合理？"></a>12.1 如何设置Redis的过期删除策略比较合理？</h5><p><strong>【定期删除+惰性删除】</strong></p>
<ul>
<li>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。但是<strong>定期删除可能会导致很多过期key到了时间并没有被删除掉，所以结合惰性删除</strong>，并不是到时间就删除key，而是在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间且过期了此时就会删除；</li>
</ul>
<h4 id="✨14-缓存穿透、缓存击穿、缓存雪崩？"><a href="#✨14-缓存穿透、缓存击穿、缓存雪崩？" class="headerlink" title="✨14. 缓存穿透、缓存击穿、缓存雪崩？"></a>✨14. 缓存穿透、缓存击穿、缓存雪崩？</h4><ul>
<li><strong>缓存穿透</strong>：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。<ul>
<li>解决办法：<ul>
<li><strong>缓存无效key并设置较短的过期时间，value统一设置成null值</strong></li>
<li>✨<strong>使用布隆过滤器</strong>，在缓存之前再加一个布隆过滤器，将redis中的所有key都存储在布隆过滤器中，在查询redis前先去布隆过滤器查询key是否存在，如果不存在就直接返回不让其访问数据库</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：有一些被大量访问的数据（热点数据缓存）在某一时刻失效（一般是缓存时间到期），导致对应的请求直接落到了数据库上。<strong>（缓存击穿其实可以算缓存雪崩的特例，缓存击穿是部分热点key过期，缓存雪崩是大量key集中过期）</strong><ul>
<li>解决办法：<ul>
<li><strong>设置互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。（可以使用 Redis 分布式锁）</li>
<li><strong>预先设置热门数据到redis，加大热门数据key的过期时长或者设置为永不过期</strong></li>
<li><strong>接口限流与熔断，降级</strong>。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：缓存在同一时间大面积失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。<ul>
<li>解决办法：<ul>
<li><p>由于过期时间集中导致：<strong>设置不同的过期时间，比如为每个key的过期时间再加个随机值</strong>。</p>
</li>
<li><p>由于缓存宕机导致：（严格来说不属于缓存雪崩）</p>
<p>事前：<strong>保证redis高可用</strong>（主从+哨兵，redis cluster）避免全盘崩溃</p>
<p>事中：<strong>设置多级失效时间不同的缓存</strong>（本地ehcache缓存） + <strong>使用熔断机制，限流降级</strong></p>
<p>事后：<strong>开启redis持久化</strong>，快速恢复缓存数据</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="15-【怎么保证Redis是高并发和高可用？】"><a href="#15-【怎么保证Redis是高并发和高可用？】" class="headerlink" title="15. 【怎么保证Redis是高并发和高可用？】"></a>15. 【怎么保证Redis是高并发和高可用？】</h4><h5 id="15-1-redis如何通过读写分离来承载读请求QPS超过10万-？"><a href="#15-1-redis如何通过读写分离来承载读请求QPS超过10万-？" class="headerlink" title="15.1 redis如何通过读写分离来承载读请求QPS超过10万+？"></a>15.1 redis如何通过读写分离来承载读请求QPS超过10万+？</h5><p><strong>高并发架构做成读写分离的主从架构，一主多从</strong>，master节点负责写，并且将数据同步复制到其他slave节点，从节点负责读，所有的读请求全部走从节点，便于进行水平扩容；</p>
<h5 id="15-2-master持久化对于主从架构的安全保障的意义"><a href="#15-2-master持久化对于主从架构的安全保障的意义" class="headerlink" title="15.2 master持久化对于主从架构的安全保障的意义"></a>15.2 master持久化对于主从架构的安全保障的意义</h5><p><strong>如果采用了主从架构，那么建议必须开启master node的持久化！</strong></p>
<ul>
<li>不建议用slave node作为master node的数据热备，因为如果RDB和AOF都关闭了，数据则会全部都在内存中，master宕机后重启是没有本地数据可以恢复的，然后就会直接认为自己的数据是空的，master就会将空的数据集同步到slave上去，所有slave的数据全部清空，导致100%数据丢失的故障；</li>
</ul>
<h5 id="15-3-redis主从复制原理和断点续传"><a href="#15-3-redis主从复制原理和断点续传" class="headerlink" title="15.3 redis主从复制原理和断点续传"></a>15.3 redis主从复制原理和断点续传</h5><ul>
<li><p><strong>主从复制机制原理</strong></p>
<ul>
<li><p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</p>
</li>
<li><p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据（增量复制）; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization（全量复制）</p>
</li>
<li><p>开始full resynchronization的时候，<strong>master会启动一个后台线程，开始在内存中生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。最后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据，至此就完成了主从复制。</strong></p>
</li>
</ul>
<ul>
<li>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</li>
</ul>
</li>
<li><p><strong>断点续传（适用于网络故障断开连接自动重连）</strong></p>
<p>master node会在内存中创建一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制，但是如果没有找到对应的offset，那么就会执行一次full resynchronization；</p>
</li>
<li><p><strong>无磁盘化复制</strong></p>
<p>master会在内存中直接创建RDB然后发送给slave，不会在自己本地磁盘落盘了；</p>
</li>
</ul>
<h5 id="15-4-redis主从架构下如何才能做到99-99-的高可用性？"><a href="#15-4-redis主从架构下如何才能做到99-99-的高可用性？" class="headerlink" title="15.4 redis主从架构下如何才能做到99.99%的高可用性？"></a>15.4 redis主从架构下如何才能做到99.99%的高可用性？</h5><p><strong>高可用架构采用主备切换的主从架构</strong>，在master节点故障宕机时，哨兵自动检测并且将某个slave节点自动切换为master节点</p>
<ul>
<li><p>哨兵 + redis主从的架构，是<strong>不会保证数据零丢失的，只能保证redis集群的高可用性</strong></p>
</li>
<li><p><strong>redis哨兵主备切换的数据丢失的情况：异步复制、集群脑裂</strong></p>
<ul>
<li><p>异步复制导致数据丢失</p>
<p>因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，此时master就宕机了，这些部分数据就丢失了</p>
</li>
<li><p>集群脑裂导致数据丢失</p>
<p>master所在机器突然脱离了正常的网络，跟其他slave机器不能正常连接，但是实际上master还运行着，但此时哨兵可能就会认为master宕机了，然后开启选举将其他slave切换成了新的master，此时<strong>集群里就会有两个有相同数据的master且作用一致，也就是所谓的脑裂</strong>，虽然某个slave被切换成了master，但是可能客户端还没来得及切换到新的master，还继续向旧master写数据，当旧master再次恢复的时候会被作为一个slave挂到新的master上去，自己的数据会清空而重新从新的master处复制数据，导致故障后客户端继续写向旧master的数据就丢失了</p>
</li>
</ul>
</li>
<li><p><strong>解决异步复制和脑裂导致的数据丢失问题</strong></p>
<p>min-slaves-to-write 1<br>min-slaves-max-lag 10</p>
<p>意思是要求至少要有1个slave，数据复制和同步的延迟不能超过10秒，如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候master就不会再接收任何请求了</p>
<p>通过上面两个配置可以减少异步复制和脑裂导致的数据丢失影响</p>
<p>（1）减少异步复制的数据丢失</p>
<p>有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内；</p>
<p>（2）减少脑裂的数据丢失</p>
<p>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求，这样脑裂后的旧master就不会接受client的新数据，最多就丢失这10秒的数据；</p>
</li>
</ul>
<h5 id="15-5-由于主从延迟导致读取到过期数据怎样处理？（待补充）"><a href="#15-5-由于主从延迟导致读取到过期数据怎样处理？（待补充）" class="headerlink" title="15.5 由于主从延迟导致读取到过期数据怎样处理？（待补充）"></a>15.5 由于主从延迟导致读取到过期数据怎样处理？（待补充）</h5><ul>
<li><strong>通过scan命令扫库</strong>：当Redis中的key被scan时相当于访问了该key，同时也会做过期检测，使用Redis惰性删除的策略；</li>
</ul>
<h4 id="16-【说一下Redis的缓存淘汰策略】"><a href="#16-【说一下Redis的缓存淘汰策略】" class="headerlink" title="16. 【说一下Redis的缓存淘汰策略】"></a>16. 【说一下Redis的缓存淘汰策略】</h4><p>结合Redis的12. 过期删除策略，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在<strong>定期删除+惰性删除</strong>漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了，当写入数据将导致超出maxmemory限制时，Redis会采用maxmemory-policy所指定的策略进行数据淘汰，淘汰策略有如下8种：</p>
<table>
<thead>
<tr>
<th align="left"><strong>策略</strong></th>
<th align="left"><strong>描述</strong></th>
<th align="left"><strong>版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">noeviction</td>
<td align="left">直接返回错误；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-ttl</td>
<td align="left">从设置了过期时间的键中，选择过期时间最小的键，进行淘汰；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-random</td>
<td align="left">从设置了过期时间的键中，随机选择键，进行淘汰；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-lru</td>
<td align="left">从设置了过期时间的键中，使用LRU算法选择键，进行淘汰；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile-lfu</td>
<td align="left">从设置了过期时间的键中，使用LFU算法选择键，进行淘汰；</td>
<td align="left">4.0</td>
</tr>
<tr>
<td align="left">allleys-random</td>
<td align="left">从所有的键中，随机选择键，进行淘汰；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">从所有的键中，使用LRU算法选择键，进行淘汰；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">allkeys-lfu</td>
<td align="left">从所有的键中，使用LFU算法选择键，进行淘汰；</td>
<td align="left">4.0</td>
</tr>
</tbody></table>
<ul>
<li>LRU（Least Recently Used）是<strong>按照最近最少使用原则来筛选数据</strong>，即最不常用的数据会被筛选出来；</li>
<li>LFU（Least Frequently Used）是Redis4新增的淘汰策略，它<strong>根据key的最近访问频率来筛选数据</strong>进行淘汰；</li>
</ul>
<h4 id="17-【如何保证缓存和数据库的数据双写一致性？】"><a href="#17-【如何保证缓存和数据库的数据双写一致性？】" class="headerlink" title="17. 【如何保证缓存和数据库的数据双写一致性？】"></a>17. 【如何保证缓存和数据库的数据双写一致性？】</h4><ul>
<li><p>先更新数据库，再删除缓存，如果失败则采用cache更新重试机制<strong>（普遍使用方式）</strong></p>
<p><strong>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单的解决方案：</strong></p>
<ol>
<li><strong>增加 cache 更新重试机制</strong>： 如果 cache 服务当前不可用导致缓存删除失败，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入消息队列中，等缓存服务可用之后，再从队列中获取需要删除的key，将缓存中对应的 key 删除即可。</li>
</ol>
</li>
<li><p><strong>延时双删策略</strong>：在写库前后都进行删除缓存操作，并且设置合理的超时时间，基本步骤是<strong>先删除缓存再写数据库，在休眠一段时间后再次删除缓存，目的是确保读请求结束，写请求可以删除读请求可能造成的缓存脏数据。</strong></p>
</li>
</ul>
<p><strong>补充说明：</strong>无论是先写数据库再删除缓存，还是先删除缓存再写入数据库，都必定会出现数据一致性的问题</p>
<ol>
<li><p>先删除了缓存，但是因为其他某些原因还没来得及写入数据库，另外一个线程就来读取，发现缓存为空，则去数据库读取到之前的数据并写入缓存，此时缓存中为脏数据。</p>
</li>
<li><p>先写入了数据库，但在缓存被删除前，因为其他原因被中断了没有成功删除掉缓存，也会出现数据不一致的情况。</p>
</li>
</ol>
<h5 id="17-1-三种常用的缓存读写策略（待补充）"><a href="#17-1-三种常用的缓存读写策略（待补充）" class="headerlink" title="17.1 三种常用的缓存读写策略（待补充）"></a>17.1 三种常用的缓存读写策略（待补充）</h5><ul>
<li><p>Cache Aside Pattern（旁路缓存模式）<strong>（常用）</strong></p>
<ul>
<li><p>对于写操作先<strong>直接删除cache</strong>，再更新DB。</p>
</li>
<li><p>对于读操作从 cache 中读取数据，读取到就直接返回，cache中读取不到的话就从 DB 中读取数据返回再把数据放到 cache 中。</p>
</li>
<li><p><strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ul>
</li>
<li><p>Read/Write Through Pattern（读写穿透）<strong>（不常用）</strong></p>
<ul>
<li>对于写操作先查 cache，cache 中不存在直接更新 DB。cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
<li>对于读操作从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
</li>
<li><p> Write Behind Pattern（异步缓存写入）<strong>（不常用）</strong></p>
</li>
<li><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。但是，两者又有很大不同：Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</p>
</li>
</ul>
<h4 id="✨18-【Redis都有哪些数据类型？分别在哪些场景下使用比较合适？-在项目中用到哪些Redis的数据结构？-】"><a href="#✨18-【Redis都有哪些数据类型？分别在哪些场景下使用比较合适？-在项目中用到哪些Redis的数据结构？-】" class="headerlink" title="✨18. 【Redis都有哪些数据类型？分别在哪些场景下使用比较合适？(在项目中用到哪些Redis的数据结构？)】"></a>✨18. 【Redis都有哪些数据类型？分别在哪些场景下使用比较合适？(在项目中用到哪些Redis的数据结构？)】</h4><ol>
<li><strong>string</strong><ul>
<li>最常用、简单的key-value类型，普通的key/ value 存储都可以归为此类。</li>
<li><strong>使用场景：</strong>常规key-value缓存应用。</li>
<li><strong>实现方式：</strong>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</li>
</ul>
</li>
<li><strong>hash</strong><ul>
<li>是一个键值(key =&gt; value)对集合。<strong>hash是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象</strong>，并且可以像数据库中update一个属性一样只修改某一项属性值。</li>
<li><strong>使用场景：</strong>存放结构化数据，比如用户信息。比如Key是用户ID, Value是一个Map，这个Map的field是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key（Redis里称内部Map的key为field）， 也就是通过key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</li>
<li><strong>实现方式：</strong>Hash对应Value内部实际就是一个HashMap，当这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储而不会采用真正的HashMap结构（zipmap），当成员数量增大到一定值时会自动转成真正的HashMap。</li>
</ul>
</li>
<li><strong>list</strong><ul>
<li>是一个有序可重复的集合，遵循FIFO原则，底层依赖双向链表实现，支持双向的Pop/Push，一般从左端Push，右端Pop。</li>
<li><strong>使用场景：</strong><ul>
<li>各种列表，比如twitter的关注列表、粉丝列表等，最新消息排行、最新回复、每篇文章的评论等也可以用Redis的list结构来实现。</li>
<li>用作消息队列，可以利用List的push操作将任务存在List中，然后工作线程再用pop操作将任务取出执行。</li>
</ul>
</li>
<li><strong>实现方式：</strong>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销</li>
</ul>
</li>
<li><strong>set</strong><ul>
<li>是一种无序天然去重的集合，即key-set，此外提供了交集、并集等一系列直接操作集合的方法</li>
<li><strong>使用场景：</strong><ul>
<li>某些需要去重的列表，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</li>
<li>可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li>
</ul>
</li>
</ul>
</li>
<li><strong>zset / sorted set</strong><ul>
<li>有序集合，相比set，元素放入集合时还要提供该元素的分数score，可根据分数自动排序。</li>
<li><strong>使用场景：</strong><ul>
<li>存放一个有序的并且不重复的集合列表</li>
<li>可以做带权重的队列或者排行榜相关的</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>三种特殊的数据类型：</p>
<ol start="6">
<li><strong>Bitmap</strong>：以位为单位的数组，数组中的每个单元只能存0或1，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等就可以使用Bitmap；</li>
<li><strong>Hyperloglog</strong>：用于统计基数，在输入元素的数量或体积即使很大时计算基数所需的空间总是固定的并且很小，适用场景有：统计网页的不重复访客，一个人访问网站多次但还是只计算为1次；</li>
<li><strong>Geospatial</strong>：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等；</li>
</ol>
<h5 id="✨18-1-String和Hash类型的区别？"><a href="#✨18-1-String和Hash类型的区别？" class="headerlink" title="✨18.1 String和Hash类型的区别？"></a>✨18.1 String和Hash类型的区别？</h5><p><strong>适合用 String 存储的情况：</strong></p>
<ul>
<li>存储对象信息时，可以用String存储也可以用Hash存储，每次需要访问该对象大量的字段时使用String<strong>（大多数存储对象的情况）</strong></li>
<li>存储的结构具有多层嵌套的对象的时候，占用的空间比Hash小</li>
</ul>
<p><strong>适合用 Hash 存储的情况：</strong></p>
<ul>
<li>当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象中少量的字段时，可以考虑使用Hash</li>
</ul>
<h4 id="19-Redis并发竞争问题如何解决？"><a href="#19-Redis并发竞争问题如何解决？" class="headerlink" title="19. Redis并发竞争问题如何解决？"></a>19. Redis并发竞争问题如何解决？</h4><p>使用Redis分布式锁，确保在同一时间只能有一个系统实例在操作某个key，其他实例不允许读和写；每次要写之前，先判断当前这个value的时间戳是否比缓存中的value的时间戳更新，如果更新那么可以写，如果更旧则不能用旧的数据覆盖新的数据；</p>
<h4 id="20-【如何利用Redis实现分布式Session？】"><a href="#20-【如何利用Redis实现分布式Session？】" class="headerlink" title="20. 【如何利用Redis实现分布式Session？】"></a>20. 【如何利用Redis实现分布式Session？】</h4><p><strong>Spring Session+Redis</strong></p>
<p>给spring session配置基于redis来存储session数据，然后配置一个spring session的过滤器，session相关操作都会交给spring session来管理，直接基于spring sesion从redis中获取数据了。</p>
<h4 id="✨21-1-如何利用Redis实现分布式锁？"><a href="#✨21-1-如何利用Redis实现分布式锁？" class="headerlink" title="✨21.1 如何利用Redis实现分布式锁？"></a>✨21.1 如何利用Redis实现分布式锁？</h4><p><strong>使用setnx、del和expire实现分布式锁</strong>会存在以下问题：</p>
<ol>
<li><p>setnx和expire非原子性</p>
<p>先拿 <code>setnx key value</code>来争抢锁，抢到之后，再用 <code>expire key 过期时间</code>给锁加一个超时过期时间防止锁忘记释放。但这两个单独命令如果在 setnx 之后执行 expire 之前进程意外挂掉，此时这把锁就没有设置过期时间，别的线程就再也无法获得该锁了；</p>
<p><strong>加锁同时设置过期时间实现原子操作：set key value nx ex 过期时间</strong>（防止死锁）</p>
<p><strong>释放锁：delete key</strong></p>
</li>
<li><p>锁误解除</p>
<p>如果线程A成功获取到了锁并设置了过期时间30s，但线程A的执行时间超过了30s，锁过期自动释放，此时线程B获取到了锁；随后A执行完成并释放锁，但此时线程B加锁还没有执行完成，线程A实际释放的是线程B加的锁；</p>
<p><strong>在加锁的时候生成一个uuid作为value，充当唯一标识，在解锁之前先验证key对应的value是不是该线程的uuid；或者使用Lua脚本做验证标识和解锁操作</strong></p>
</li>
<li><p>超时解锁导致并发</p>
<p>如果线程A成功获取到了锁并设置了过期时间30s，但线程A的执行时间超过了30s，锁过期自动释放，此时线程B获取到了锁，相当于线程A和线程B在并发执行；</p>
<p><strong>将过期时间设置足够长确保代码逻辑在所释放之前能够执行完成；或为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间</strong></p>
</li>
<li><p>不可重入</p>
<p><strong>Redis可通过对锁进行重入计数，加锁时加1，解锁时减1，当计数归0时释放锁</strong></p>
</li>
</ol>
<h4 id="21-2-Redis做分布式锁死锁的情况，如何解决？"><a href="#21-2-Redis做分布式锁死锁的情况，如何解决？" class="headerlink" title="21.2 Redis做分布式锁死锁的情况，如何解决？"></a>21.2 Redis做分布式锁死锁的情况，如何解决？</h4><ol>
<li>加锁没有释放锁，此时需要加释放锁的操作比如delete key</li>
<li>加锁后程序还没有执行释放锁就挂了，此时需要用到key的过期机制</li>
</ol>
<h4 id="22-Redis-是如何判断数据是否过期的呢？"><a href="#22-Redis-是如何判断数据是否过期的呢？" class="headerlink" title="22. Redis 是如何判断数据是否过期的呢？"></a>22. Redis 是如何判断数据是否过期的呢？</h4><p>Redis 通过一个叫做过期字典的hash表来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key，过期字典的值是一个 long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间；</p>
<h4 id="23-【RedLock算法的原理】（待补充）"><a href="#23-【RedLock算法的原理】（待补充）" class="headerlink" title="23. 【RedLock算法的原理】（待补充）"></a>23. 【RedLock算法的原理】（待补充）</h4><p>Redisson完成了对RedLock算法的封装</p>
<h4 id="24-什么是缓存预热和缓存降级？"><a href="#24-什么是缓存预热和缓存降级？" class="headerlink" title="24. 什么是缓存预热和缓存降级？"></a>24. 什么是缓存预热和缓存降级？</h4><ul>
<li><p><strong>缓存预热</strong>：指系统上线后提前将相关的缓存数据加载到缓存系统，避免在用户请求的时候先查询数据库再将数据缓存的问题，用户直接查询事先被预热的缓存数据；（<strong>优先保证热点数据提前加载到缓存</strong>）</p>
</li>
<li><p><strong>缓存降级</strong>：指缓存失效或缓存服务器挂掉的情况下不去访问数据库，直接返回默认数据或访问服务的内存数据；</p>
</li>
</ul>
<h4 id="25-Redis如何做内存优化？"><a href="#25-Redis如何做内存优化？" class="headerlink" title="25. Redis如何做内存优化？"></a>25. Redis如何做内存优化？</h4><ul>
<li><strong>控制key的数量</strong>。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量可以节省大量内存</li>
<li><strong>缩减键值对象</strong>。降低Redis内存使用最直接的方式就是缩减key和value的长度<ul>
<li>key长度：在设计键时，在能完整描述业务情况下键值越短越好；</li>
<li>value长度：把业务对象序列化成二进制数组放入Reids，并且在业务上精简业务对象去掉不必要的属性避免存储无效数据；</li>
</ul>
</li>
</ul>
<h4 id="26-如果现在有个超高并发的系统，用Redis来抗住大部分读请求，请问要怎么设计？"><a href="#26-如果现在有个超高并发的系统，用Redis来抗住大部分读请求，请问要怎么设计？" class="headerlink" title="26. 如果现在有个超高并发的系统，用Redis来抗住大部分读请求，请问要怎么设计？"></a>26. 如果现在有个超高并发的系统，用Redis来抗住大部分读请求，请问要怎么设计？</h4><ul>
<li><strong>如果是读高并发的情况</strong>，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，可承载每秒几万，使用一主多从+哨兵集群的缓存架构可以来承载每秒10w+的读并发，采用主从复制读写分离的模式，主库负责写，多个从库负责读，更好地支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例；</li>
<li><strong>如果是写并发的情况</strong>，需要缓存1T+的数据，一主多从架构就受单主内存容量瓶颈制约不能解决问题，需要选择Redis cluster模式，采用多主多从架构，每个主节点存一部分数据，假设一个master存32G，只需要n*32G&gt;=1T即可，n个master节点就可以支持海量数据的存储了；</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h4 id="1-【什么是CAP定理？】"><a href="#1-【什么是CAP定理？】" class="headerlink" title="1. 【什么是CAP定理？】"></a>1. 【什么是CAP定理？】</h4><p>CAP定理指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）</p>
<ul>
<li><p><strong>Consistency (一致性)：</strong></p>
<p>“all nodes see the same data at the same time”，即<strong>更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致</strong>，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p>
</li>
</ul>
<ul>
<li><p><strong>Availability (可用性)：</strong></p>
<p>可用性指“Reads and writes always succeed”，即<strong>非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）</strong>。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p>
</li>
<li><p><strong>Partition Tolerance (分区容错性)：</strong></p>
<p>即<strong>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或者可用性的服务</strong>。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p>
</li>
</ul>
<p>需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证</strong>（CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C）</p>
<h4 id="2-如何实现分布式存储？"><a href="#2-如何实现分布式存储？" class="headerlink" title="2. 如何实现分布式存储？"></a>2. 如何实现分布式存储？</h4><p>实现这种存储架构主要有三种通用的形式：</p>
<ul>
<li><p><strong>中间控制节点架构（HDFS）</strong></p>
<p>在该系统的整个架构中将服务器分为两种类型，一种名为namenode，这种类型的节点负责管理管理数据（元数据），另外一种名为datanode，这种类型的服务器负责管理实际数据；</p>
<p>如果客户端需要从某个文件读取数据，首先从namenode获取该文件的位置（具体存放在哪个datanode），然后从该位置获取具体的数据。在该架构中namenode通常是主备部署，而datanode则是由大量节点构成一个集群。由于元数据的访问频度和访问量相对数据都要小很多，因此namenode通常不会成为性能瓶颈，而datanode集群可以分散客户端的请求。因此，通过这种分布式存储架构可以通过横向扩展datanode的数量来增加承载能力，也即实现了动态横向扩展的能力。</p>
</li>
<li><p><strong>完全无中心架构—计算模式（Ceph）</strong></p>
<p>该架构中与HDFS不同的地方在于该架构中没有中心节点namenode。客户端是通过一个设备映射关系计算出来其写入数据的位置，这样客户端可以直接与存储节点通信，从而避免中心节点可能存在的性能瓶颈；</p>
<p>在Ceph存储系统架构中核心组件有Mon服务、OSD服务和MDS服务等。对于块存储类型只需要Mon服务、OSD服务和客户端的软件即可。其中Mon服务用于维护存储系统的硬件逻辑关系，主要是服务器和硬盘等在线信息。Mon服务通过集群的方式保证其服务的可用性。OSD服务用于实现对磁盘的管理，实现真正的数据读写，通常一个磁盘对应一个OSD服务。 客户端访问存储的大致流程是，客户端在启动后会首先从Mon服务拉取存储资源布局信息，然后根据该布局信息和写入数据的名称等信息计算出期望数据的位置（包含具体的物理服务器信息和磁盘信息），然后该位置信息直接通信，读取或者写入数据。</p>
</li>
<li><p><strong>完全无中心架构—一致性哈希（Swift）</strong></p>
<p>一致性哈希的方式就是将设备做成一个哈希环，然后根据数据名称计算出的哈希值映射到哈希环的某个位置，从而实现数据的定位；</p>
<p>为了保证数据分配的均匀性及出现设备故障时数据迁移的均匀性，一致性哈希将磁盘划分为比较多的虚拟分区，每个虚拟分区是哈希环上的一个节点。整个环是一个从0到32位最大值的一个区间，并且首尾相接。当计算出数据（或者数据名称）的哈希值后，必然落到哈希环的某个区间，然后以顺时针，必然能够找到一个节点。那么，这个节点就是存储数据的位置。 </p>
</li>
</ul>
<h4 id="5-【你能说下单点登录SSO吗？】"><a href="#5-【你能说下单点登录SSO吗？】" class="headerlink" title="5. 【你能说下单点登录SSO吗？】"></a>5. 【你能说下单点登录SSO吗？】</h4><p>分布式架构才导致了单点登录，<strong>单点登录就是分布式登录</strong>，即在分布式系统中一个系统登录，其他所有系统共享登录状态；</p>
<p><strong>单点登录的主要实现方式：</strong>将登录功能单独拿出来作为一个独立的模块（即SSO模块），仅且仅与登录相关的操作在该模块中完成;</p>
<p><strong>单一架构将所有的业务都部署到一个Tomcat上，而分布式架构将不同业务部署不同的Tomcat上，形成一个Tomcat集群，这就造成了下面多个Tomcat之间如何共享登录信息的问题</strong></p>
<p><strong>分布式系统存在的问题与解决方案：</strong></p>
<ul>
<li><p><strong>Session不共享问题</strong></p>
<p>单点登录的问题是Session是各个系统所独自拥有的，各个系统不知道用户是否登录，无法共享用户的登录状态，解决的切入点是“要让所有的系统就都可以知道现在用户登录没有”；</p>
<ul>
<li><strong>Tomcat集群Session全局复制</strong>，即使得集群内每个Tomcat的Session完全同步，在任何时候都完全一样，但当集群内Tomcat数量过多时Session全局复制会导致集群性能下降，不建议使用；</li>
<li><strong>把Session数据缓存在各系统都可以访问的Redis中</strong>，这样所有系统就都可以知道现在用户登录状态，建议使用；</li>
<li><strong>使用Token取代Session保存登录状态</strong>，Token是用户名登录生成的一个字符串，存在请求头中进行网络传送，使用Token代替Session，Token相对于Session由于其无状态可以实现应用间共享，解决在Tomcat间共享的问题<strong>（主流SSO解决方案）</strong></li>
</ul>
</li>
<li><p><strong>Cookie跨域问题</strong></p>
<p>跨域问题就是不同域名（一级域名相同二级域名不同）的Cookie服务端接收不到，但是Cookie不是重点，Cookie里面存放的Token才是实现自动登录的重点，Token存在于Cookie中，Cookie不能只能让创建cookie的服务端接收到，导致Token只能让创建Cookie的服务端接收到，解决的切入点是”要让Token在全网服务端都能接收到“</p>
<ul>
<li><strong>放大Cookie作用域使多个域名共享Cookie</strong>，即服务端在新建Cookie第一次发送请求给客户端的时候，就设置好Cookie的domain，设置为顶级Cookie，以后请求还是使用Cookie传输Token；</li>
<li><strong>直接将Token放到URL请求地址后面</strong>，按照一定规则生成Token，第一次通过Cookie将Token发送请求给客户端后，前端将Token解析出来，以后请求不再使用Cookie来传输Token，而是直接将Token放到URL请求地址后面进行传输；</li>
<li><strong>将Token保存在SessionStroage或LocalStorage中，不使用Cookie</strong>，二者都是临时数据存储，SessionStorage表示会话内有效，LocalStorage表示指定时间有效;</li>
</ul>
</li>
</ul>
<p><strong>单一架构的登录过程：</strong></p>
<ol>
<li>首先客户端会发送一个http请求到服务器端（用户登录请求）；</li>
<li>服务器端接收客户端请求后，新建一个保存有用户信息(包含登录状态)的Session并存储在该服务器上，发送一个http响应到客户端，这个响应头部包含了服务器端所给的Cookie，其中sessionId包含在该Cookie中，完成登录认证；</li>
<li>在客户端发起第二次请求（业务请求）时，浏览器自动在http请求头中添加Cookie；</li>
<li>服务器端接收到请求后分解Cookie，获取到其中的sessionId验证信息，通过session来判断该用户是否登录，核对成功后返回响应给客户端成功登录；</li>
</ol>
<p><strong>分布式架构的单点登录过程：</strong></p>
<ul>
<li><p>父域Cookie+Session+Redis（同父域下SSO，不支持跨主域名）</p>
<p>在sso登录模块中登录后，实际上要完成两件事：一是在服务器端的Session中记录包括登录状态等用户信息，同时在客户端下写入保存有SessionId的Cookie，<strong>在sso登录以后，将sso的Cookie的域设置为父域，这样所有子域的应用系统都可以访问到父域的Cookie解决了浏览器的Cookie不能跨域的问题，通过将session集中缓存在redis中解决了服务器端Session不能共享的问题</strong>。不过这种方式要求应用系统的域名需建立在一个共同的主域名之下。</p>
</li>
<li><p>Token+Cookie+CAS认证中心（支持跨主域名SSO）</p>
<p>部署一个专门负责处理登录请求的sso认证中心，即CAS：</p>
<ol>
<li>当用户想要去访问系统A，若系统A发现用户还未登录，就重定向到sso认证中心，并将自己的地址作为参数如<code>www.sso.com?service=www.applicationA.com</code>，sso认证中心发现用户未登录，将用户引导至登录页面统一在认证中心进行登录，<strong>用户与认证中心建立全局会话，登录成功后认证中心记录用户的登录状态等信息到授权令牌Token中，并将 Token 写入 Cookie保存在浏览器上</strong>（注意这个 Cookie 是认证中心的，应用系统是访问不到的），之后认证中心重定向回系统A，并把Token携带去给系统A，重定向的地址如<code>www.applicationA.com?token=xxx</code>；</li>
<li>系统A去sso认证中心验证这个Token是否有效，如果有效则<strong>系统A使用该Token和用户建立局部会话</strong>；</li>
<li>当用户想要访问另一个系统B，系统B发现用户还没有登录，于是重定向到sso认证中心，并将自己的地址作为参数同时带上保存在浏览器上的Cookie，认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，就重定向回系统B，并把Token携带过去给系统B，重定向的地址如<code>www.applicationB.com?token=xxx</code>；</li>
<li>系统B去sso认证中心验证这个Token是否有效，如果有效则系统B使用该Token和用户建立局部会话；</li>
</ol>
</li>
<li><p>Token+LocalStorage（支持跨主域名SSO，几乎可以在前端完成）（待补充）</p>
</li>
</ul>
<h4 id="6-什么是BASE理论？"><a href="#6-什么是BASE理论？" class="headerlink" title="6. 什么是BASE理论？"></a>6. 什么是BASE理论？</h4><p>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</p>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p>
<p><strong>BASE理论核心思想：</strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
<p><strong>BASE理论三要素：</strong></p>
<ul>
<li><p><strong>基本可用</strong></p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统部分非核心功能无法使用</li>
</ul>
</li>
<li><p><strong>软状态</strong></p>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</strong>。</p>
</li>
<li><p><strong>最终一致性</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，本质是<strong>需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</strong>。</p>
</li>
</ul>
<h4 id="7-1-如何保证分布式系统中的接口幂等性？"><a href="#7-1-如何保证分布式系统中的接口幂等性？" class="headerlink" title="7.1 如何保证分布式系统中的接口幂等性？"></a>7.1 如何保证分布式系统中的接口幂等性？</h4><p>（1）<strong>每个请求必须有一个全局请求唯一id</strong>，比如订单支付请求肯定得包含订单id，一个订单id最多支付一次</p>
<p>（2）<strong>每次处理完请求之后，必须有一个记录标识已经处理过这个请求</strong>，比如说常见的方案是在mysql中记录状态</p>
<p>（3）<strong>利用主键唯一索引，且每次接收请求需要进行判断之前是否处理过该逻辑</strong>，比如说如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时要先插入支付流水，而订单Id已经存在了，唯一约束生效，报错无法插入使整个事务回滚。</p>
<h4 id="7-2-幂等有哪些技术解决方案？（待补充）"><a href="#7-2-幂等有哪些技术解决方案？（待补充）" class="headerlink" title="7.2 幂等有哪些技术解决方案？（待补充）"></a>7.2 幂等有哪些技术解决方案？（待补充）</h4><h4 id="✨8-【谈谈你对分布式事务的理解？如何实现最终一致性分布式事务？】"><a href="#✨8-【谈谈你对分布式事务的理解？如何实现最终一致性分布式事务？】" class="headerlink" title="✨8. 【谈谈你对分布式事务的理解？如何实现最终一致性分布式事务？】"></a>✨8. 【谈谈你对分布式事务的理解？如何实现最终一致性分布式事务？】</h4><p><strong>分布式概念</strong>：一个系统分拆多个子系统并部署在不同的服务器上， 然后通过一定的通信协议能够让这些子系统之间相互通信。（核心问题在于解决如何拆分和如何连接这两个问题）</p>
<ul>
<li>优点：提高可用性、可扩展性；</li>
<li>缺点：数据一致性、网络延迟问题；</li>
</ul>
<p><strong>分布式事务概念：</strong>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，<strong>分布式事务就是为了保证不同数据库的数据一致性</strong>。</p>
<p>实现强一致性分布式事务方案：</p>
<ul>
<li><p><strong>二阶段提交方案（2PC） / XA方案</strong></p>
<p>概念：参与者将操作成败通知事务管理器（即协调者），再由事务管理器根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。 </p>
<p>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆ 阶段为提交阶段；</p>
<ul>
<li>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)操作，并反映是否可以提交；</li>
<li>第二阶段：事务协调器要求每个数据库提交数据(commit)，或者回滚数据；</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>单点问题</strong>：事务管理器在整个流程中扮演的角色很关键，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用；</li>
<li><strong>同步阻塞</strong>：在准备就绪之后，资源管理器中的资源一直处于阻塞状态，直到提交完成才释放资源，不支持高并发操作；</li>
<li><strong>数据不一致</strong>：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致。</li>
</ul>
<p><strong>2PC和3PC提交方案的区别：</strong></p>
<ol>
<li>3PC比2PC在pre commit阶段前多了一个can commit阶段，因为2PC在第一阶段会占用资源，而3PC在这阶段不占用资源，只是校验一下sql，如果不能执行就直接返回，减少了资源占用；</li>
<li>2PC只有协调者有超时机制，超时后发送回滚指令，而3PC的协调者和参与者中都引入超时机制，协调者超时，即can commit和pre commit中如果收不到参与者的反馈，则协调者向参与者发送中断指令；参与者超时，即pre commit阶段参与者进行中断，do commit阶段，参与者进行提交；</li>
</ol>
</li>
</ul>
<p>实现最终一致性分布式事务方案：</p>
<ul>
<li><p><strong>【TCC事务补偿型方案（Try-Confirm-Cancel）</strong>- Seata】</p>
<p><strong>TCC方案适用于服务间是接口同步调用的情况；</strong></p>
<ul>
<li><p><strong>Try阶段</strong>：尝试执行。完成所有业务检查，预留并锁定必须的业务资源；</p>
</li>
<li><p><strong>Confirm阶段</strong>：确认执行。真正开始执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，如果Try阶段所有分支事务都执行成功后开始执行Confirm操作，Confirm失败后需要进行重试；</p>
</li>
<li><p><strong>Cancel阶段</strong>：取消执行。释放Try阶段预留的业务资源，如果任何一个服务的业务方法执行出错，就执行前面全部已经执行成功的业务逻辑的回滚操作；</p>
</li>
</ul>
<p><strong>以电商项目下单扣除库存作为例子：</strong></p>
<ul>
<li><p>Try阶段：创建订单，并将订单状态设置为待提交，调用库存服务预扣减库存。库存表中库存字段减去订单中的数量，同时在预扣减字段中增加订单中库存数量，以此来预留资源；</p>
</li>
<li><p>Confirm阶段：如果try全部成功，则进入confirm阶段。此阶段将订单状态修改为已提交，库存服务则将预扣减库存字段的数量减去订单中的数量，实现真正的减库存。（通常TCC方案我们都认为confirm阶段是不会出错的。就是说只要try成功了，那么confirm就一定会成功。如果confirm出错了，那么就需要引入补偿机制或者人工处理）</p>
</li>
<li><p>Cancel阶段：try阶段失败或者出现异常，则进入cancel阶段，订单状态修改为已取消，库存服务将表中库存字段增加订单中的数量，预扣减库存字段减去订单中的数量，以此实现事务回滚。（同样TCC中我们认为cancel阶段一定会执行成功，如果失败也需要引入重试或者人工处理）</p>
</li>
</ul>
<p>TCC方案中锁定资源的粒度小，有利于提高系统性能；Confirm和Cancel阶段的幂等保证分布式事务执行完成后数据的一致性。由主业务方发起事务，无论是主业务还是分支业务都能集群部署，解决了XA方案的单点问题。但是它的代码需要耦合到业务中，参与分布式事务的每个业务方法都需要try，confirm，cancel阶段，增加开发成本。</p>
<p><strong>TCC空回滚是解决什么问题的？</strong>（待补充）</p>
<p><strong>如何解决TCC幂等问题？</strong>（待补充）</p>
<p><strong>如何解决TCC中悬挂问题？</strong>（待补充）</p>
</li>
</ul>
<ul>
<li><p>✨<strong>可靠消息最终一致性方案</strong>（基于MQ或本地消息表来实现事务） - RocketMQ】</p>
<p>可靠消息最终一致性方案：当事务的发起方（消息生产者）执行完本地事务后，同时发出一条消息，事务参与方（消息消费者）一定能够接收消息并可以成功处理自己的事务；</p>
<p><strong>可靠消息方案简易流程：</strong></p>
<ol>
<li>当有请求进来时，事务发起方向MQ发送一个half message，此时这个消息事务参与方还无法消费；</li>
<li>当事务发起方收到MQ返回的发送成功指令后，开始执行本地事务，如果本地事务执行成功则向MQ发送提交half message请求，如果本地事务执行失败则向MQ发送回滚half message请求；</li>
<li>当消息被确认提交后，这条消息就可以被事务参与者消费，当消息被回滚后，消息删除不进行投递，事务参与者就无法消费到这条消息；</li>
<li>当MQ长时间没有收到事务发起方的提交或者回滚请求时，会向事务发起方回查事务状态，事务发起方检查完本地事务的状态后，根据事务状态选择提交或者回滚half message的操作；</li>
</ol>
</li>
<li><p><strong>最大努力通知型方案</strong></p>
<p><strong>最大努力通知型方案适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果的情况</strong>；</p>
<p>特点如下：</p>
<ul>
<li>不可靠消息：业务活动主动方在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失；</li>
<li>定期校对：业务活动的被动方根据定时策略向业务活动主动方查询，由主动方提供查询接口，恢复丢失的业务消息；</li>
</ul>
</li>
</ul>
<h4 id="9-介绍Spring-Cloud核心组件及其作用（说说Spring-Cloud的工作原理）"><a href="#9-介绍Spring-Cloud核心组件及其作用（说说Spring-Cloud的工作原理）" class="headerlink" title="9 介绍Spring Cloud核心组件及其作用（说说Spring Cloud的工作原理）"></a>9 介绍Spring Cloud核心组件及其作用（说说Spring Cloud的工作原理）</h4><p><strong>Eureka：</strong>各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从⽽发现其他服务在哪⾥<strong>（服务注册与服务发现）</strong></p>
<ul>
<li>Eureka的客户端默认每隔30s会向eureka服务端更新实例，注册中⼼也会定时进⾏检查，发现某个实例默认90s内没有再收到心跳，会注销此实例。<strong>（springcloud心跳机制）</strong></li>
</ul>
<p><strong>Ribbon：</strong>服务间发起请求的时候，基于Ribbon做负载均衡，从有该服务的多台机器中选择⼀台<strong>（服务负载均衡）</strong></p>
<p><strong>Feign：</strong>基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址发起请求<strong>（远程服务调用）</strong></p>
<p><strong>Hystrix：</strong>发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，避免了服务雪崩的问题<strong>（服务隔离、降级与熔断）</strong></p>
<p><strong>Zuul：</strong>如果前端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务<strong>（服务网关）</strong></p>
<h4 id="10-说一说Spring-Cloud服务发现原理（Eureka是如何进行服务注册发现的？）"><a href="#10-说一说Spring-Cloud服务发现原理（Eureka是如何进行服务注册发现的？）" class="headerlink" title="10. 说一说Spring Cloud服务发现原理（Eureka是如何进行服务注册发现的？）"></a>10. 说一说Spring Cloud服务发现原理（Eureka是如何进行服务注册发现的？）</h4><ol>
<li>每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li>
<li>注册信息和更新会被复制到其他Eureka 节点，来⾃任何区域的客户端可以查找到注册中⼼信息，每30s发⽣⼀次复制来定位他们的服务，并进⾏远程调⽤。 </li>
<li>客户端还可以缓存⼀些服务实例信息，所以即使Eureka Server全挂掉，客户端也是可以定位到服务地址的。</li>
</ol>
<h4 id="✨11-Hystrix如何实现熔断？（待补充）"><a href="#✨11-Hystrix如何实现熔断？（待补充）" class="headerlink" title="✨11 Hystrix如何实现熔断？（待补充）"></a>✨11 Hystrix如何实现熔断？（待补充）</h4><p>Hystrix在运⾏过程中会向每个commandKey对应的熔断器报告成功、失败、超时和拒绝的状态，熔断器维护计算统计的数据，根据这些统计的信息来确定熔断器是否打开。如果打开，后续的请求都会被截断。然后会隔⼀段时间（默认是5s）尝试半开，放⼊⼀部分流量请求进来，相当于对依赖服务进⾏⼀次健康检查，如果恢复则熔断器关闭，随后完全恢复调⽤。</p>
<h4 id="12-RPC和HTTP的区别，使⽤场景？-（待补充）"><a href="#12-RPC和HTTP的区别，使⽤场景？-（待补充）" class="headerlink" title="12. RPC和HTTP的区别，使⽤场景？ （待补充）"></a>12. RPC和HTTP的区别，使⽤场景？ （待补充）</h4><p>**RPC(Remote Procedure Call)**：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p><strong>两者区别如下：</strong> </p>
<ul>
<li><p>传输协议 </p>
<ul>
<li>RPC，可以基于TCP协议，也可以基于HTTP协议</li>
<li>HTTP，基于HTTP协议 </li>
</ul>
</li>
<li><p>传输效率</p>
<ul>
<li><p>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</p>
</li>
<li><p>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理</p>
</li>
</ul>
</li>
<li><p>性能消耗，主要在于序列化和反序列化的耗时</p>
<ul>
<li><p>RPC，可以基于thrift实现⾼效的⼆进制传输</p>
</li>
<li><p>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</p>
</li>
</ul>
</li>
<li><p>负载均衡</p>
<ul>
<li>RPC，基本都⾃带了负载均衡策略</li>
<li>HTTP，需要配置Nginx，HAProxy来实现</li>
</ul>
</li>
<li><p>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</p>
<ul>
<li><p>RPC，能做到⾃动通知，不影响上游</p>
</li>
<li><p>HTTP，需要事先通知，修改Nginx/HAProxy配置</p>
</li>
</ul>
<p><strong>总结：</strong>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</p>
</li>
</ul>
<h4 id="13-分布式id的生成方案有哪些？"><a href="#13-分布式id的生成方案有哪些？" class="headerlink" title="13. 分布式id的生成方案有哪些？"></a>13. 分布式id的生成方案有哪些？</h4><ol>
<li>UUID：通用唯一标识码，让分布式系统中的所有元素都有唯一的便是信息，而不需要通过中央控制器来指定唯一标识；缺点在于占用16个字符，且不是递增有序的数字；</li>
<li>数据库自增主键：MySQL数据库设置主键且主键自动增长，缺点在于自增在分库分表时需要改造较为复杂，数据和数据量容易泄露；</li>
<li>Redis自增，通过Redis计数器原子性自增</li>
<li>雪花算法<ul>
<li>雪花算法生成id的组成部分：1位符号位，41位时间戳，10位机器码以及12位序列码；</li>
</ul>
</li>
</ol>
<h4 id="14-微服务相关内容补充"><a href="#14-微服务相关内容补充" class="headerlink" title="14. 微服务相关内容补充"></a>14. 微服务相关内容补充</h4><h5 id="14-1-微服务架构原理是什么？"><a href="#14-1-微服务架构原理是什么？" class="headerlink" title="14.1 微服务架构原理是什么？"></a>14.1 微服务架构原理是什么？</h5><p>主要是面向服务理念，更小粒度地拆分服务，将功能分解到各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持；</p>
<h5 id="14-2-注册中心的原理是什么？"><a href="#14-2-注册中心的原理是什么？" class="headerlink" title="14.2 注册中心的原理是什么？"></a>14.2 注册中心的原理是什么？</h5><p>以Eureka为例，服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者时，则向服务注册中心获取服务提供者地址然后会将服务提供者地址缓存在本地，下次再调用时则直接从本地缓存中获取服务列表来完成服务调用；</p>
<h5 id="14-3-配置中心的原理是什么？"><a href="#14-3-配置中心的原理是什么？" class="headerlink" title="14.3 配置中心的原理是什么？"></a>14.3 配置中心的原理是什么？</h5><p>在服务运行之前，将所需的配置信息从配置仓库拉取到本地服务，达到统一化配置管理的目的；</p>
<h5 id="14-4-配置中心是如何实现自动刷新的？"><a href="#14-4-配置中心是如何实现自动刷新的？" class="headerlink" title="14.4 配置中心是如何实现自动刷新的？"></a>14.4 配置中心是如何实现自动刷新的？</h5><p>以Config为例：</p>
<ol>
<li>配置中心Server端承担起配置刷新的职责，提交配置触发post请求给Server端的bus/refresh接口，Server端接收到请求并发送给Spring Cloud Bus总线；</li>
<li>Spring Cloud Bus接收到消息并通知给其他连接到总线的客户端，其它客户端接收到通知，请求Server端获取到最新配置；</li>
</ol>
<h5 id="14-5-Ribbon负载均衡原理是什么？"><a href="#14-5-Ribbon负载均衡原理是什么？" class="headerlink" title="14.5 Ribbon负载均衡原理是什么？"></a>14.5 Ribbon负载均衡原理是什么？</h5><p>Ribbon通过ILoadBalancer接口对外提供统一的选择服务器Server的功能，ILoadBalancer通过调用IRule的choose()返回合适的Server给使用者；</p>
<h5 id="14-6-注册中心和服务挂了应该如何处理？"><a href="#14-6-注册中心和服务挂了应该如何处理？" class="headerlink" title="14.6 注册中心和服务挂了应该如何处理？"></a>14.6 注册中心和服务挂了应该如何处理？</h5><p>当注册中心挂了可以读取本地持久化里的配置，当服务挂了配有的服务监控中心会感知到服务下线，之后通过配置好的通知机制通知相关人员排查问题；</p>
<h2 id="搜索引擎（待补充）"><a href="#搜索引擎（待补充）" class="headerlink" title="搜索引擎（待补充）"></a>搜索引擎（待补充）</h2><h4 id="1-es的分布式架构原理能说一下么（es是如何实现分布式的）"><a href="#1-es的分布式架构原理能说一下么（es是如何实现分布式的）" class="headerlink" title="1. es的分布式架构原理能说一下么（es是如何实现分布式的）"></a>1. es的分布式架构原理能说一下么（es是如何实现分布式的）</h4><p>elasticsearch设计的理念就是<strong>分布式搜索引擎</strong>，底层其实还是基于lucene的。核心思想就是在多台机器上启动多个es进程实例，组成了一个es集群。</p>
<p>es中存储数据的基本单位是索引，比如说你现在要在es中存储一些订单数据，你就应该在es中创建一个索引order_idx，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是mysql里的一张表。index -&gt; type -&gt; mapping -&gt; document -&gt; field</p>
<ul>
<li><p><strong>index：相当于mysql里的一张表</strong></p>
</li>
<li><p>type：没法跟mysql里去对比，一个index里可以有多个type，每个type的字段都是差不多的，但是有一些略微的差别。</p>
<ul>
<li>好比说，有一个index，是订单index，里面专门是放订单数据的，有些订单是实物商品的订单，而有些订单是虚拟商品的订单，就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。所以就会在订单index里，建两个type，一个是实物商品订单type，一个是虚拟商品订单type，这两个type大部分字段是一样的，少部分字段是不一样的。</li>
<li>很多情况下，一个index里可能就一个type，但是确实如果说是一个index里有多个type的情况，你<strong>可以认为index是一个类别的表，具体的每个type代表了具体的一个mysql中的表</strong>；</li>
<li>每个type有一个mapping，如果你认为一个type是一个具体的一个表，index代表了多个type的同属于的一个类型，mapping就是这个type的表结构定义，你在mysql中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型；</li>
</ul>
</li>
<li><p><strong>mapping就代表了这个type的表结构的定义</strong>，定义了这个type中每个字段名称，字段是什么类型的，然后还有这个字段的各种配置</p>
</li>
</ul>
<ul>
<li><strong>实际上往index里的一个type里面写的一条数据，叫做一条document，一条document就代表了mysql中某个表里的一行</strong>；</li>
<li>每个document有多个field，<strong>每个field就代表了这个document中的一个字段的值</strong></li>
</ul>
<p> 索引可以拆分成多个shard，每个shard存储部分数据。这个shard的数据实际是有多个备份，就是说每个shard都有一个primary shard负责写入数据，还有几个replica shard。primary shard写入数据之后，会将数据同步到其他几个replica shard。通过这个replica的方案，每个shard的数据都有多个备份，如果某个机器宕机了还有别的数据副本在别的机器上实现高可用；</p>
<p>es集群多个节点，会自动选举一个节点为master节点，这个master节点其实就是干一些管理的工作，比如维护索引元数据，负责切换primary shard和replica shard身份等。要是master节点宕机了，那么会在剩余节点中重新选举一个节点为master节点。如果是非master节点宕机了，那么会由master节点，<strong>让那个宕机节点上的primary shard的身份转移到保存在其他机器上的replica shard上</strong>。修复了那个宕机机器重启了之后，<strong>master节点会控制将宕机节点上原本的primary shard修改为replica shard</strong>，让集群恢复正常。</p>
<h4 id="2-es写入数据的工作原理是什么？es查询数据的工作原理是什么？"><a href="#2-es写入数据的工作原理是什么？es查询数据的工作原理是什么？" class="headerlink" title="2. es写入数据的工作原理是什么？es查询数据的工作原理是什么？"></a>2. es写入数据的工作原理是什么？es查询数据的工作原理是什么？</h4><p><strong>es写入数据过程：</strong></p>
<p>1）客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点）</p>
<p>2）coordinating node，对document进行路由，将请求转发给对应的有primary shard的node</p>
<p>3）实际的node上的primary shard处理请求，然后将数据同步到replica node</p>
<p>4）coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端</p>
<ul>
<li><strong>写入数据底层原理：</strong><ol>
<li>先写入buffer（内存），在buffer里的时候数据是搜索不到的，同时将数据写入translog日志文件；</li>
<li>如果buffer快满了，或者每隔一定时间，就会将buffer中的数据refresh到一个新的segment file（磁盘文件）中，但是此时数据不是直接进入segment file的，而是先进入os cache（操作系统缓存），这个过程就是<strong>refresh操作</strong>，只要buffer中的数据被refresh操作刷入os cache中，就代表这个数据就可以被搜索到了；<strong>（默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到）</strong></li>
<li>重复前面步骤，新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。<ul>
<li>commit操作就是将buffer中现有数据refresh到os cache中去，然后清空buffer，将一个commit point写入磁盘文件，里面标识着这个commit point对应的前面写入的所有segment file；之后强行将os cache中缓存所有的数据都fsync到磁盘中去；最后将现有的translog清空，然后再次重新启用一个translog，此时commit操作完成。默认每隔30分钟会自动执行一次commit，但是如果translog过大，也会触发commit。整个commit的过程叫做<strong>flush操作</strong>。</li>
<li><strong>translog日志文件作用</strong>：将数据对应的操作写入一个专门的日志文件防止宕机导致写入buffer或os cache内存中的数据丢失，宕机重启后es也会自动读取translog日志文件中的数据，恢复到内存buffer和os cache中去；</li>
<li><strong>可能会丢失数据的</strong>，translog其实也是先写入os cache的，默认每隔5秒刷一次到磁盘中去，所以默认情况下有5秒的数据会停留在buffer、translog os cache、segment file os cache中，有5秒的数据不在磁盘上，此时如果宕机，会导致这5秒的数据丢失，如果不希望丢失数据也可以将translog设置成每次写操作必须是直接fsync到磁盘。</li>
</ul>
</li>
<li>buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，此时会定期执行<strong>merge操作</strong>；<ul>
<li>每次merge的时候，会将多个segment file合并成一个，同时这里会将标识为deleted的doc给物理删除掉，然后将新的segment file写入磁盘，这里会写一个commit point，标识所有新的segment file，然后打开segment file供搜索使用，同时删除旧的segment file。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>es查询数据过程：</strong></p>
<p>1）客户端发送请求到任意一个node，成为coordinate node</p>
<p>2）coordinate node对document进行路由，将请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其所有replica中随机选择一个，让读请求负载均衡</p>
<p>3）接收请求的node返回document给coordinate node</p>
<p>4）coordinate node返回document给客户端</p>
<p><strong>es搜索数据过程：</strong></p>
<p>1）客户端发送请求到一个coordinate node</p>
<p>2）协调节点将搜索请求转发到所有的shard对应的primary shard或replica shard也可以</p>
<p>3）query phase：每个shard将自己的搜索结果（其实就是一些doc id），返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果</p>
<p>4）fetch phase：接着由协调节点，根据doc id去各个节点上拉取实际的document数据，最终返回给客户端</p>
<ul>
<li><p><strong>搜索的底层原理：倒排索引</strong></p>
<p>区别于传统检索是通过文章逐个遍历找到对应关键词的位置，倒排索引是通过分词策略形成词和文章的映射关系表，从词出发记载了这个词在哪些文档中出现过，由<strong>词典和倒排表</strong>两部分组成；（倒排索引底层实现基于FST数据结构）</p>
</li>
</ul>
<h4 id="3-es在数据量很大的情况下（数十亿级别）如何提高查询性能？"><a href="#3-es在数据量很大的情况下（数十亿级别）如何提高查询性能？" class="headerlink" title="3. es在数据量很大的情况下（数十亿级别）如何提高查询性能？"></a>3. es在数据量很大的情况下（数十亿级别）如何提高查询性能？</h4><h4 id="4-es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"><a href="#4-es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？" class="headerlink" title="4. es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"></a>4. es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</h4><p>（1）es生产集群我们部署了5台机器，每台机器是6核64G的，集群总内存是320G</p>
<p>（2）我们es集群的日增量数据大概是2000万条，每天日增量数据大概是500MB，每月增量数据大概是6亿，15G。目前系统已经运行了几个月，现在es集群里数据总量大概是100G左右。</p>
<p>（3）目前线上有5个索引（这个结合你们自己业务来，看看自己有哪些数据可以放es的），每个索引的数据量大概是20G，所以这个数据量之内，我们每个索引分配的是8个shard，比默认的5个shard多了3个shard。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1-网络分层模型有哪些以及每一层的作用"><a href="#1-网络分层模型有哪些以及每一层的作用" class="headerlink" title="1. 网络分层模型有哪些以及每一层的作用"></a>1. 网络分层模型有哪些以及每一层的作用</h4><p><strong>OSI分层 （7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、 网际层、运输层、 应用层。 </p>
<p><strong>五层协议   （5层）</strong>：物理层、数据链路层、网络层、运输层、 应用层。</p>
<p>每一层的作用如下： </p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特Bit） </p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧Frame）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（数据报） </p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（报文段）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元SPDU） </p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） </p>
<p><strong>应用层</strong>：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<h4 id="2-计算机网络各层有哪些协议？"><a href="#2-计算机网络各层有哪些协议？" class="headerlink" title="2. 计算机网络各层有哪些协议？"></a>2. 计算机网络各层有哪些协议？</h4><p><strong>每一层的协议如下：</strong></p>
<p><strong>物理层</strong>：中继器，集线器，网关</p>
<p><strong>数据链路层</strong>：PPP点对点协议、ARQ自动重传请求协议、CSMA/CD停止等待协议</p>
<p><strong>网络层</strong>：IP网际协议、ICMP控制消息协议、ARP地址转换协议、RARP反向地址转换协议、OSPF分布式链路状态协议、BGP边界网关协议RIP路由信息协议、IGMP组管理协议</p>
<p><strong>传输层</strong>：TCP传输控制协议、UDP用户数据报协议</p>
<p><strong>应用层</strong>：FTP文本传输协议、DNS域名解析系统、Telnet远程登录协议、SMTP简单邮件传输协议、HTTP超文本传输协议、SSH安全外壳协议、DHCP动态主机配置协议</p>
<h5 id="2-1-ICMP协议的作用"><a href="#2-1-ICMP协议的作用" class="headerlink" title="2.1 ICMP协议的作用"></a>2.1 ICMP协议的作用</h5><p>ICMP协议：控制消息协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。（ping是工作在TCP/IP网络体系结构中应用层的一个服务命令，<strong>基于ICMP协议</strong>，主要是向特定的目的主机发送ICMP请求报文，测试目的站是否为可达及了解其有关状态）</p>
<h4 id="3-【请说一下从浏览器地址栏输入URL到显示主页的过程】"><a href="#3-【请说一下从浏览器地址栏输入URL到显示主页的过程】" class="headerlink" title="3. 【请说一下从浏览器地址栏输入URL到显示主页的过程】"></a>3. 【请说一下从浏览器地址栏输入URL到显示主页的过程】</h4><p>1、客户端通过DNS解析，查找域名对应的IP地址，通过IP地址找到客户端到服务器的路径；<br>2、客户端发起TCP请求，与服务器通过三次握手建立TCP连接，向IP对应的web服务器发送一个HTTP请求（Cookie会随着请求发送给服务器）；<br>3、服务器响应HTTP请求，返回网页内容；</p>
<p>4、客户端解析html并渲染网页内容；</p>
<p>5、TCP四次挥手释放连接；</p>
<h5 id="3-1-URI和URL的区别"><a href="#3-1-URI和URL的区别" class="headerlink" title="3.1 URI和URL的区别"></a>3.1 URI和URL的区别</h5><ul>
<li>URI：统一资源标识符，主要作用是唯一标识一个资源。</li>
<li>URL：统一资源定位符，主要作用是提供资源的路径。</li>
</ul>
<h4 id="4-【ARP地址解析协议工作原理】"><a href="#4-【ARP地址解析协议工作原理】" class="headerlink" title="4. 【ARP地址解析协议工作原理】"></a>4. 【ARP地址解析协议工作原理】</h4><p>ARP地址解析协议：<strong>用于实现IP地址到MAC地址的映射</strong>；（广播发送ARP请求，单播发送ARP响应）</p>
<ol>
<li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 </p>
</li>
<li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据报，该数据报包括的内容有：<strong>源主机</strong> <strong>IP地址，源主机MAC地址，目的主机的IP 地址</strong>。 </p>
</li>
<li><p>当本网络的所有主机收到该ARP数据报时，首先检查数据报中的IP地址是否是自己的IP地址，如果不是，则忽略该数据报，如果是，则首先从数据报中取出源主机的IP和MAC地址写入到自己的ARP列表中，如果已经存在则覆盖，然后将自己的MAC地址写入ARP响应报中，告诉源主机自己是它想要找的MAC地址。 </p>
</li>
<li><p>源主机收到ARP响应报后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据报，表示ARP查询失败。</p>
</li>
</ol>
<h5 id="4-1-有了IP地址为什么还要用MAC地址？"><a href="#4-1-有了IP地址为什么还要用MAC地址？" class="headerlink" title="4.1 有了IP地址为什么还要用MAC地址？"></a>4.1 有了IP地址为什么还要用MAC地址？</h5><ul>
<li>计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用；</li>
<li>为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址分别在哪个子网，这需要路由器有极大的存储空间是无法实现的；</li>
</ul>
<h4 id="5-TCP和UDP相关问题"><a href="#5-TCP和UDP相关问题" class="headerlink" title="5. TCP和UDP相关问题"></a>5. TCP和UDP相关问题</h4><h5 id="5-1-请简述TCP与UDP的区别"><a href="#5-1-请简述TCP与UDP的区别" class="headerlink" title="5.1 请简述TCP与UDP的区别"></a>5.1 请简述TCP与UDP的区别</h5><ol>
<li>TCP面向连接，UDP不面向连接即发送数据前不需要建立连接</li>
<li>TCP提供可靠的服务（数据传输），UDP无法保证可靠交付</li>
<li>TCP面向字节流，UDP面向报文且没有拥塞控制</li>
<li>TCP只能是点到点的，UDP支持一对一和多对多的交互通信</li>
<li>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般</li>
</ol>
<h5 id="5-2-TCP的粘包和拆包问题"><a href="#5-2-TCP的粘包和拆包问题" class="headerlink" title="5.2 TCP的粘包和拆包问题"></a>5.2 TCP的粘包和拆包问题</h5><p>TCP的粘包和拆包：指的是<strong>一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送</strong>；<br><strong>产生粘包和拆包的原因：</strong></p>
<p>粘包：①要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去；<br>            ②接收数据端的应用层没有及时读取接收缓冲区中的数据；</p>
<p>拆包：①要发送的数据大于TCP发送缓冲区剩余空间大小；<br>            ②待发送数据大于MSS（最大报文长度）；<br><strong>解决方案：</strong></p>
<p>①发送端将每个数据包封装为固定长度；<br>②在数据尾部增加特殊字符进行分割；<br>③将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小；</p>
<h5 id="5-3-TCP的流量控制与滑动窗口"><a href="#5-3-TCP的流量控制与滑动窗口" class="headerlink" title="5.3 TCP的流量控制与滑动窗口"></a>5.3 TCP的流量控制与滑动窗口</h5><p><strong>TCP滑动窗口</strong>：是操作系统开辟的一个缓存空间，窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。TCP头部有个字段叫<strong>win</strong>，也即那个<strong>16位的窗口大小</strong>，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p>
<h5 id="5-4-TCP的拥塞控制"><a href="#5-4-TCP的拥塞控制" class="headerlink" title="5.4 TCP的拥塞控制"></a>5.4 TCP的拥塞控制</h5><ul>
<li><strong>TCP拥塞控制</strong>：拥塞控制是<strong>作用于网络的</strong>，防止过多的数据包注入到网络中，避免出现网络负载过大的情况，最大化利用网络上瓶颈链路的带宽。只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。而对比流量控制是<strong>作用于接收者的</strong>，根据接收端的实际接收能力控制发送速度，防止分组丢失的。</li>
<li><strong>拥塞控制常用算法</strong><ul>
<li><strong>慢启动</strong>：表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）</strong>。<strong>每过一个RTT</strong>发送窗口增加一倍，呈指数增长，如果出现丢包或超过慢启动阈值，拥塞窗口就减半，进入拥塞避免阶段。</li>
<li><strong>拥塞避免</strong>：<br>cwnd到达<strong>慢启动阀值后，</strong>每收到一个ACK时，cwnd = cwnd + 1/cwnd；当每过一个RTT时，cwnd = cwnd + 1，避免过快导致网络拥塞问题。</li>
<li><strong>拥塞发生</strong>：发生超时重传时慢启动阈值减半，cwnd重置为1，进入新的慢启动过程；发生快速重传时，发送方收到3个连续重复的ACK时，就会快速地重传，不必等待<strong>RTO超时</strong>再重传。</li>
<li><strong>快速恢复</strong>：配合快速重传使用，重传重复的那几个ACK（即丢失的那几个数据包）；如果再收到重复的 ACK，那么 cwnd = cwnd +1；如果收到新数据的 ACK 后, cwnd = sshthresh，因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li>
</ul>
</li>
<li><strong>TCP的重传机制</strong><ul>
<li><strong>超时重传</strong>：原理是在发送某一个数据以后就开启一个计时器，在一个RTO如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</li>
<li><strong>快速重传</strong>：发送方连着收到三个重复冗余ACK的确认后，知道哪个报文段在传输过程中丢失了；发送方在定时器过期之前，重传该报文段。</li>
<li><strong>带选择确认的重传（SACK）</strong>：在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。</li>
<li><strong>重复SACK</strong>：用来告诉发送方，有哪些数据包，自己重复接受了。DSACK的目的是帮助发送方判断，是否发生了包失序、ACK丢失、包重复或伪重传。让TCP可以更好的做网络流控</li>
</ul>
</li>
</ul>
<h4 id="6-【介绍一下TCP三次握手建立连接的过程】"><a href="#6-【介绍一下TCP三次握手建立连接的过程】" class="headerlink" title="6. 【介绍一下TCP三次握手建立连接的过程】"></a>6. 【介绍一下TCP三次握手建立连接的过程】</h4><ol>
<li><strong>客户端发送连接请求报文段并进入SYN_SEND状态</strong>，等待服务器端确认，无应用层数据；</li>
<li><strong>服务器端</strong>收到客户端的连接请求报文段后，为该TCP连接分配缓存和变量，<strong>向客户端返回确认报文段ack允许连接并进入SYN_RCV状态</strong>，无应用层数据；</li>
<li><strong>客户端</strong>为该TCP连接分配缓存和变量，并<strong>向服务器端返回确认的确认数据报ack，客户端进入ESTABLISHED状态，当服务器端接收到这个确认包时，也进入ESTABLISHED状态</strong>，可以携带数据；</li>
</ol>
<h5 id="6-1-为什么采用三次握手而不是两次握手？"><a href="#6-1-为什么采用三次握手而不是两次握手？" class="headerlink" title="6.1 为什么采用三次握手而不是两次握手？"></a>6.1 为什么采用三次握手而不是两次握手？</h5><p>建立连接的过程是利用客户-服务器模式，假设主机A为客户端，主机B为服务器端。 </p>
<p> （1）<strong>TCP的三次握手过程</strong>：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 </p>
<p> （2）<strong>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B</strong>。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 </p>
<h5 id="6-2-半连接队列和全连接队列"><a href="#6-2-半连接队列和全连接队列" class="headerlink" title="6.2 半连接队列和全连接队列"></a>6.2 半连接队列和全连接队列</h5><p>TCP进入三次握手前，服务器端会从<strong>CLOSED</strong>状态变为<strong>LISTEN</strong>状态，同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）</p>
<ul>
<li>TCP三次握手时，客户端发送SYN到服务器端，服务器端收到之后，便回复<strong>ACK和SYN</strong>，状态由<strong>LISTEN变为SYN_RCV</strong>，此时这个连接就被推入了<strong>SYN队列</strong>，即半连接队列；</li>
<li>当客户端回复ACK, 服务器端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入<strong>ACCEPT队列</strong>，即全连接队列；</li>
</ul>
<h4 id="7-【介绍一下TCP四次挥手释放连接的过程】"><a href="#7-【介绍一下TCP四次挥手释放连接的过程】" class="headerlink" title="7. 【介绍一下TCP四次挥手释放连接的过程】"></a>7. 【介绍一下TCP四次挥手释放连接的过程】</h4><ol>
<li><strong>客户端发送连接释放报文段FIN</strong>，停止发送数据，主动关闭TCP连接，客户端进入<strong>FIN_WAIT_1</strong>状态；</li>
<li><strong>服务器端收到后回送一个确认报文段ACK</strong>，客户端到服务器端这个方向的连接就被释放了，但服务器端仍处于关闭等待（<strong>Close_Wait</strong>）状态，客户端仍可以接收数据，在接收到这个确认报文段之后，进入<strong>FIN_WAIT_2</strong>状态；</li>
<li><strong>服务器端发完数据就发出连接释放报文段FIN</strong>，主动关闭TCP连接，服务器端进入<strong>LAST_ACK</strong>状态，等待来自客户端的最后一个ACK；</li>
<li><strong>客户端回送一个确认报文段ACK</strong>，并进入时间等待（Time_Wait）状态，在等待两个最大生命周期2MSL后，连接彻底关闭；</li>
</ol>
<h5 id="7-1-为什么需要四次挥手？"><a href="#7-1-为什么需要四次挥手？" class="headerlink" title="7.1 为什么需要四次挥手？"></a>7.1 为什么需要四次挥手？</h5><p>TCP是<strong>全双工模式</strong>，这就意味着，当客户端发出FIN报文段时，只是表示客户端告诉服务器，它的数据已经全部发送完毕了，但是这个时候客户端还是可以接收来自服务端的数据；当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端；当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后就会中断这次TCP连接。<strong>简单地说，前两次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道</strong>。</p>
<h5 id="7-2-如果服务器出现大量CLOSE-WAIT状态如何解决？"><a href="#7-2-如果服务器出现大量CLOSE-WAIT状态如何解决？" class="headerlink" title="7.2 如果服务器出现大量CLOSE_WAIT状态如何解决？"></a>7.2 如果服务器出现大量CLOSE_WAIT状态如何解决？</h5><p>服务器端收到客户端发送的连接释放报文FIN后，TCP协议栈就会自动发送ACK，接着进入<strong>CLOSE_WAIT</strong>状态。但是如果服务器端不执行socket的close()操作，那么就没法进入LAST_ACK，导致大量连接处于<strong>CLOSE_WAIT</strong>状态，所以如果服务器出现了大量<strong>CLOSE_WAIT</strong>状态，一般是程序Bug，或者关闭socket不及时，需要去排查程序或者手动执行socket的close()操作；</p>
<h5 id="7-3-TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态"><a href="#7-3-TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态" class="headerlink" title="7.3 TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态"></a>7.3 TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态</h5><ol>
<li><strong>为了保证客户端发送的最后一个ACK报文段能够到达服务端。</strong> 这个ACK报文段有可能丢失，因而使处在<strong>LAST-ACK</strong>状态的服务端就收不到对已发送的<strong>FIN + ACK</strong>报文段的确认。服务端会超时重传这个FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动2MSL计时器。最后，客户端和服务器都正常进入到<strong>CLOSED</strong>状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h4 id="8-【DNS域名解析原理】"><a href="#8-【DNS域名解析原理】" class="headerlink" title="8. 【DNS域名解析原理】"></a>8. 【DNS域名解析原理】</h4><p>DNS：域名解析系统，是Internet上作为域名和IP相互映射的一个分布式数据库；</p>
<p><strong>DNS解析查找过程：</strong><br>1.首先会查找浏览器的缓存，看是否能找到域名对应的IP地址，找到就直接返回，否则进行下一步；</p>
<p>2.将请求发给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；</p>
<p>3.①本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责.com的顶级域名服务器的IP地址的列表；<br>   ②本地DNS服务器再向其中一个负责.com的顶级域名服务器发送一个请求，返回负责xxx的权威域名服务器的IP地址列表；<br>   ③本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回完整域名所对应的IP地址。</p>
<h4 id="9-【HTTP和HTTPS协议的区别】"><a href="#9-【HTTP和HTTPS协议的区别】" class="headerlink" title="9. 【HTTP和HTTPS协议的区别】"></a>9. 【HTTP和HTTPS协议的区别】</h4><p>HTTPS：超文本传输安全协议，经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包</p>
<p><strong>HTTP与HTTPS的区别</strong>：</p>
<ol>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要到数字证书认证机构申请证书。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>HTTP和 HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li><strong>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议</strong>，所以HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ol>
<h5 id="9-1-客户端使用HTTPS方式与Web服务器通信步骤"><a href="#9-1-客户端使用HTTPS方式与Web服务器通信步骤" class="headerlink" title="9.1 客户端使用HTTPS方式与Web服务器通信步骤"></a>9.1 客户端使用HTTPS方式与Web服务器通信步骤</h5><p>（1）客户使用https的URL请求访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p> （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥，私钥由服务器持有）传送一份给客户端。</p>
<p> （3）客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会<strong>生成一个随机的对称密钥，用证书的公钥加密，并将公钥加密后的对称密钥传送给Web服务器</strong>。</p>
<p> （4）Web服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后<strong>用客户端密钥对返回数据进行对称加密</strong>，服务器将加密后的密文返回到客户端。</p>
<p> （5）客户端收到后，<strong>用对称密钥对其进行对称解密</strong>，得到服务器返回的数据。</p>
<h5 id="9-2-什么是数字签名和数字证书？"><a href="#9-2-什么是数字签名和数字证书？" class="headerlink" title="9.2 什么是数字签名和数字证书？"></a>9.2 什么是数字签名和数字证书？</h5><p><strong>数字签名</strong>：公钥和个人等信息，经过Hash摘要算法加密会形成消息摘要，将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密就形成数字签名；<br><strong>数字证书</strong>：指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份，而公钥和个人信息、数字签名共同构成数字证书；</p>
<h5 id="9-3-对称加密和非对称加密的区别"><a href="#9-3-对称加密和非对称加密的区别" class="headerlink" title="9.3 对称加密和非对称加密的区别"></a>9.3 对称加密和非对称加密的区别</h5><p><strong>对称加密</strong>：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES等。<br><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有RSA。</p>
<h4 id="10-HTTP中GET和POST的区别"><a href="#10-HTTP中GET和POST的区别" class="headerlink" title="10. HTTP中GET和POST的区别"></a>10. HTTP中GET和POST的区别</h4><p>GET：对服务器资源的简单获取<br>POST：用于发送包含用户提交数据的请求</p>
<p><strong>GET和POST具体区别：</strong></p>
<ol>
<li><strong>数据报</strong>：GET产生一个TCP数据报，POST可能产生两个TCP数据报；</li>
<li><strong>请求参数</strong>：GET把参数包含在URL中，用&amp;连接起来；POST通过响应体传递参数；</li>
<li><strong>请求缓存</strong>：GET会被主动缓存，POST不会缓存除非手动设置</li>
</ol>
<h4 id="11-【如何理解HTTP是无状态协议】"><a href="#11-【如何理解HTTP是无状态协议】" class="headerlink" title="11. 【如何理解HTTP是无状态协议】"></a>11. 【如何理解HTTP是无状态协议】</h4><p>当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是服务器不知道其实就是刚才的那个浏览器。简言之，服务器不会去记住访问的对象，所以是无状态协议，可以使用Cookie进行解决；</p>
<h5 id="11-1-HTTP1-0、1-1与2-0的区别"><a href="#11-1-HTTP1-0、1-1与2-0的区别" class="headerlink" title="11.1 HTTP1.0、1.1与2.0的区别"></a>11.1 HTTP1.0、1.1与2.0的区别</h5><p><strong>HTTP1.0：</strong><br>默认使用短连接，每次请求都需要建立一个TCP连接；</p>
<p><strong>HTTP1.1：</strong></p>
<ol>
<li>引入持久连接，即TCP连接默认不关闭，可被多个请求复用；</li>
<li>分块传输编码。即服务器端每产生一块数据就传送一块，用流模式取代缓存全部数据再传输的模式；</li>
<li>管道机制，即同一个TCP连接中客户端可同时发送多个请求；</li>
</ol>
<p><strong>HTTP2.0：</strong></p>
<ol>
<li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应；</li>
<li>服务端推送，允许服务器未经请求主动向客户端发送资源；</li>
</ol>
<h5 id="11-2-HTTP的状态码301和302的区别"><a href="#11-2-HTTP的状态码301和302的区别" class="headerlink" title="11.2 HTTP的状态码301和302的区别"></a>11.2 HTTP的状态码301和302的区别</h5><p>301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</p>
<p>302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。</p>
<h4 id="12-forward和redirect的区别？"><a href="#12-forward和redirect的区别？" class="headerlink" title="12. forward和redirect的区别？"></a>12. forward和redirect的区别？</h4><p><strong>forward</strong>：直接转发方式，客户端和浏览器只发出一次请求，由信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。<br><strong>redirect</strong>：间接转发方式，实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>
<h4 id="13-WebSocket与Socket的区别？"><a href="#13-WebSocket与Socket的区别？" class="headerlink" title="13. WebSocket与Socket的区别？"></a>13. WebSocket与Socket的区别？</h4><p><strong>WebSocket</strong>：是一个持久化的应用层通信协议，它是伴随H5而出的协议，用来解决http不支持持久化连接的问题；<br><strong>Socket</strong>：一个是网编编程的标准接口，等于<strong>IP地址 + 端口 + 协议</strong>；</p>
<h4 id="14-Session和Cookie的区别？"><a href="#14-Session和Cookie的区别？" class="headerlink" title="14. Session和Cookie的区别？"></a>14. Session和Cookie的区别？</h4><p><strong>Cookie：</strong>是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。<br><strong>Session：</strong>指的就是服务器和客户端一次会话的过程。Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。</p>
<h5 id="14-1-Session和Cookie运行流程"><a href="#14-1-Session和Cookie运行流程" class="headerlink" title="14.1 Session和Cookie运行流程"></a>14.1 Session和Cookie运行流程</h5><ul>
<li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie中，同时Cookie记录此SessionID是属于哪个域名。</li>
<li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID查找对应的 Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。</li>
</ul>
<h4 id="15-重定向和请求转发的区别？"><a href="#15-重定向和请求转发的区别？" class="headerlink" title="15. 重定向和请求转发的区别？"></a>15. 重定向和请求转发的区别？</h4><p>（1）请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；</p>
<p>（2）地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
<p>（3）是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
<p>（4）跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
<p>（5）发生行为不同：重定向是客户端行为，转发是服务器端行为。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="1-Linux里如何查看一个想知道的进程？"><a href="#1-Linux里如何查看一个想知道的进程？" class="headerlink" title="1. Linux里如何查看一个想知道的进程？"></a>1. Linux里如何查看一个想知道的进程？</h4><p><strong>查看进程运行状态的指令</strong>：<strong>ps</strong>命令。**”ps aux | grep PID”**，用来查看某PID进程状态</p>
<h4 id="2-Linux里如何查看带有关键字的日志文件？"><a href="#2-Linux里如何查看带有关键字的日志文件？" class="headerlink" title="2. Linux里如何查看带有关键字的日志文件？"></a>2. Linux里如何查看带有关键字的日志文件？</h4><p><strong>“cat 路径/文件名 | grep 关键词”<strong>或者</strong>“grep -i 关键词 路径/文件名”</strong> </p>
<h4 id="3-Linux修改主机名的命令是什么？"><a href="#3-Linux修改主机名的命令是什么？" class="headerlink" title="3. Linux修改主机名的命令是什么？"></a>3. Linux修改主机名的命令是什么？</h4><ol>
<li><p>如果只需要临时更改主机名，可以使用hostname命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo hostname &lt;new-hostname&gt; </span><br></pre></td></tr></table></figure></li>
<li><p>如果想永久改变主机名，可以使用hostnamectl命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo hostnamectl set-hostname &lt;new-hostname&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-Linux查看内存的命令是什么？"><a href="#4-Linux查看内存的命令是什么？" class="headerlink" title="4. Linux查看内存的命令是什么？"></a>4. Linux查看内存的命令是什么？</h4><p><strong>查看内存使用情况的指令</strong>：<strong>free命令</strong>。“<strong>free -m</strong>”，命令查看内存使用情况。</p>
<ul>
<li><strong>free</strong>命令会<strong>显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等</strong>。</li>
</ul>
<p>查看进程运行状态、查看内存使用情况的指令均可使用<strong>top指令</strong>。</p>
<ul>
<li><strong>top</strong>命令会<strong>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</strong>。</li>
</ul>
<h4 id="5-Linux中，如何通过端口查进程，如何通过进程查端口？"><a href="#5-Linux中，如何通过端口查进程，如何通过进程查端口？" class="headerlink" title="5. Linux中，如何通过端口查进程，如何通过进程查端口？"></a>5. Linux中，如何通过端口查进程，如何通过进程查端口？</h4><ol>
<li><strong>linux下通过进程名查看其占用端口</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先查看进程pid</span><br><span class="line">ps -ef | grep 进程名</span><br><span class="line"></span><br><span class="line"># 再通过pid查看占用端口</span><br><span class="line">netstat -nap | grep 进程pid</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>linux通过端口查看进程</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nap | grep 端口号</span><br></pre></td></tr></table></figure>



<h4 id="6-【Linux服务器怎么部署项目？（以部署Tomcat为例）】"><a href="#6-【Linux服务器怎么部署项目？（以部署Tomcat为例）】" class="headerlink" title="6. 【Linux服务器怎么部署项目？（以部署Tomcat为例）】"></a>6. 【Linux服务器怎么部署项目？（以部署Tomcat为例）】</h4><ul>
<li><strong>tomcat部署(前后端不分离)：</strong></li>
</ul>
<p>1、安装xsheel和xftp。</p>
<p>2、安装环境（jdk,tomcat、数据库）。</p>
<p>3、防火墙配置tomcat端口允许外界访问。</p>
<p>4、测试外界能否通过tomcat访问。</p>
<p>5、本地代码数据库连接修改成linux上面的url连接。</p>
<p>6、代码打包（jar或者war）</p>
<p>7、xftp上传war</p>
<p>8、xsheet重启tomcat服务。</p>
<p>9、调试让系统能够正常访问不报错。</p>
<p>10、完成。</p>
<ul>
<li><strong>ngnix+jre部署（前后端分离）：</strong></li>
</ul>
<p>1、安装xsheel和xftp。</p>
<p>2、安装环境（jdk,tomcat、数据库、ngnix（反向代理等等配置））。</p>
<p>3、防火墙配置ngnix端口允许外界访问。</p>
<p>4、测试外界能否通过ngnix访问。</p>
<p>5、本地代码数据库连接修改成linux上面的url连接。</p>
<p>6、代码打包（前端和后端）</p>
<p>7、xftp上传打包代码、前端放在ngnix里面、后端随便放一个位置。</p>
<p>8、重启ngnix，运行后端java -jar ***.jar</p>
<p>9、调试让系统能够正常访问不报错。</p>
<p>10、完成。</p>
<h4 id="6-进程与线程的区别？"><a href="#6-进程与线程的区别？" class="headerlink" title="6. 进程与线程的区别？"></a>6. 进程与线程的区别？</h4><p><strong>调度</strong>：进程是资源管理的基本单位，一个进程可以有多个线程，线程是程序执行的基本单位。<br><strong>切换</strong>：线程上下文切换比进程上下文切换要快得多。<br><strong>拥有资源</strong>： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。<br><strong>系统开销</strong>： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</p>
<h4 id="7-协程与线程的区别"><a href="#7-协程与线程的区别" class="headerlink" title="7. 协程与线程的区别"></a>7. 协程与线程的区别</h4><h5 id="7-1-什么是协程？"><a href="#7-1-什么是协程？" class="headerlink" title="7.1 什么是协程？"></a>7.1 什么是协程？</h5><p>协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<h5 id="7-2-为什么协程比线程切换的开销小？"><a href="#7-2-为什么协程比线程切换的开销小？" class="headerlink" title="7.2 为什么协程比线程切换的开销小？"></a>7.2 为什么协程比线程切换的开销小？</h5><p>（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的<strong>切换非常快</strong>，切换开销比线程更小。</p>
<p>（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。<strong>避免了加锁解锁的开销。</strong></p>
<h4 id="8-并行和并发的区别"><a href="#8-并行和并发的区别" class="headerlink" title="8. 并行和并发的区别"></a>8. 并行和并发的区别</h4><p><strong>并发</strong>就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p>
<p><strong>并行</strong>就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p>
<h4 id="9-进程与线程的切换流程"><a href="#9-进程与线程的切换流程" class="headerlink" title="9. 进程与线程的切换流程"></a>9. 进程与线程的切换流程</h4><p>进程切换分两步：</p>
<ol>
<li><p>切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。</p>
</li>
<li><p>切换内核栈和硬件上下文。（时间片算法）</p>
</li>
</ol>
<p>线程和进程的最大区别就在于<strong>地址空间</strong>！<br>对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<h5 id="9-1-进程切换为什么比线程更消耗资源？（为什么虚拟地址空间切换会比较耗时？）"><a href="#9-1-进程切换为什么比线程更消耗资源？（为什么虚拟地址空间切换会比较耗时？）" class="headerlink" title="9.1 进程切换为什么比线程更消耗资源？（为什么虚拟地址空间切换会比较耗时？）"></a>9.1 进程切换为什么比线程更消耗资源？（为什么虚拟地址空间切换会比较耗时？）</h5><p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB。</p>
<p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而<strong>线程切换则不会导致TLB失效，因为线程无需切换地址空间</strong>，因此我们通常说线程切换要比进程切换快，原因就在这里。</p>
<h4 id="10-进程间通信方式有哪些及其优缺点"><a href="#10-进程间通信方式有哪些及其优缺点" class="headerlink" title="10. 进程间通信方式有哪些及其优缺点"></a>10. 进程间通信方式有哪些及其优缺点</h4><p><strong>通信方式种类：</strong></p>
<ul>
<li><p><strong>管道</strong>：管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
</li>
<li><p><strong>信号</strong>： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>
</li>
<li><p><strong>信号量</strong>：信号量是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p><strong>消息队列</strong>：消息队列是消息的链接表，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p><strong>共享内存</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p><strong>Socket</strong>：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ul>
<p><strong>各种通信方式的优缺点：</strong></p>
<ul>
<li><strong>管道</strong>：速度慢，容量有限，半双工通信，只在父子进程间使用；</li>
<li><strong>Socket</strong>：任何进程间都能通讯，但速度慢；</li>
<li><strong>消息队列</strong>：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</li>
<li><strong>信号量</strong>：不能传递复杂消息，只能用来同步；</li>
<li><strong>共享内存</strong>：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li>
</ul>
<h4 id="11-进程间互斥同步方式有哪些及其优缺点"><a href="#11-进程间互斥同步方式有哪些及其优缺点" class="headerlink" title="11. 进程间互斥同步方式有哪些及其优缺点"></a>11. 进程间互斥同步方式有哪些及其优缺点</h4><ol>
<li><strong>临界区</strong>：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<ul>
<li>优点：保证在某一时刻只有一个线程能访问数据的简便办法。</li>
<li>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</li>
</ul>
</li>
<li><strong>互斥量</strong>：为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。<ul>
<li>优点：使用互斥不仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</li>
<li>缺点：互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多。</li>
</ul>
</li>
<li><strong>信号量</strong>：为控制一个具有有限数量用户的资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。<ul>
<li>优点：适用于对Socket程序中线程的同步。</li>
<li>缺点：信号量机制必须有公共内存，不能用于分布式操作系统；信号量读写和维护困难，不易控制和管理。</li>
</ul>
</li>
<li><strong>事件</strong>：用来通知线程有一些事件已发生，从而启动后继任务的开始。<ul>
<li>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</li>
</ul>
</li>
</ol>
<h4 id="12-线程同步的方式有哪些？"><a href="#12-线程同步的方式有哪些？" class="headerlink" title="12. 线程同步的方式有哪些？"></a>12. 线程同步的方式有哪些？</h4><ol>
<li><strong>临界区</strong>：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操 作共享资源的目的。 </li>
<li><strong>事件</strong>：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。 </li>
<li><strong>互斥量</strong>：互斥对象和临界区对象非常相似，只是其允许在不同进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。 </li>
<li><strong>信号量</strong>：当需要一个计数器来<strong>限制可以使用某共享资源的线程数目</strong>时，可以使用“信号量”对象</li>
</ol>
<h4 id="13-线程的分类"><a href="#13-线程的分类" class="headerlink" title="13. 线程的分类"></a>13. 线程的分类</h4><p>从线程的运行空间划分，分为用户级线程和内核级线程：</p>
<p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。</p>
<p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是不依赖于操作系统核心的。应用进程利用线程库来完成其创建和管理，速度比较快，操作系统内核无法感知用户级线程的存在。</p>
<h4 id="14-什么是临界区，如何解决冲突？"><a href="#14-什么是临界区，如何解决冲突？" class="headerlink" title="14. 什么是临界区，如何解决冲突？"></a>14. 什么是临界区，如何解决冲突？</h4><p><strong>临界区</strong>：每个进程中访问临界资源的那段程序；<br><strong>临界资源</strong>：一次仅允许一个进程使用的资源；</p>
<p><strong>解决冲突的办法</strong>：<br>1、如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；<br>2、进入临界区的进程要在<strong>有限时间内退出</strong>。<br>3、如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</p>
<h4 id="15-什么是死锁？死锁产生的条件是什么？如何处理死锁问题？"><a href="#15-什么是死锁？死锁产生的条件是什么？如何处理死锁问题？" class="headerlink" title="15. 什么是死锁？死锁产生的条件是什么？如何处理死锁问题？"></a>15. 什么是死锁？死锁产生的条件是什么？如何处理死锁问题？</h4><p><strong>死锁概念</strong>：在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是<strong>两个或多个进程无限期的阻塞、相互等待的一种状态</strong>。</p>
<p><strong>死锁产生的四个必要条件（有一个条件不成立，则都不会产生死锁）</strong>：<br>1、互斥条件：一个资源一次只能被一个进程使用；<br>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放；<br>3、不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺；<br>4、循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系；</p>
<p><strong>如何让处理死锁问题：</strong><br>1、鸵鸟算法<br>2、检测死锁并且恢复<br>3、仔细的对资源进行动态分配以避免死锁<br>4、破除死锁四个必要条件之一来防止死锁产生</p>
<h4 id="16-进程调度策略有哪几种？"><a href="#16-进程调度策略有哪几种？" class="headerlink" title="16. 进程调度策略有哪几种？"></a>16. 进程调度策略有哪几种？</h4><p>1、<strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。这种调度方式有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。</p>
<hr>
<p>2、<strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。这种调度方式下长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<hr>
<p>3、<strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<hr>
<p>4、<strong>时间片轮转</strong>：将所有就绪进程按<strong>先来先服务</strong>的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给递进到队首的进程。</p>
<hr>
<p>5、<strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="17-进程有哪些状态以及状态之间如何转换？"><a href="#17-进程有哪些状态以及状态之间如何转换？" class="headerlink" title="17. 进程有哪些状态以及状态之间如何转换？"></a>17. 进程有哪些状态以及状态之间如何转换？</h4><p>进程五种状态：创建、就绪、运行、终止、阻塞；</p>
<p><strong>运行态</strong>：进程正在CPU上运行。<br><strong>就绪态</strong>：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到CPU即可运行。<br><strong>阻塞态</strong>：进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待I/O完成。即使CPU空闲，该进程也不能运行。</p>
<p>进程状态切换如下：</p>
<p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。<br><strong>阻塞态→就绪态</strong>：即等待的条件已满足，只需分配到处理器后就能运行。<br><strong>运行态→就绪态</strong>：不是由于自身原因，而是由于外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。<br><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p>
<h4 id="18-分页和分段"><a href="#18-分页和分段" class="headerlink" title="18. 分页和分段"></a>18. 分页和分段</h4><h5 id="18-1-什么是分页？"><a href="#18-1-什么是分页？" class="headerlink" title="18.1 什么是分页？"></a>18.1 什么是分页？</h5><p>把内存空间划分为大小相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此<strong>需要一个页表来记录映射关系，以实现从页号到物理块号的映射</strong>。 </p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> ：一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据。</p>
<h5 id="18-2-什么是分段？"><a href="#18-2-什么是分段？" class="headerlink" title="18.2 什么是分段？"></a>18.2 什么是分段？</h5><p>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<h5 id="18-3-分页和分段的区别"><a href="#18-3-分页和分段的区别" class="headerlink" title="18.3 分页和分段的区别"></a>18.3 分页和分段的区别</h5><ol>
<li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。 </li>
<li>分页的地址空间是一维地址空间，分段是二维的。 </li>
<li>页的大小不可变，段的大小可以动态改变。 </li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ol>
<h4 id="19-什么是交换空间？"><a href="#19-什么是交换空间？" class="headerlink" title="19. 什么是交换空间？"></a>19. 什么是交换空间？</h4><p><strong>交换空间概念：</strong>操作系统把物理内存分成一块一块的小内存，每一块内存被称为页。当内存资源不足时，Linux把某些页的内容转移至硬盘上的一块空间上以释放内存空间。<strong>硬盘上的那块空间就叫做交换空间，而这一过程被称为交换。</strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</p>
<p><strong>交换空间用途：</strong></p>
<ol>
<li>物理内存不足时一些不常用的页可以被交换出去，腾出内存空间。</li>
<li>程序启动时很多内存页被用来初始化，之后便不再需要，这些内存页可以被交换出去。</li>
</ol>
<h4 id="20-什么是虚拟内存？"><a href="#20-什么是虚拟内存？" class="headerlink" title="20. 什么是虚拟内存？"></a>20. 什么是虚拟内存？</h4><p><strong>虚拟内存：</strong>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，<strong>让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程</strong>，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>
<h4 id="21-什么是IO多路复用？"><a href="#21-什么是IO多路复用？" class="headerlink" title="21. 什么是IO多路复用？"></a>21. 什么是IO多路复用？</h4><p>IO多路复用：是一种同步IO模型，<strong>实现一个线程可以监视多个文件句柄</strong>； 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作； 没有文件句柄就绪就会阻塞应用程序，交出CPU，多路是指网络连接，复用指的是同一个线程；</p>
<p><strong>IO多路复用适用如下场合：</strong></p>
<p>1、当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。<br>2、当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。<br>3、如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。<br>4、如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。<br>5、如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。<br>6、与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h4 id="22-中断的处理过程"><a href="#22-中断的处理过程" class="headerlink" title="22. 中断的处理过程"></a>22. 中断的处理过程</h4><ol>
<li><strong>保护现场</strong>：将当前执行程序的相关数据保存在寄存器中，然后入栈。 </li>
<li><strong>开中断</strong>：以便执行中断时能响应较高级别的中断请求。 </li>
<li><strong>中断处理</strong> 。</li>
<li><strong>关中断</strong>：保证恢复现场时不被新中断打扰 </li>
<li><strong>恢复现场</strong>：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li>
</ol>
<h5 id="22-1-中断和轮询的区别？"><a href="#22-1-中断和轮询的区别？" class="headerlink" title="22.1 中断和轮询的区别？"></a>22.1 中断和轮询的区别？</h5><p><strong>轮询</strong>：CPU对<strong>特定设备</strong>轮流询问。效率低等待时间长，且CPU利用率不高。</p>
<p><strong>中断</strong>：通过<strong>特定事件</strong>提醒CPU。但容易遗漏问题，CPU利用率不高。</p>
<h4 id="23-【谈谈你对自旋锁的理解】"><a href="#23-【谈谈你对自旋锁的理解】" class="headerlink" title="23. 【谈谈你对自旋锁的理解】"></a>23. 【谈谈你对自旋锁的理解】</h4><p><strong>自旋锁的定义</strong>：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采取加锁循环等待的机制被称为自旋锁。</p>
<p><strong>自旋锁有以下特点</strong></p>
<ul>
<li>用于临界区互斥</li>
<li>在任何时刻最多只能有一个执行单元获得锁</li>
<li>要求持有锁的处理器所占用的时间尽可能短</li>
<li>等待锁的线程进入忙循环</li>
</ul>
<p><strong>自旋锁存在的问题</strong></p>
<ul>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程一直处于循环等待消耗CPU。</li>
<li>无法满足等待时间最长的线程优先获取锁，这种非公平锁就会存在线程饥饿问题。</li>
</ul>
<p><strong>自旋锁的优点</strong></p>
<ul>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ul>
<p><strong>自旋锁与互斥锁的区别</strong></p>
<ul>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li><strong>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/05/Error%20creating%20bean%20with%20name%20%E2%80%98httpPutFormContentFilter%E2%80%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>记录一次上传代码到服务器后出现Error creating bean with name ‘httpPutFormContentFilter‘问题的错误解决方案</p>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>前几天在处理一个新的业务时复用了以前一个老项目的代码框架进行修改，但是在上传代码到测试环境运行时报了以下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error starting Tomcat context. Exception: org.springframework.beans.factory.BeanCreationException. </span><br><span class="line">Message: Error creating bean with name <span class="string">&#x27;httpPutFormContentFilter&#x27;</span> defined in <span class="keyword">class</span> <span class="title class_">path</span> resource</span><br></pre></td></tr></table></figure>

<p>我一看是Tomcat相关的问题，就去检查了代码中是否接口访问路径有冲突，当时找到了有两个Controller的访问url重复了，以为是这个问题，但是重新部署后问题也没有解决；</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>通过去Stack Overflow查找发现可能是以下两个原因导致的：</p>
<ol>
<li>启动类未加@SpringBootApplication；</li>
<li>引入依赖出错，或者重复引入依赖；</li>
</ol>
<p>最后我发现我的项目是在引入了spring-boot-starter-web的同时，又引入了spring-web重复依赖导致的，注释掉spring-web依赖后问题顺利解决；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.springframework&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>git merge 合并分支时遇上refusing to merge unrelated histories问题解决</title>
    <url>/2022/09/28/git%20merge%20%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E6%97%B6%E9%81%87%E4%B8%8Arefusing%20to%20merge%20unrelated%20histories%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>记录一次分支合并时遇上refusing to merge unrelated histories的解决方案</p>
<span id="more"></span>

<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>最近在开发一个项目时，想拉取master分支的代码先合并到本地的dev开发分支上，但是在合并分支时提示一个“refusing to merge unrelated histories”的错误，这是由于两个分支拥有不相关的提交历史所以被拒绝合并；</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>如果需要合并出现这种问题的分支，则可以在执行merge命令时指定一个–allow-unrelated-histories 参数，去允许合并具有不相关提交历史的开发分支；</p>
<p>例如：合并master分支到dev分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
</search>
