<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSM框架(Spring+SpringMVC+MyBatis)整合搭建步骤</title>
    <url>/2020/09/01/SSM%E6%A1%86%E6%9E%B6(Spring+SpringMVC+MyBatis)%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>因为 Spring MVC 是 Spring 框架中的一个子模块，所以 Spring 与 SpringMVC 之间不存在整合的问题，本质上SSM框架的整合只涉及 Spring 与 MyBatis 的整合，以及 Spring MVC 与 MyBatis 的整合。而各自整合的步骤如下：</p>
<span id="more"></span>

<h3 id="一、基本环境搭建"><a href="#一、基本环境搭建" class="headerlink" title="一、基本环境搭建"></a>一、基本环境搭建</h3><ol>
<li><p>新建一个Maven项目</p>
</li>
<li><p>在pom.xml中导入需要用到的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Servlet、JSP--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在pom.xml中添加Maven资源过滤，预防资源无法导出</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>建立基本目录结构（controller、dao、service、pojo）</p>
</li>
<li><p>配置框架</p>
<ul>
<li>Mybatis 配置文件 ：<strong>mybatis-config.xml</strong> </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 配置文件 ：<strong>applicationContext.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二、MyBatis层编写"><a href="#二、MyBatis层编写" class="headerlink" title="二、MyBatis层编写"></a>二、MyBatis层编写</h3><ol>
<li><p>数据库配置文件 ：<strong>database.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：MySQL 8.0以上的版本要配置时区，serverTimezone=GMT%2B8否则会有时区问题，并且驱动由&quot;com.mysql.jdbc.Driver&quot; 变为：&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用IDEA连接数据库</p>
</li>
<li><p>在pojo包下创建实体类（以Blog为例），使用lombok插件创建有参、无参构造器和getter、setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> String create_time;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写dao层接口及对应的Mapper.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mq.pojo.Blog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有的博客</span></span><br><span class="line">    List&lt;Blog&gt; <span class="title function_">queryAllBLog</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace:绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ssm.dao.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--绑定对应的方法，以及定义返回值类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllBLog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">                select * from firend_mq.blog</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>.编写 Mybatis 的核心配置文件，导入实体类和映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描pojo包下的实体类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ssm.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册mapper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Service层的接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BlogService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用dao层中的方法</span></span><br><span class="line">    <span class="keyword">private</span> BlogMapper blogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; <span class="title function_">queryAllBLog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blogMapper.queryAllBLog();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、Spring层编写"><a href="#三、Spring层编写" class="headerlink" title="三、Spring层编写"></a>三、Spring层编写</h3><ol>
<li><p>编写Spring整合Mybatis的相关的配置文件：<strong>spring-dao.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.关联数据库文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:database.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池的私有属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring IoC的依赖注入：<strong>spring-service.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service相关的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--将BlogServiceImpl注入到IOC容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;BlogServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ssm.service.BlogServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> 	<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四、SpringMVC层编写"><a href="#四、SpringMVC层编写" class="headerlink" title="四、SpringMVC层编写"></a>四、SpringMVC层编写</h3><ol>
<li><p>编写网络配置文件：<strong>web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册前端控制器DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--自定义配置文件位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--表示服务器Tomcat创建对象的顺序，数值越小创建对象的时间越早--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置编码过滤器CharacterEncodingFilter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置HiddenHttpMethodFilter过滤器--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置Session过期时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring MVC配置文件：<strong>spring-mvc.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2.静态资源默认servlet配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 3.开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ssm.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置ViewResolver视图解析器，也可以配置为Thymeleaf--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 根据需要还可以配置文件上传解析器、拦截器和异常处理器--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写Spring配置整合文件：<strong>applicationContext.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-service.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-mvc.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>至此SSM框架就整合完成！</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java web开发中的各种层作用理解</title>
    <url>/2020/09/03/Java%20web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B1%82%E5%8F%8A%E5%90%84%E8%87%AA%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般的项目模块中都有Dao层、Entity层、Service层、Controller层和View层，今天来分享一下个人对各层作用的理解；</p>
<span id="more"></span>

<h3 id="1、Dao层（持久层、数据访问层、Mapper层）"><a href="#1、Dao层（持久层、数据访问层、Mapper层）" class="headerlink" title="1、Dao层（持久层、数据访问层、Mapper层）"></a>1、Dao层（持久层、数据访问层、Mapper层）</h3><p><strong>功能</strong>：访问数据库，向数据库发送sql语句，完成数据的增删改查任务，实现数据的持久化，使用@Repository和@Mapper注解都可用于标注数据访问组件Dao层；</p>
<p>​        两个注解的区别：</p>
<ul>
<li>@Mapper注解是MyBatis的注解，用来说明这个是一个Mapper，对应的xxxMapper.xml就是来实现这个Mapper，在Sevice层使用@Autowired注解引用Dao层会报红但是不影响使用，这是因为@Autowired是Spring的注解，会提示找不到相应的bean，这里可以用JDK的注解@Resource替代@Autowired；</li>
<li>@Repository注解是Spring的注解，用来把当前类注册成一个bean，在Service层通常使用@Autowired注解引用Dao层，但需要在主要启动类配置@MapperScan注解；</li>
</ul>
<p><strong>使用流程</strong>：Dao层先要设计Dao接口，然后在配置文件中定义该接口的实现类，接着就可以在Service层调用Dao层的接口进行业务处理；</p>
<p><strong>个人理解</strong>：Dao层只是定义方法接口，然后在Service层的xxxServiceImpl实现类调用接口的方法，从而达到操作数据库的目的。Dao层对数据库进行数据持久化操作，方法语句主要是针对数据库实现的一些增删改查操作，在Mapper中的方法与xxxMapper.xml一一映射。</p>
<h3 id="2、Service层（业务逻辑层）"><a href="#2、Service层（业务逻辑层）" class="headerlink" title="2、Service层（业务逻辑层）"></a>2、Service层（业务逻辑层）</h3><p><strong>功能</strong>：用于实现操作的具体方法，包含了对页面操作模块的代码；</p>
<p><strong>个人理解</strong>：Service用于存放业务逻辑处理，不直接和数据库打交道，Service层是建立在DAO层之上的，同时又是在Controller层之下的，因而Service层应该既调用DAO层的接口进行实现，又要提供封装后的接口给Controller层的类来进行调用，它刚好处于一个中间层的位置，不仅有面向Controller层的接口也有对Dao层接口的实现方法，Dao层接口的实现方法在xxxServiceImpl文件中，标注@Service注解，把mapper和service进行整合封装Service层的业务逻辑；</p>
<h3 id="3、Controller层（表现层、控制层）"><a href="#3、Controller层（表现层、控制层）" class="headerlink" title="3、Controller层（表现层、控制层）"></a>3、Controller层（表现层、控制层）</h3><p><strong>功能</strong>：控制业务逻辑，负责具体业务模块流程的控制；</p>
<p><strong>个人理解</strong>：Controller层负责请求转发，接收页面过来的参数后传给Service层处理，接到返回值后再返回给页面。Controller层一般会和前端以json文件进行数据的交互， Controller层是前台数据的接收器，后台处理好的数据也是通过Controller层传递到前台进行显示的；xxxController上标注@RestController注解，具体方法上标注@RequestMapping注解或具体的@xxxMapping（Get、Post…）注解</p>
<h3 id="4、View层（视图层）"><a href="#4、View层（视图层）" class="headerlink" title="4、View层（视图层）"></a>4、View层（视图层）</h3><p><strong>功能</strong>：此层与Controller层联系紧密，需要协同开发。View层主要负责前台页面的展示</p>
<h3 id="5、Model层（Entity层、实体层）"><a href="#5、Model层（Entity层、实体层）" class="headerlink" title="5、Model层（Entity层、实体层）"></a>5、Model层（Entity层、实体层）</h3><p><strong>功能</strong>：与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供getter/setter方法，tostring方法，有参和无参构造器；</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的对象术语(PO/POJO/VO/BO/DAO/DTO)总结</title>
    <url>/2020/02/12/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚开始学习Java Web时接触到DAO和POJO还经常搞混，后来上网查才发现还不只有这两种对象，每一层的Java Bean有不同的称呼，于是试着结合网上的资料和一些个人的理解对Java中常用的一些对象进行总结。</p>
<span id="more"></span>

<h2 id="1-PO-persistant-object-持久化对象"><a href="#1-PO-persistant-object-持久化对象" class="headerlink" title="1. PO(persistant object) : 持久化对象"></a><strong>1. PO(persistant object) : 持久化对象</strong></h2><ol>
<li><p>可理解为DAO层中接收和返回的Java Bean，与数据库的数据结构形成一一对应的映射关系。</p>
</li>
<li><p>是数据库表中的记录在Java对象中的显示状态，一个PO对应一张数据库表，数据库表中的每个字段就对应PO的一个属性。</p>
</li>
</ol>
<h2 id="2-VO-value-object-值对象-view-object表现层对象"><a href="#2-VO-value-object-值对象-view-object表现层对象" class="headerlink" title="2. VO(value object) : 值对象 / view object表现层对象"></a><strong>2. VO(value object) : 值对象 / view object表现层对象</strong></h2><ol>
<li><p>可理解为View层中用于显示的Java Bean</p>
</li>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不和表对应（大部分情况是表所有字段集合的子集）。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的Web Service传输中，而VO用于界面的展示，也可以把DTO转化为VO提供给前台。</p>
</li>
</ol>
<h2 id="3-BO-business-object-业务对象"><a href="#3-BO-business-object-业务对象" class="headerlink" title="3. BO(business object) : 业务对象"></a><strong>3. BO(business object) : 业务对象</strong></h2><ol>
<li><p>可理解为Service层中接收和返回的Java Bean。</p>
</li>
<li><p>从业务模型的角度看，是封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从数据库中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ol>
<h2 id="4-POJO-plain-ordinary-java-object-简单无规则java对象"><a href="#4-POJO-plain-ordinary-java-object-简单无规则java对象" class="headerlink" title="4. POJO(plain ordinary java object) : 简单无规则java对象"></a><strong>4. POJO(plain ordinary java object) : 简单无规则java对象</strong></h2><ol>
<li><p>理解为各个层中接收和返回的Java Bean统称，实际上就是普通的Java Bean，POJO类中有属性和getter、setter方法，但是没有业务逻辑，可以作为支持业务逻辑的协助类。</p>
</li>
<li><p>是一个抽象的统一概念，可以当作简单的Java对象，也可以如下转化为PO、DTO、VO（或者说PO、DTO、VO是POJO的不同的具体阶段的名字）。</p>
</li>
<li><p>POJO持久化之后==〉PO</p>
</li>
<li><p>POJO传输过程中==〉DTO</p>
</li>
<li><p>POJO用作表示层==〉VO</p>
</li>
</ol>
<h2 id="5-DAO-data-access-object-数据访问对象"><a href="#5-DAO-data-access-object-数据访问对象" class="headerlink" title="5. DAO(data access object) : 数据访问对象"></a><strong>5. DAO(data access object) : 数据访问对象</strong></h2><ol>
<li><p>DAO负责将PO持久化到数据库，也负责将数据库查询的结果集映射为PO。</p>
</li>
<li><p>为业务层提供接口，此对象用于访问数据库（CRUD操作），通常和PO结合使用；DAO中包含了各种数据库的操作方法，通过它的方法，结合PO对数据库进行相关的操作，夹在业务逻辑与数据库资源中间，配合VO,，提供数据库的CRUD操作。</p>
</li>
</ol>
<h2 id="6-DTO-Data-Transfer-Object-数据传输对象"><a href="#6-DTO-Data-Transfer-Object-数据传输对象" class="headerlink" title="6. DTO (Data Transfer Object) : 数据传输对象"></a><strong>6. DTO (Data Transfer Object) : 数据传输对象</strong></h2><ol>
<li>可理解为Controller层中接收和返回的Java Bean</li>
<li>用于在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>举一个例子：比如一张表有100个字段，那么对应的PO就有100个属性，但View层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面进行显示，那此时它的身份就转为VO。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录三种实现方式比较</title>
    <url>/2021/10/03/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​            单点登录（Single Sign On, 简称SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。以百度为例，如果用户在百度贴吧登录过之后，当他访问百度知道时就无需再次登录即可使用服务，而百度贴吧和百度知道是百度公司旗下的两个不同的应用系统，那么就说明百度贴吧和百度知道之间实现了单点登录。</p>
<p>​            单点登录的实现方式有多种，下面来总结三种在学习过程中遇到过的实现方法：</p>
<span id="more"></span>

<h3 id="1-Session广播机制实现"><a href="#1-Session广播机制实现" class="headerlink" title="1. Session广播机制实现"></a>1. Session广播机制实现</h3><p>实现机制：参与集群的每个节点的Session状态都被复制到该集群中的其他所有节点上，无论何时，只要Session发生改变，Session数据都要重新被复制到其他节点上，由于每个节点都复制一份Session，当一个节点出现问题时其它节点可以接替它的工作，但是节点间进行Session复制同步会造成数据重复，占据大量的系统空间，整体性能随着集群节点数的增加而急剧下降，不适合多模块项目。</p>
<h3 id="2-Cookie-Redis实现"><a href="#2-Cookie-Redis实现" class="headerlink" title="2. Cookie+Redis实现"></a>2. Cookie+Redis实现</h3><p>实现机制：</p>
<p>(1)客户端第在集群某节点一次登录时，通过服务端产生cookie和一个与之对相应的session；<br>(2)将第一次登录产生的User对象(即登录所需信息)，以key-value的形式存储在Redis中，key存放按照一定规则生成的唯一随机值，value存储用户登录所需信息，并把生成的唯一随机值放到cookie中；<br>(3)当客户端再次该集群中访问另外需要登录操作的页面时，发送请求会带着cookie进行发送，将该客户端的cookie拿到Redis中根据key进行查询比对，如果存在，则视为已登录；</p>
<h3 id="3-token实现"><a href="#3-token实现" class="headerlink" title="3. token实现"></a>3. token实现</h3><p>实现机制：<br>(1)客户端第一次在集群中某模块登录时获取登录凭证（按照一定规则生成的字符串），把登录后的用户信息经过加密后包含到生成字符串中，并把字符串返回，字符串返回的方式有两种：</p>
<ul>
<li>可以把字符串通过cookie返回</li>
<li>把字符串通过地址栏返回</li>
</ul>
<p>(2)客户端再去访问集群中的其他模块，每次访问在地址栏都带着生成的字符串，在访问的模块中获取地址栏的字符串，根据字符串获取用户信息，如果可以获取到就登录；</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>难点记录</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL入门学习笔记</title>
    <url>/2020/02/03/MySQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是个人刚开始学习MySQL数据库时所记录的一些笔记，总结成十几章内容，包括基本增删改查操作语句，创建数据库，创建修改数据表，约束，视图，存储过程和函数，变量，流程控制和触发器等内容，适合刚开始接触数据库学习的小伙伴o(<em>￣▽￣</em>)ブ</p>
<span id="more"></span>

<h1 id="第-01-章-数据库概述"><a href="#第-01-章-数据库概述" class="headerlink" title="第 01 章 数据库概述"></a>第 01 章 数据库概述</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><ul>
<li>持久化(persistence)： 把数据保存到可掉电式存储设备中以供之后使用 。大多数情况下，特别是企</li>
</ul>
<p>业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以保存 ，而持久化的实现过程大多</p>
<p>通过各种关系数据库来完成。</p>
<ul>
<li>持久化的主要作用：将内存中的数据存储在关系型数据库中。</li>
</ul>
<h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2. 1 数据库的相关概念"></a>2. 1 数据库的相关概念</h3><ul>
<li><p>DB：数据库（Database），其本质是一个文件系统。它保存了一系列有组织的数据。</p>
</li>
<li><p>DBMS：数据库管理系统（Database Management System），是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</p>
</li>
<li><p>SQL：结构化查询语言（Structured Query Language）专门用来与数据库通信的语言。</p>
</li>
</ul>
<h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2. 2 数据库与数据库管理系统的关系"></a>2. 2 数据库与数据库管理系统的关系</h3><p>数据库管理系统(DBMS)可以管理多个数据库(DB)，为保存应用中实体的数据，在数据库创建会多个表以保存程序中实体用户的数据。</p>
<h2 id="3-RDBMS-与-非RDBMS"><a href="#3-RDBMS-与-非RDBMS" class="headerlink" title="3. RDBMS 与 非RDBMS"></a>3. RDBMS 与 非RDBMS</h2><h3 id="3-1-关系型数据库-RDBMS"><a href="#3-1-关系型数据库-RDBMS" class="headerlink" title="3.1 关系型数据库(RDBMS)"></a>3.1 关系型数据库(RDBMS)</h3><h4 id="3-1-1-实质"><a href="#3-1-1-实质" class="headerlink" title="3. 1. 1 实质"></a>3. 1. 1 实质</h4><ul>
<li><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。</p>
</li>
<li><p>关系型数据库以行(row)和列(column)的形式存储数据，这一系列的行和列被称为表(table)，一组表组成了一个库(database)。</p>
</li>
<li><p>关系型数据库，就是建立在关系模型基础上的数据库。</p>
</li>
<li><p>SQL 是关系型数据库的查询语言。</p>
</li>
</ul>
<h4 id="3-1-2-优势"><a href="#3-1-2-优势" class="headerlink" title="3. 1. 2 优势"></a>3. 1. 2 优势</h4><ul>
<li><p>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
</li>
<li><p>事务支持：使得对于安全性能很高的数据访问要求得以实现。</p>
</li>
</ul>
<h3 id="3-2-非关系型数据库-非RDBMS"><a href="#3-2-非关系型数据库-非RDBMS" class="headerlink" title="3. 2 非关系型数据库(非RDBMS)"></a>3. 2 非关系型数据库(非RDBMS)</h3><h4 id="非关系型数据库种类"><a href="#非关系型数据库种类" class="headerlink" title="非关系型数据库种类"></a>非关系型数据库种类</h4><ol>
<li><p>键值型数据库</p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，就会消耗大量的计算。键值型数据库典型的使用场景是作为内存缓存。Redis是最流行的键值型数据库。</p>
</li>
<li><p>文档型数据库</p>
<p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。</p>
</li>
<li><p>搜索引擎数据库</p>
<p>搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。典型产品有Solr、Elasticsearch、Splunk 等。</p>
</li>
<li><p>列式数据库</p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足之处在于功能相对有限。典型产品有HBase等。</p>
</li>
<li><p>图形数据库</p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。图形数据库就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。典型产品有Neo4J、InfoGrid等。</p>
</li>
</ol>
<h1 id="第-02-章-SELECT语句"><a href="#第-02-章-SELECT语句" class="headerlink" title="第 02 章 SELECT语句"></a>第 02 章 SELECT语句</h1><h2 id="1-基本SELECT语句"><a href="#1-基本SELECT语句" class="headerlink" title="1. 基本SELECT语句"></a>1. 基本SELECT语句</h2><h3 id="1-1-SELECT-…-FROM-…"><a href="#1-1-SELECT-…-FROM-…" class="headerlink" title="1. 1 SELECT … FROM …"></a>1. 1 SELECT … FROM …</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span> 标识从哪个表中选择</span><br></pre></td></tr></table></figure>
<p>选择全部列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<h3 id="1-2-列的别名"><a href="#1-2-列的别名" class="headerlink" title="1. 2 列的别名"></a>1. 2 列的别名</h3><p><strong>别名使用方法</strong>：紧跟列名，也可以 在列名和别名之间加入关键字<strong>AS</strong>，别名使用双引号 ，以便在别名中包含空格或特殊的字符并区分大小写。AS 可以省略，在实际使用时建议别名简短，见名知意；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> name, commission_pct comm</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-去除重复行"><a href="#1-3-去除重复行" class="headerlink" title="1. 3 去除重复行"></a>1. 3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行，在SELECT语句中使用关键字<strong>DISTINCT</strong>去除重复行；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>要注意的是：</p>
<ol>
<li><p>DISTINCT 需要放到所有列名的前面，否则会报错。</p>
</li>
<li><p>DISTINCT 其实是对后面所有列名的组合进行去重。</p>
</li>
</ol>
<h3 id="1-4-空值参与运算"><a href="#1-4-空值参与运算" class="headerlink" title="1. 4 空值参与运算"></a>1. 4 空值参与运算</h3><p>所有运算符或列值遇到null值，运算的结果都为null</p>
<p>值得注意的是，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0 ，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h3 id="1-5-查询常数"><a href="#1-5-查询常数" class="headerlink" title="1. 5 查询常数"></a>1. 5 查询常数</h3><ul>
<li><p>SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p>
</li>
<li><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
</li>
</ul>
<h2 id="2-过滤数据"><a href="#2-过滤数据" class="headerlink" title="2. 过滤数据"></a>2. 过滤数据</h2><p>语法：使用<strong>WHERE子句</strong>，将不满足条件的行过滤掉，WHERE子句紧随 FROM子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段 <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 过滤条件</span><br></pre></td></tr></table></figure>


<h1 id="第-03-章-运算符"><a href="#第-03-章-运算符" class="headerlink" title="第 03 章 运算符"></a>第 03 章 运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。</p>
<ol>
<li>加法与减法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</p>
</li>
<li><p>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</p>
</li>
<li><p>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</p>
</li>
<li><p>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按 0 计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</p>
</li>
</ul>
<ol start="2">
<li>乘法与除法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个数乘以整数 1 和除以整数 1 后仍得原数；</p>
</li>
<li><p>一个数乘以浮点数 1 和除以浮点数 1 后变成浮点数，数值与原数相等；</p>
</li>
<li><p>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</p>
</li>
<li><p>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后 4 位；</p>
</li>
<li><p>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</p>
</li>
<li><p>在数学运算中， 0 不能用作除数，在MySQL中，一个数除以 0 为NULL。</p>
</li>
</ul>
<ol start="3">
<li>求模（求余）运算符</li>
</ol>
<h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1 ，比较的结果为假则返回 0 ，其他情况则返回NULL。比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<ol>
<li><p>等号运算符</p>
<p>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回 1 ，不相等则返回0 。</p>
<p>在使用等号运算符时，遵循如下规则：</p>
</li>
</ol>
<ul>
<li><p>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</p>
</li>
<li><p>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</p>
</li>
<li><p>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</p>
</li>
<li><p>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</p>
</li>
</ul>
<ol start="2">
<li><p>安全等于运算符</p>
<p>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，唯一的区别是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为 1 ，而不为NULL；当一个操作数为NULL时，其返回值为 0 ，而不为NULL。</p>
</li>
<li><p>不等于运算符 </p>
<p>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回 1 ，相等则返回 0 。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 </p>
</li>
<li><p>空运算符 </p>
<p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回 1 ，否则返回0 。</p>
</li>
<li><p>非空运算符 </p>
<p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回 1 ，否则返回 0 。 </p>
</li>
<li><p>最小值运算符 </p>
<p>语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>最大值运算符 </p>
<p>语法格式为：GREATEST(值 1 ，值 2 ，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>BETWEEN AND运算符 </p>
<p>BETWEEN运算符使用的格式通常为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D <span class="keyword">FROM</span> <span class="keyword">TABLE</span> </span><br><span class="line"><span class="keyword">WHERE</span> C <span class="keyword">BETWEEN</span> A <span class="keyword">AND</span> B</span><br></pre></td></tr></table></figure>

<p>此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0 。</p>
</li>
<li><p>IN运算符 </p>
<p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
</li>
<li><p>NOT IN运算符 </p>
<p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回 1 ，否则返回 0 。</p>
</li>
<li><p>LIKE运算符</p>
<p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回 1 ，否则返回0 。如果给定的值或者匹配条件为NULL，则返回结果为NULL。LIKE运算符通常与通配符一起使用。</p>
</li>
<li><p>REGEXP运算符</p>
<p>REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1 ；如果不满足，则返回 0 。若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
</li>
</ol>
<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为 1 、 0 或者NULL。</p>
<p>MySQL中支持 4 种逻辑运算符如下：</p>
<ol>
<li><p>逻辑非运算符 </p>
<p>逻辑非（NOT或!）运算符表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL。</p>
</li>
<li><p>逻辑与运算符 </p>
<p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL。</p>
</li>
<li><p>逻辑或运算符 </p>
<p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
</li>
</ol>
<p><strong>注意</strong>：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
<ol start="4">
<li><p>逻辑异或运算符 </p>
<p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1 。</p>
</li>
</ol>
<h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<ol>
<li><p>按位与运算符 </p>
<p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位或运算符 </p>
<p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位异或运算符 </p>
<p>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位取反运算符 </p>
<p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</p>
</li>
</ol>
<p><strong>注意</strong>：由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以 10 &amp; ~ 1 ，首先，对数字 1 进</p>
<p>行按位取反操作，结果除了最低位为 0 ，其他位都为 1 ，然后与 10 进行按位与操作，结果为 10 。</p>
<ol start="5">
<li><p>按位右移运算符 </p>
<p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。</p>
</li>
<li><p>按位左移运算符 按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐。</p>
</li>
</ol>
<h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p>结论：赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p>
<h1 id="第-04-章-排序与分页"><a href="#第-04-章-排序与分页" class="headerlink" title="第 04 章 排序与分页"></a>第 04 章 排序与分页</h1><h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1. 1 排序规则"></a>1. 1 排序规则</h3><p>使用 <strong>ORDER BY 子句</strong>进行排序，ASC（ascend）为升序，DESC（descend）为降序，ORDER BY 子句在SELECT语句的结尾。</p>
<h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1. 2 单列排序"></a>1. 2 单列排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例子如下：</span><br><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date ;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1. 3 多列排序"></a>1. 3 多列排序</h3><p>可以使用不在SELECT列表中的列排序。在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</p>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-分页规则"><a href="#2-1-分页规则" class="headerlink" title="2. 1 分页规则"></a>2. 1 分页规则</h3><p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。MySQL中使用 **LIMIT **实现分页，LIMIT 子句必须放在整个SELECT语句的最后！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT [位置偏移量],行数</span><br></pre></td></tr></table></figure>

<p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
<p><strong>举例</strong>：MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第 5 条记录开始后面的 3 条记录，和“LIMIT4,3;”返回的结果相同。</p>
<p><strong>分页显式公式</strong>：LIMIT（当前页数- 1 ）*每页条数，每页条数</p>
<p><strong>使用 LIMIT 的好处</strong>：约束返回结果的数量可以减少据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回；</p>
<h1 id="第-05-章-多表查询"><a href="#第-05-章-多表查询" class="headerlink" title="第 05 章 多表查询"></a>第 05 章 多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p><strong>前提条件</strong>：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<h2 id="1-笛卡尔积产生的问题"><a href="#1-笛卡尔积产生的问题" class="headerlink" title="1. 笛卡尔积产生的问题"></a>1. 笛卡尔积产生的问题</h2><h3 id="1-1-笛卡尔积（或交叉连接）的理解"><a href="#1-1-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1. 1 笛卡尔积（或交叉连接）的理解"></a>1. 1 笛卡尔积（或交叉连接）的理解</h3><ul>
<li><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p>
</li>
<li><p>SQL 92 中，笛卡尔积也称为交叉连接，英文是 CROSS JOIN。在 SQL 99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。</p>
</li>
</ul>
<h3 id="1-2-分析与问题解决"><a href="#1-2-分析与问题解决" class="headerlink" title="1. 2 分析与问题解决"></a>1. 2 分析与问题解决</h3><p>笛卡尔积的错误会在下面条件下产生 ：</p>
<ol>
<li><p>省略多个表的连接条件（或关联条件）</p>
</li>
<li><p>连接条件（或关联条件）无效</p>
</li>
<li><p>所有表中的所有行互相连接</p>
</li>
</ol>
<p>为了避免笛卡尔积， 可以 在 WHERE 加入有效的连接条件。加入连接条件后，查询语法如下：</p>
<p><strong>在 WHERE子句中写入连接条件，在表中有相同列时，在列名之前加上表名前缀</strong></p>
<h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类-1-：等值连接-vs-非等值连接"><a href="#分类-1-：等值连接-vs-非等值连接" class="headerlink" title="分类 1 ：等值连接 vs 非等值连接"></a>分类 1 ：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> table1.column <span class="number">1</span> <span class="operator">=</span> table2.column <span class="number">2</span> ;  #连接条件为等号即为等值连接</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>多个连接条件与 AND 操作符</p>
</li>
<li><p>区分重复的列名，当多个表中有相同列时，必须在列名之前加上表名前缀，在不同表中具有相同列名的列可以用表名加以区分。</p>
</li>
<li><p>使用表的别名可以简化查询，列名前使用表名前缀可以提高查询效率。但需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p>
</li>
<li><p>连接 n个表,至少需要n- 1 个连接条件。 比如，连接三个表，至少需要两个连接条件。</p>
</li>
</ol>
<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>一个用户查询请求涉及到多个表的时候，连接两个表的条件为=时，就是等值连接连接；其他的运算符连接的就是非等值连接。<br><strong>注意</strong>：连接条件中的各连接字段类型必须是可比的，但不必是相同的，整型和浮点型是可比的，但是字符型和整型就不可比。</p>
<h3 id="分类-2-：自连接-vs-非自连接"><a href="#分类-2-：自连接-vs-非自连接" class="headerlink" title="分类 2 ：自连接 vs 非自连接"></a>分类 2 ：自连接 vs 非自连接</h3><p>自连接就是当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询操作。</p>
<h3 id="分类-3-：内连接-vs-外连接"><a href="#分类-3-：内连接-vs-外连接" class="headerlink" title="分类 3 ：内连接 vs 外连接"></a>分类 3 ：内连接 vs 外连接</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行；</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
<ul>
<li><p>如果是左外连接，则连接条件中左边的表也称为主表，右边的表称为从表。</p>
</li>
<li><p>如果是右外连接，则连接条件中右边的表也称为主表，左边的表称为从表。</p>
</li>
</ul>
<h4 id="SQL-92-语法：使用-创建连接"><a href="#SQL-92-语法：使用-创建连接" class="headerlink" title="SQL 92 语法：使用(+)创建连接"></a>SQL 92 语法：使用(+)创建连接</h4><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接，而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p>
<p>下面是SQL92关于外连接的语法：(层次性和可读性不强不推荐使用)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="3-SQL-99-语法实现多表查询"><a href="#3-SQL-99-语法实现多表查询" class="headerlink" title="3. SQL 99 语法实现多表查询"></a>3. SQL 99 语法实现多表查询</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3. 1 基本语法"></a>3. 1 基本语法</h3><p>使用JOIN…ON子句创建连接的语法结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column,table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3. 2 内连接(INNER JOIN)的实现"></a>3. 2 内连接(INNER JOIN)的实现</h3><p><strong>语法说明</strong>：</p>
<ul>
<li><p>可以使用 ON 子句指定额外的连接条件 ，这个连接条件是与其它条件分开的，ON 子句使语句具有更高的易读性 ；</p>
</li>
<li><p>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接；</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3. 3 外连接(OUTER JOIN)的实现"></a>3. 3 外连接(OUTER JOIN)的实现</h3><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3. 3. 1 左外连接(LEFT OUTER JOIN)"></a>3. 3. 1 左外连接(LEFT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3. 3. 2 右外连接(RIGHT OUTER JOIN)"></a>3. 3. 2 右外连接(RIGHT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：LEFT JOIN 和 RIGHT JOIN 只存在于 SQL 99 及以后的标准中，在 SQL 92 中不存在，只能用 (+) 表示。</p>
<h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3. 3. 3 满外连接(FULL OUTER JOIN)"></a>3. 3. 3 满外连接(FULL OUTER JOIN)</h4><p>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
<p>SQL 99 是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</p>
<p><strong>需要注意的是</strong>：MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。</p>
<h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><p>合并查询结果 利用<strong>UNION</strong>关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p>
<h5 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UNION操作符：UNION 操作符返回两个查询的结果集的并集，并去除重复记录。</p>
</li>
<li><p>UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
</li>
</ul>
<p><strong>注意</strong>：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
<h2 id="5-SQL-99-语法新特性"><a href="#5-SQL-99-语法新特性" class="headerlink" title="5. SQL 99 语法新特性"></a>5. SQL 99 语法新特性</h2><h3 id="5-1-自然连接"><a href="#5-1-自然连接" class="headerlink" title="5. 1 自然连接"></a>5. 1 自然连接</h3><p>SQL 99 在 SQL 92 的基础上提供了一些特殊语法，比如<strong>NATURAL JOIN</strong>用来表示自然连接。我们可以把自然连接理解为 SQL 92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。</p>
<p>在SQL 92 标准中写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br></pre></td></tr></table></figure>

<p>在 SQL 99 中你可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-USING连接"><a href="#5-2-USING连接" class="headerlink" title="5. 2 USING连接"></a>5. 2 USING连接</h3><p>当我们进行连接的时候，SQL 99 还支持使用 <strong>USING</strong> 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br></pre></td></tr></table></figure>

<p>与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="6-章节小结"><a href="#6-章节小结" class="headerlink" title="6. 章节小结"></a>6. 章节小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p>
<ul>
<li><p>WHERE：适用于所有关联查询</p>
</li>
<li><p>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</p>
</li>
<li><p>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">where</span>后面</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">on</span>后面，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#把关联字段写在<span class="keyword">using</span>()中，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示<span class="operator">=</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs <span class="keyword">USING</span>(job_id);</span><br></pre></td></tr></table></figure>



<h1 id="第-06-章-聚合函数"><a href="#第-06-章-聚合函数" class="headerlink" title="第 06 章 聚合函数"></a>第 06 章 聚合函数</h1><p>区别于MySQL对单个值操作的单行函数，实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p>
<h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul>
<li><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p>
</li>
<li><p>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</p>
</li>
</ul>
<h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1. 1 AVG和SUM函数"></a>1. 1 AVG和SUM函数</h3><p>可以对数值型数据使用AVG 和 SUM 函数。</p>
<h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1. 2 MIN和MAX函数"></a>1. 2 MIN和MAX函数</h3><p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p>
<h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1. 3 COUNT函数"></a>1. 3 COUNT函数</h3><p>COUNT(*)返回表中记录总数，适用于任意数据类型 。COUNT(expr) 返回 expr不为空 的记录总数。</p>
<p><strong>问题1</strong>：用count(*)，count(1)，count(列名)谁好呢?</p>
<p>这取决于所用的引擎，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，好于具体的count(列名)。</p>
<p><strong>问题2</strong>：能不能使用count(列名)替换count(*)?</p>
<p>不要使用 count(列名)来替代 count(*)，count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2. 1 基本使用"></a>2. 1 基本使用</h3><p>可以使用<strong>GROUP BY子句</strong>将表中的数据分成若干组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2-2-GROUP-BY中使用WITH-ROLLUP"><a href="#2-2-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2. 2 GROUP BY中使用WITH ROLLUP"></a>2. 2 GROUP BY中使用WITH ROLLUP</h3><p>使用<strong>WITH ROLLUP</strong>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的。</p>
<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3. 1 基本使用"></a>3. 1 基本使用</h3><p>使用<strong>HAVING子句</strong>来过滤分组</p>
<p>使用情况如下：</p>
<ol>
<li><p>行已经被分组。</p>
</li>
<li><p>使用了聚合函数，注意不能在 WHERE 子句中使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span> <span class="number">10000</span> ;</span><br><span class="line"></span><br><span class="line"># 下面为错误的使用方法</span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure></li>
<li><p>满足HAVING 子句中条件的分组将被显示。</p>
</li>
<li><p>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</p>
</li>
</ol>
<h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3. 2 WHERE和HAVING的对比"></a>3. 2 WHERE和HAVING的对比</h3><p><strong>区别 1 ：</strong></p>
<ul>
<li><p>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；</p>
</li>
<li><p>HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</p>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p>
</li>
</ul>
<p><strong>区别 2 ：</strong></p>
<p>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p>
<p><strong>各自的优点与缺点：</strong></p>
<ul>
<li><p>WHERE 先筛选数据再关联，执行效率高，但不能使用分组中的计算函数进行筛选</p>
</li>
<li><p>HAVING 可以使用分组中的计算函数，在最后的结果集中进行筛选，但执行效率较低</p>
</li>
</ul>
<p><strong>开发中的参考选择：</strong></p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p>
<h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4. 1 查询的结构"></a>4. 1 查询的结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT .......</span><br><span class="line"></span><br><span class="line">#其中：</span><br><span class="line">#（ <span class="number">1</span> ）<span class="keyword">from</span>：从哪些表中筛选</span><br><span class="line">#（ <span class="number">2</span> ）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（ <span class="number">3</span> ）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（ <span class="number">4</span> ）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据</span><br><span class="line">#（ <span class="number">5</span> ）<span class="keyword">having</span>：在统计结果中再次筛选</span><br><span class="line">#（ <span class="number">6</span> ）<span class="keyword">order</span> <span class="keyword">by</span>：排序</span><br><span class="line">#（ <span class="number">7</span> ）limit：分页</span><br></pre></td></tr></table></figure>
<h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4. 2 SELECT执行顺序"></a>4. 2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p>
<ol>
<li><p>关键字的顺序是不能颠倒的，关键字顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT...</span><br></pre></td></tr></table></figure></li>
<li><p>SELECT 语句的执行顺序 （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
</li>
</ol>
<p>比如你写了一个 SQL 语句，那么它的执行顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> 的字段 <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num # 顺序 <span class="number">5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id # 顺序 <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> # 顺序 <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id # 顺序 <span class="number">3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> # 顺序 <span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> # 顺序 <span class="number">6</span></span><br><span class="line">LIMIT <span class="number">2</span> # 顺序 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h1 id="第-07-章-子查询"><a href="#第-07-章-子查询" class="headerlink" title="第 07 章 子查询"></a>第 07 章 子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询;</p>
<h2 id="1-子查询基本情况"><a href="#1-子查询基本情况" class="headerlink" title="1. 子查询基本情况"></a>1. 子查询基本情况</h2><h3 id="1-1-子查询的基本使用"><a href="#1-1-子查询的基本使用" class="headerlink" title="1. 1 子查询的基本使用"></a>1. 1 子查询的基本使用</h3><p><strong>子查询的基本语法结构例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>子查询（内查询）在主查询之前一次执行完成。子查询的结果被主查询（外查询）使用 。</p>
</li>
<li><p>子查询要包含在括号内将子查询放在比较条件的右侧，单行操作符对应单行子查询，多行操作符对应多行子查询。</p>
</li>
</ol>
<h3 id="1-2-子查询的分类"><a href="#1-2-子查询的分类" class="headerlink" title="1. 2 子查询的分类"></a>1. 2 子查询的分类</h3><p><strong>分类方式 1 ：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。</p>
<p><strong>分类方式 2 ：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为相关(或关联)子查询和不相关(或非关联)子查询。</p>
<ul>
<li>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</li>
</ul>
<ul>
<li>如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</li>
</ul>
<h2 id="2-多行子查询"><a href="#2-多行子查询" class="headerlink" title="2. 多行子查询"></a>2. 多行子查询</h2><p>多行子查询也称为集合比较子查询，内查询返回多行，使用多行比较操作符</p>
<h3 id="2-1-多行比较操作符"><a href="#2-1-多行比较操作符" class="headerlink" title="2. 1 多行比较操作符"></a>2. 1 多行比较操作符</h3><p>IN 等于列表中的 任意一个</p>
<p>ANY 需要和单行比较操作符一起使用，和子查询返回的 某一个 值比较</p>
<p>ALL 需要和单行比较操作符一起使用，和子查询返回的 所有 值比较</p>
<p>SOME 实际上是ANY的别名，作用相同，一般常使用ANY</p>
<h2 id="3-相关子查询"><a href="#3-相关子查询" class="headerlink" title="3. 相关子查询"></a>3. 相关子查询</h2><h3 id="3-1-相关子查询执行流程"><a href="#3-1-相关子查询执行流程" class="headerlink" title="3. 1 相关子查询执行流程"></a>3. 1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<ul>
<li><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p>
</li>
<li><p>在ORDER BY 中使用子查询：</p>
</li>
</ul>
<h3 id="3-2-EXISTS-与-NOT-EXISTS关键字"><a href="#3-2-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="3. 2 EXISTS 与 NOT EXISTS关键字"></a>3. 2 EXISTS 与 NOT EXISTS关键字</h3><p>关联子查询通常也会和 <strong>EXISTS</strong>操作符一起来使用，用来检查在子查询中是否存在满足条件的行。如果在子查询中不存在满足条件的行，条件返回 FALSE，继续在子查询中查找，如果在子查询中存在满足条件的行，不在子查询中继续查找，条件返回 TRUE；</p>
<p><strong>NOT EXISTS</strong>关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span></span><br><span class="line">e1.employee_id);</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是：</strong></p>
<p>当既可以使用子查询，也可以使用自连接时，一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h1 id="第-8-章-创建和管理表"><a href="#第-8-章-创建和管理表" class="headerlink" title="第 8 章 创建和管理表"></a>第 8 章 创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-标识符命名规则"><a href="#1-1-标识符命名规则" class="headerlink" title="1. 1 标识符命名规则"></a>1. 1 标识符命名规则</h3><ul>
<li><p>数据库名、表名不得超过 30 个字符，变量名限制为 29 个，必须只能包含 A–Z, a–z, 0 – 9 , _共 63 个字符</p>
</li>
<li><p>数据库名、表名、字段名等对象名中间不要包含空格</p>
</li>
<li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名，必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</p>
</li>
<li><p>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</p>
</li>
</ul>
<h3 id="1-2-MySQL中的数据类型"><a href="#1-2-MySQL中的数据类型" class="headerlink" title="1. 2 MySQL中的数据类型"></a>1. 2 MySQL中的数据类型</h3><p><strong>类型举例：</strong></p>
<ul>
<li><p>整数类型 TINYINT、SMALLINT、MEDIUMINT、 INT(或INTEGER) 、BIGINT</p>
</li>
<li><p>浮点类型 FLOAT、DOUBLE</p>
</li>
<li><p>定点数类型 DECIMAL</p>
</li>
<li><p>位类型 BIT</p>
</li>
<li><p>日期时间类型 YEAR、TIME、 DATE 、DATETIME、TIMESTAMP</p>
</li>
<li><p>文本字符串类型 CHAR、 VARCHAR 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</p>
</li>
<li><p>枚举类型 ENUM</p>
</li>
<li><p>集合类型 SET</p>
</li>
<li><p>二进制字符串类型BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</p>
</li>
<li><p>JSON类型 JSON对象、JSON数组</p>
</li>
<li><p>空间数据类型</p>
</li>
</ul>
<p>单值：GEOMETRY、POINT、LINESTRING、POLYGON；</p>
<p>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</p>
<p><strong>数据类型描述：</strong></p>
<ul>
<li><p>INT 从-2^31到2^31-1的整型数据。存储大小为 4 个字节</p>
</li>
<li><p>CHAR(size) 定长字符数据。若未指定，默认为 1 个字符，最大长度 255</p>
</li>
<li><p>VARCHAR(size) 可变长字符数据，根据字符串实际长度保存， 必须指定长度</p>
</li>
<li><p>FLOAT(M,D)单精度，占用 4 个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</p>
</li>
<li><p>DOUBLE(M,D) 双精度，占用 8 个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</p>
</li>
<li><p>DECIMAL(M,D)高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</p>
</li>
</ul>
<ul>
<li><p>DATE 日期型数据，格式’YYYY-MM-DD’</p>
</li>
<li><p>BLOB 二进制形式的长文本数据，最大可达4G</p>
</li>
<li><p>TEXT 长文本数据，最大可达4G</p>
</li>
</ul>
<h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2. 1 创建数据库"></a>2. 1 创建数据库</h3><p>方式 1 ：创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：创建数据库并指定字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br></pre></td></tr></table></figure>

<p>方式 3 ：判断数据库是否已经存在，不存在则创建数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p>
<h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2. 2 使用数据库"></a>2. 2 使用数据库</h3><p>查看当前所有的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure>

<p>查看当前正在使用的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure>

<p>查看指定库下所有的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>查看数据库的创建信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名\G</span><br></pre></td></tr></table></figure>

<p>使用/切换数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名”。</p>
<h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2. 3 修改数据库"></a>2. 3 修改数据库</h3><p>更改数据库字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure>

<h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2. 4 删除数据库"></a>2. 4 删除数据库</h3><p>方式 1 ：删除指定的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：判断数据库是否存在后再删除指定的数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="3-1-创建方式"><a href="#3-1-创建方式" class="headerlink" title="3. 1 创建方式"></a>3. 1 创建方式</h3><p><strong>语法格式：</strong></p>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
<p><strong>必须指定：</strong>表名、列名(或字段名)，数据类型， 长度</p>
<p><strong>可选指定：</strong>表约束条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">字段<span class="number">1</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">2</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">3</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">......</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-查看数据表结构"><a href="#3-2-查看数据表结构" class="headerlink" title="3. 2 查看数据表结构"></a>3. 2 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>

<h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。使用 ALTER TABLE 语句可以实现：</p>
<p>向已有的表中添加列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 【<span class="keyword">COLUMN</span>】 字段名 字段类型 【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名】;</span><br></pre></td></tr></table></figure>

<p>修改现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 【<span class="keyword">COLUMN</span>】 字段名 <span class="number">1</span> 字段类型 【<span class="keyword">DEFAULT</span> 默认值】【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名</span><br><span class="line"><span class="number">2</span> 】;</span><br></pre></td></tr></table></figure>

<p>删除现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 【<span class="keyword">COLUMN</span>】字段名</span><br></pre></td></tr></table></figure>

<p>重命名现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 【<span class="keyword">column</span>】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>

<h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><p>方式一：使用RENAME</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> emp</span><br><span class="line"><span class="keyword">TO</span> myemp;</span><br></pre></td></tr></table></figure>

<p>方式二：必须是对象的拥有者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> dept</span><br><span class="line">RENAME [<span class="keyword">TO</span>] detail_dept;  <span class="comment">-- [TO]可以省略</span></span><br></pre></td></tr></table></figure>

<h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><p>在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, ..., 数据表n];</span><br></pre></td></tr></table></figure>

<p>IF EXISTS的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<p><strong>注意：</strong>DROP TABLE 语句不能回滚</p>
<h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><p>TRUNCATE TABLE语句：删除表中所有的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 数据表;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚；</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h1 id="第-9-章-增删改语句"><a href="#第-9-章-增删改语句" class="headerlink" title="第 9 章 增删改语句"></a>第 9 章 增删改语句</h1><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-将数据插入表中"><a href="#1-1-将数据插入表中" class="headerlink" title="1. 1 将数据插入表中"></a>1. 1 将数据插入表中</h3><p>使用<strong>INSERT 语句</strong>向表中插入数据。</p>
<p><strong>方式 1 ：</strong>VALUES的方式添加，使用这种语法一次只能向表中插入一条数据。</p>
<p>情况 1 ：为表的所有字段按默认顺序插入数据，</p>
<ul>
<li>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,....);</span><br></pre></td></tr></table></figure>
<p>情况 2 ：为表的指定字段插入数据</p>
<ul>
<li><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
</li>
<li><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span> (value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>情况 3 ：同时插入多条记录</p>
<ul>
<li><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开</p>
<p>基本语法格式如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><p>VALUES也可以写成VALUE，但是VALUES是标准写法。</p>
</li>
<li><p>字符和日期型数据应包含在单引号中。</p>
</li>
</ul>
<h3 id="1-2-将查询结果插入到表中"><a href="#1-2-将查询结果插入到表中" class="headerlink" title="1. 2 将查询结果插入到表中"></a>1. 2 将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, ..., tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, ..., src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<p>在 INSERT 语句中加入子查询不必书写 VALUES 子句,子查询中的值列表应与 INSERT 子句中的列名对应。</p>
<h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p>使用 <strong>UPDATE 语句</strong>更新数据。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> 更新字段<span class="operator">=</span>更新值</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以一次更新多条数据。</p>
</li>
<li><p>如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;</p>
</li>
<li><p>使用 WHERE 子句指定需要更新的数据，如果省略 WHERE 子句，则表中的所有数据都将被更新。</p>
</li>
</ul>
<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><p>使用 <strong>DELETE 语句</strong>从表中删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p>
<p><strong>truncate table与delete table对比：</strong></p>
<p>相同点：都可以删除表中所有数据，同时保留表结构<br>不同点：truncate table清除全部表数据后不可回滚；delete table不带where时也清除全部表数据，同时数据可以回滚；</p>
<h1 id="第-10-章-约束"><a href="#第-10-章-约束" class="headerlink" title="第 10 章 约束"></a>第 10 章 约束</h1><h2 id="1-约束概述"><a href="#1-约束概述" class="headerlink" title="1. 约束概述"></a>1. 约束概述</h2><h3 id="1-1-什么是约束"><a href="#1-1-什么是约束" class="headerlink" title="1. 1 什么是约束"></a>1. 1 什么是约束</h3><p>约束是表级的强制规定。可以在 创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建后通过 ALTER TABLE 语句规定约束 。</p>
<h3 id="1-2-约束的分类"><a href="#1-2-约束的分类" class="headerlink" title="1. 2 约束的分类"></a>1. 2 约束的分类</h3><p>根据约束数据列的限制， 约束可分为：</p>
<ul>
<li><p>单列约束 ：每个约束只约束一列</p>
</li>
<li><p>多列约束 ：每个约束可约束多列数据</p>
</li>
</ul>
<p>根据约束的作用范围 ，约束可分为：</p>
<ul>
<li><p>列级约束 ：只能作用在一个列上，跟在列的定义后面</p>
</li>
<li><p>表级约束 ：可以作用在多个列上，不与列一起，而是单独定义</p>
</li>
</ul>
<p>根据约束起的作用 ，约束可分为：</p>
<ul>
<li><p>NOT NULL 非空约束，规定某个字段不能为空</p>
</li>
<li><p>UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的</p>
</li>
<li><p>PRIMARY KEY 主键(非空且唯一)约束</p>
</li>
<li><p>FOREIGN KEY 外键约束</p>
</li>
<li><p>CHECK 检查约束</p>
</li>
<li><p>DEFAULT 默认值约束</p>
</li>
</ul>
<p>**注意： **MySQL不支持check约束，但可以使用check约束，不过没有任何效果</p>
<h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2. 1 作用"></a>2. 1 作用</h3><p>限定某个字段/某列的值不允许为空</p>
<h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2. 2 关键字"></a>2. 2 关键字</h3><p>NOT NULL</p>
<h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2. 3 特点"></a>2. 3 特点</h3><ul>
<li><p>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</p>
</li>
<li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空，一个表可以有很多列都分别限定了非空</p>
</li>
<li><p>空字符串’不等于NULL， 0 也不等于NULL</p>
</li>
</ul>
<h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2. 4 添加非空约束"></a>2. 4 添加非空约束</h3><p>（1）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2. 5 删除非空约束"></a>2. 5 删除非空约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">NULL</span>;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br></pre></td></tr></table></figure>
<h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3. 1 作用"></a>3. 1 作用</h3><p>用来限制某个字段/某列的值不能重复。</p>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3. 2 关键字"></a>3. 2 关键字</h3><p>UNIQUE</p>
<h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3. 3 特点"></a>3. 3 特点</h3><ul>
<li><p>同一个表可以有多个唯一约束。</p>
</li>
<li><p>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</p>
</li>
<li><p>唯一性约束允许列值为空。</p>
</li>
<li><p>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</p>
</li>
<li><p>MySQL会给唯一约束的列上默认创建一个唯一索引。</p>
</li>
</ul>
<h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3. 4 添加唯一约束"></a>3. 4 添加唯一约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后指定唯一键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> key(字段列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 字段类型 <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3. 5 关于复合唯一约束"></a>3. 5 关于复合唯一约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">unique</span> key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-删除唯一约束"><a href="#3-6-删除唯一约束" class="headerlink" title="3. 6 删除唯一约束"></a>3. 6 删除唯一约束</h3><ul>
<li><p>添加唯一性约束的列上也会自动创建唯一索引，删除唯一约束只能通过删除唯一索引的方式删除。</p>
</li>
<li><p>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</p>
</li>
</ul>
<p><strong>注意：</strong>可以通过 show index from 表名称;查看表的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>; #查看都有哪些约束</span><br></pre></td></tr></table></figure>
<h2 id="4-PRIMARY-KEY-主键约束"><a href="#4-PRIMARY-KEY-主键约束" class="headerlink" title="4. PRIMARY KEY 主键约束"></a>4. PRIMARY KEY 主键约束</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4. 1 作用"></a>4. 1 作用</h3><p>用来唯一标识表中的一行记录。</p>
<h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4. 2 关键字"></a>4. 2 关键字</h3><p>primary key</p>
<h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4. 3 特点"></a>4. 3 特点</h3><ul>
<li><p>主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。</p>
</li>
<li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
</li>
<li><p>主键约束对应着表中的一列或者多列（复合主键），如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p>
</li>
<li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
<h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4. 4 添加主键约束"></a>4. 4 添加主键约束</h3><p>（ 1 ）建表时指定主键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key, #列级模式</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">primary</span> key(字段名) #表级模式</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后增加主键约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure>

<h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4. 5 关于复合主键"></a>4. 5 关于复合主键</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">primary</span> key(字段名<span class="number">1</span>,字段名<span class="number">2</span>)  #表示字段 <span class="number">1</span> 和字段 <span class="number">2</span> 的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4. 6 删除主键约束"></a>4. 6 删除主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
<h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5. 1 作用"></a>5. 1 作用</h3><p>某个字段的值自增</p>
<h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5. 2 关键字"></a>5. 2 关键字</h3><p>auto_increment</p>
<h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5. 3 特点和要求"></a>5. 3 特点和要求</h3><ul>
<li><p>一个表最多只能有一个自增长列</p>
</li>
<li><p>当需要产生唯一标识符或顺序值时，可设置自增长</p>
</li>
<li><p>自增长列约束的列必须是键列（主键列，唯一键列）</p>
</li>
<li><p>自增约束的列的数据类型必须是整数类型</p>
</li>
<li><p>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
</li>
</ul>
<h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5. 4 如何指定自增约束"></a>5. 4 如何指定自增约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,,</span><br><span class="line"><span class="keyword">primary</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br></pre></td></tr></table></figure>

<h3 id="5-5-删除自增约束"><a href="#5-5-删除自增约束" class="headerlink" title="5. 5 删除自增约束"></a>5. 5 删除自增约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure>

<h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6. 1 作用"></a>6. 1 作用</h3><p>限定某个表的某个字段的引用完整性。</p>
<h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6. 2 关键字"></a>6. 2 关键字</h3><p>FOREIGN KEY</p>
<h3 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6. 3 主表和从表/父表和子表"></a>6. 3 主表和从表/父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<p><strong>例子1：</strong>员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p>
<p><strong>例如2：</strong>学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p>
<h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6. 4 特点"></a>6. 4 特点</h3><p>（ 1 ）从表的外键列，必须引用/参考主表的主键或唯一约束的列，因为被依赖/被参考的值必须是唯一的</p>
<p>（ 2 ）在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名，也可以指定外键约束名。</p>
<p>（ 3 ）创建(CREATE)表时就指定外键约束的话，必须先创建主表，再创建从表</p>
<p>（ 4 ）删表时，先删从表（或先删除外键约束），再删除主表</p>
<p>（ 5 ）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p>
<p>（ 6 ）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p>
<p>（ 7 ）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。</p>
<p>（ 8 ） 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）</p>
<p>（ 9 ）删除外键约束后，必须手动删除对应的索引</p>
<h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6. 5 添加外键约束"></a>6. 5 添加外键约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表名称(</span><br><span class="line">字段 <span class="number">1</span> 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段 <span class="number">2</span> 数据类型,</span><br><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键约束名称<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY（从表的某个字段) <span class="keyword">references</span> 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line"><span class="comment">-- FOREIGN KEY: 在表级指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES: 标示在父表中的列</span></span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段);</span><br></pre></td></tr></table></figure>

<h3 id="6-6-删除外键约束"><a href="#6-6-删除外键约束" class="headerlink" title="6. 6 删除外键约束"></a>6. 6 删除外键约束</h3><p>流程如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span> )第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">（ <span class="number">2</span> ）第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称; #查看某个表的索引名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>
<h2 id="7-DEFAULT约束"><a href="#7-DEFAULT约束" class="headerlink" title="7. DEFAULT约束"></a>7. DEFAULT约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7. 1 作用"></a>7. 1 作用</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h3 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7. 2 关键字"></a>7. 2 关键字</h3><p>DEFAULT</p>
<h3 id="7-3-如何给字段加默认值"><a href="#7-3-如何给字段加默认值" class="headerlink" title="7. 3 如何给字段加默认值"></a>7. 3 如何给字段加默认值</h3><h5 id="（-1-）建表时"><a href="#（-1-）建表时" class="headerlink" title="（ 1 ）建表时"></a>（ 1 ）建表时</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line"><span class="keyword">primary</span> key(字段名),</span><br><span class="line"><span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure>

<h5 id="（-2-）建表后"><a href="#（-2-）建表后" class="headerlink" title="（ 2 ）建表后"></a>（ 2 ）建表后</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值</span><br></pre></td></tr></table></figure>
<h3 id="7-4-删除默认值约束"><a href="#7-4-删除默认值约束" class="headerlink" title="7. 4 删除默认值约束"></a>7. 4 删除默认值约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br></pre></td></tr></table></figure>

<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h1 id="第-11-章-视图"><a href="#第-11-章-视图" class="headerlink" title="第 11 章 视图"></a>第 11 章 视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><ul>
<li><p>表(TABLE)</p>
<p> 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</p>
</li>
<li><p>数据字典</p>
<p>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</p>
</li>
<li><p>约束(CONSTRAINT)</p>
<p>执行数据校验的规则，用于保证数据完整性的规则</p>
</li>
<li><p>视图(VIEW)</p>
<p> 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</p>
</li>
<li><p>索引(INDEX) </p>
<p>用于提高查询性能，相当于书的目录</p>
</li>
<li><p>存储过程(PROCEDURE)</p>
<p>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</p>
</li>
<li><p>存储函数(FUNCTION)</p>
<p>用于完成一次特定的计算，具有一个返回值</p>
</li>
<li><p>触发器(TRIGGER)</p>
<p>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</p>
</li>
</ul>
<h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2. 1 为什么使用视图？"></a>2. 1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p>
<h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2. 2 视图的理解"></a>2. 2 视图的理解</h3><ul>
<li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p>
</li>
<li><p>视图建立在已有表的基础上 , 视图赖以建立的这些表称为基表 。</p>
</li>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
</li>
<li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句</p>
</li>
<li><p>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</p>
</li>
<li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
</li>
</ul>
<h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><p>在 CREATE VIEW 语句中嵌入子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br></pre></td></tr></table></figure>
<p><strong>说明 1 ：</strong>实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形</p>
<p>成一张虚拟表。</p>
<p><strong>说明 2 ：</strong>在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字</p>
<p>段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法 1 ：查看数据库的表对象、视图对象</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>

<p>语法 2 ：查看视图的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 视图名称;</span><br></pre></td></tr></table></figure>

<p>语法 3 ：查看视图的属性信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>语法 4 ：查看视图的详细定义信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>

<h2 id="5-不可更新的视图"><a href="#5-不可更新的视图" class="headerlink" title="5. 不可更新的视图"></a>5. 不可更新的视图</h2><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li><p>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>视图定义基于一个不可更新视图；</p>
</li>
<li><p>常量视图。</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p>
</li>
</ul>
<p><strong>总结：</strong>虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图的数据。 对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p>
<h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6. 1 修改视图"></a>6. 1 修改视图</h3><p>方式 1 ：使用CREATE OR REPLACE VIEW 子句 修改视图</p>
<p><strong>注意：</strong>CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
<p>方式 2 ：ALTER VIEW</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6. 2 删除视图"></a>6. 2 删除视图</h3><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7. 1 视图优点"></a>7. 1 视图优点</h3><ol>
<li><p>操作简单</p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
</li>
<li><p>减少数据冗余</p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
</li>
<li><p>数据安全</p>
<p>MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， 用户不需要查询数据表，可以直接通过视图获取数据表中的信息 。这在一定程度上保障了数据表中数据的安全性。</p>
</li>
<li><p>适应灵活多变的需求</p>
<p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
</li>
<li><p>能够分解复杂的查询逻辑 </p>
<p>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
</li>
</ol>
<h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7. 2 视图不足"></a>7. 2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么， 如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h1 id="第-12-章-存储过程与函数"><a href="#第-12-章-存储过程与函数" class="headerlink" title="第 12 章 存储过程与函数"></a>第 12 章 存储过程与函数</h1><h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1. 1 理解"></a>1. 1 理解</h3><p><strong>含义 ：</strong>存储过程的英文是 Stored Procedure。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。</p>
<p><strong>执行过程：</strong>存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处 ：</strong></p>
<ol>
<li><p>简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </p>
</li>
<li><p>减少操作过程中的失误，提高效率</p>
</li>
<li><p>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </p>
</li>
<li><p>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p>
</li>
</ol>
<p><strong>和视图、函数的对比 ：</strong></p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1. 2 分类"></a>1. 2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<ol>
<li>没有参数（无参数无返回） </li>
<li>仅仅带 IN 类型（有参数无返回）</li>
<li>仅仅带 OUT 类型（无参数有返回） </li>
<li>既带 IN 又带 OUT（有参数有返回） </li>
<li>带 INOUT（有参数有返回）</li>
</ol>
<p><strong>注意：</strong>IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2. 1 语法分析"></a>2. 1 语法分析</h3><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span> 新的结束标记</span><br><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>参数前面的符号的意思</li>
</ol>
<ul>
<li><p>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认是 IN，表示输入参数。</p>
</li>
<li><p>OUT：当前参数为输出参数，也就是表示出参；执行完成后，调用这个存储过程客户端或者应用程序就可以读取这个参数返回值了。</p>
</li>
<li><p>INOUT：当前参数既可以为输入参数，也可以为输出参数。</p>
</li>
</ul>
<ol start="2">
<li><p>形参类型可以是 MySQL数据库中的任意类型。</p>
</li>
<li><p>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
</li>
</ol>
<ul>
<li><p>LANGUAGE SQL：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>
</li>
<li><p>[NOT] DETERMINISTIC：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。</p>
</li>
<li><p>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</p>
</li>
<li><p>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</p>
</li>
<li><p>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</p>
</li>
<li><p>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。默认情况下，系统会指定为CONTAINS SQL。</p>
</li>
<li><p>SQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
</li>
<li><p>DEFINER表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</p>
</li>
<li><p>INVOKER表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。如果没有设置相关的值，则MySQL默认指定值为DEFINER。</p>
</li>
<li><p>COMMENT ‘string’：注释信息，可以用来描述存储过程。</p>
</li>
</ul>
<ol start="4">
<li><p>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
</li>
<li><p>需要设置新的结束标记</p>
</li>
</ol>
<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p>
<p><strong>比如：</strong>“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p>
<h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><p>调用格式如下：</p>
<p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4. 1 语法分析"></a>4. 1 语法分析</h3><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><p>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p>
</li>
<li><p>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。</p>
</li>
<li><p>characteristic 创建函数时指定的对函数的约束。</p>
</li>
<li><p>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
</li>
</ol>
<h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4. 2 调用存储函数"></a>4. 2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。</p>
<h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5. 1 查看"></a>5. 1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍 3 种方法。</p>
<ol>
<li><p>使用SHOW CREATE语句查看存储过程和函数的创建信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure></li>
<li><p>使用SHOW STATUS语句查看存储过程和函数的状态信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">#[<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。 </span><br></pre></td></tr></table></figure></li>
<li><p>从information_schema.Routines表中查看存储过程和函数的信息</p>
</li>
</ol>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;];</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>如果在MySQL数据库中存在存储过程和函数名称相同情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
<h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5. 2 修改"></a>5. 2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<p><strong>注意：</strong>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
<h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5. 3 删除"></a>5. 3 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br><span class="line"># IF <span class="keyword">EXISTS</span>：如果程序或函数不存储，它可以防止发生错误，产生一个用<span class="keyword">SHOW</span> WARNINGS查看的警告。</span><br></pre></td></tr></table></figure>

<h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6. 1 优点"></a>6. 1 优点</h3><ol>
<li><p>存储过程可以一次编译多次使用。 存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
</li>
<li><p>可以减少开发工作量。 将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
</li>
<li><p>存储过程的安全性强。 我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</p>
</li>
<li><p>可以减少网络传输量。 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
</li>
<li><p>良好的封装性。 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
</li>
</ol>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6. 2 缺点"></a>6. 2 缺点</h3><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<ol>
<li><p>可移植性差。 存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
</li>
<li><p>调试困难。 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
</li>
<li><p>存储过程的版本管理很困难。 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
</li>
<li><p>它不适合高并发的场景。 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
</li>
</ol>
<h1 id="第-13-章-变量、流程控制与游标"><a href="#第-13-章-变量、流程控制与游标" class="headerlink" title="第 13 章 变量、流程控制与游标"></a>第 13 章 变量、流程控制与游标</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ul>
<li><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
</li>
<li><p>在 MySQL 数据库中，变量分为系统变量以及用户自定义变量。</p>
</li>
</ul>
<h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1. 1 系统变量"></a>1. 1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1. 1. 1 系统变量分类"></a>1. 1. 1 系统变量分类</h4><ul>
<li><p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数；</p>
</li>
<li><p>系统变量分为全局系统变量（需要添加global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 如果不写，默认为会话级别。 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
</li>
<li><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p>
</li>
<li><p>全局系统变量针对于所有会话（连接）有效，但不能跨重启，而会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值，但是会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</p>
</li>
</ul>
<h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1. 1. 2 查看系统变量"></a>1. 1. 2 查看系统变量</h4><p>查看所有或部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看指定系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure>

<p>作为 MySQL 编码规范，MySQL 中的系统变量以“**@@**”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
<h4 id="1-1-3修改系统变量"><a href="#1-1-3修改系统变量" class="headerlink" title="1.1.3修改系统变量"></a>1.1.3修改系统变量</h4><p>方式 1 ：修改MySQL配置文件，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式 2 ：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1. 2 用户变量"></a>1. 2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1. 2. 1 用户变量分类"></a>1. 2. 1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个“**@**”开头。根据作用范围不同，又分为会话用户变量和局部变量。</p>
<ul>
<li><p>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</p>
</li>
<li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</p>
</li>
</ul>
<h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1. 2. 2 会话用户变量"></a>1. 2. 2 会话用户变量</h4><p>作用域：<strong>针对于当前会话有效</strong>，可定义在会话的任何位置，等同于会话变量的作用域</p>
<ol>
<li>查看用户变量的值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>声明变量并初始化</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>赋值（更新用户变量的值）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1. 2. 3 局部变量"></a>1. 2. 3 局部变量</h4><p>定义：可以使用DECLARE语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的<strong>BEGIN … END 中</strong>有效，只能放在 BEGIN … END 中，而且只能放在第一句</p>
<ol>
<li>定义变量</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 [<span class="keyword">default</span> 值];  # 如果没有<span class="keyword">DEFAULT</span>子句，初始值为NULLBEGIN</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量赋值</li>
</ol>
<p>方式 1 ：一般用于赋简单的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：一般用于赋表中的字段值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure>

<p>3 .使用变量 （查看、比较、运算等)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>

<h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><p>只要是执行的程序，流程就分为三大类：</p>
<ul>
<li><p>顺序结构：程序从上往下依次执行</p>
</li>
<li><p>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</p>
</li>
<li><p>循环结构：程序满足一定条件下，重复执行一组语句</p>
</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li><p>条件判断语句：IF 语句和 CASE 语句</p>
</li>
<li><p>循环语句：LOOP、WHILE 和 REPEAT 语句</p>
</li>
<li><p>跳转语句：ITERATE 和 LEAVE 语句</p>
</li>
</ul>
<h3 id="2-1-分支结构之-IF"><a href="#2-1-分支结构之-IF" class="headerlink" title="2. 1 分支结构之 IF"></a>2. 1 分支结构之 IF</h3><p>IF 语句的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 表达式 <span class="number">1</span> <span class="keyword">THEN</span> 操作 <span class="number">1</span></span><br><span class="line">[ELSEIF 表达式 <span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]......</span><br><span class="line">[<span class="keyword">ELSE</span> 操作N]</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br><span class="line">#根据表达式的结果为<span class="literal">TRUE</span>或<span class="literal">FALSE</span>执行相应的语句。这里“[]”中的内容是可选的。</span><br></pre></td></tr></table></figure>

<p>特点：① 不同的表达式对应不同的操作  ② 使用在begin end中</p>
<h3 id="2-2-分支结构之-CASE"><a href="#2-2-分支结构之-CASE" class="headerlink" title="2. 2 分支结构之 CASE"></a>2. 2 分支结构之 CASE</h3><p>CASE 语句的语法结构 1 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构 2 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<h3 id="2-3-循环结构之LOOP"><a href="#2-3-循环结构之LOOP" class="headerlink" title="2. 3 循环结构之LOOP"></a>2. 3 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br><span class="line"></span><br><span class="line">#其中，loop_label表示LOOP语句的标注名称，该参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="2-4-循环结构之WHILE"><a href="#2-4-循环结构之WHILE" class="headerlink" title="2. 4 循环结构之WHILE"></a>2. 4 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br><span class="line"></span><br><span class="line"># while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环</span><br></pre></td></tr></table></figure>

<h3 id="2-5-循环结构之REPEAT"><a href="#2-5-循环结构之REPEAT" class="headerlink" title="2. 5 循环结构之REPEAT"></a>2. 5 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br><span class="line"></span><br><span class="line"># repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<ul>
<li>loop：一般用于实现简单的死循环</li>
<li>while：先判断后执行</li>
<li>repeat：先执行后判断，无条件至少执行一次</li>
</ul>
<h3 id="2-6-跳转语句之LEAVE语句"><a href="#2-6-跳转语句之LEAVE语句" class="headerlink" title="2. 6 跳转语句之LEAVE语句"></a>2. 6 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。可以把 LEAVE 理解为编程语句中的 break。</p>
<p>基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LEAVE label</span><br><span class="line"># 其中，label参数表示循环的标志。LEAVE和<span class="keyword">BEGIN</span> ... <span class="keyword">END</span>或循环一起被使用。</span><br></pre></td></tr></table></figure>

<h3 id="2-7-跳转语句之ITERATE语句"><a href="#2-7-跳转语句之ITERATE语句" class="headerlink" title="2. 7 跳转语句之ITERATE语句"></a>2. 7 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。可以把 ITERATE 理解为编程语句中的 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br><span class="line"># label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</span><br></pre></td></tr></table></figure>

<h2 id="3-游标"><a href="#3-游标" class="headerlink" title="3. 游标"></a>3. 游标</h2><h3 id="3-1-什么是游标"><a href="#3-1-什么是游标" class="headerlink" title="3. 1 什么是游标"></a>3. 1 什么是游标</h3><ul>
<li><p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。 游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</p>
</li>
<li><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。MySQL中游标可以在存储过程和函数中使用。</p>
</li>
</ul>
<h3 id="3-2-使用游标步骤"><a href="#3-2-使用游标步骤" class="headerlink" title="3. 2 使用游标步骤"></a>3. 2 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><em><strong>第一步，声明游标</strong></em></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。</p>
<p>如果是用 Oracle 或者 PostgreSQL，则需要写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。</p>
<p><strong>第二步，打开游标</strong></p>
<p>打开游标的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。</p>
<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>var_name必须在声明游标之前就定义好。</p>
</li>
<li><p>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 ，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
</li>
</ol>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源，如果不及时关闭， 游标会一直保持到存储过程结束 ，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<h1 id="第-14-章-触发器"><a href="#第-14-章-触发器" class="headerlink" title="第 14 章_触发器"></a>第 14 章_触发器</h1><h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><p>创建触发器的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br><span class="line"></span><br><span class="line"># 表名：表示触发器监控的对象。</span><br><span class="line"># BEFORE<span class="operator">|</span>AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</span><br><span class="line"># <span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>：表示触发的事件。</span><br><span class="line"># <span class="keyword">INSERT</span> 表示插入记录时触发；</span><br><span class="line"># <span class="keyword">UPDATE</span> 表示更新记录时触发；</span><br><span class="line"># <span class="keyword">DELETE</span> 表示删除记录时触发。</span><br></pre></td></tr></table></figure>

<p>触发器执行的语句块可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p>
<h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3. 1 查看触发器"></a>3. 1 查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式 1 ：查看当前数据库的所有触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：查看当前数据库中某个触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure>

<p>方式 3 ：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3. 2 删除触发器"></a>3. 2 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4. 1 优点"></a>4. 1 优点</h3><ol>
<li><p>触发器可以确保数据的完整性 。</p>
</li>
<li><p>触发器可以帮助我们记录操作日志。</p>
</li>
<li><p>触发器还可以用在操作数据前，对数据进行合法性检查。</p>
</li>
</ol>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4. 2 缺点"></a>4. 2 缺点</h3><ol>
<li>触发器最大的一个问题就是可读性差。</li>
</ol>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</p>
<ol start="2">
<li>相关数据的变更，可能会导致触发器出错。</li>
</ol>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程和JUC并发编程学习笔记</title>
    <url>/2021/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习多线程和并发编程时记录的笔记，仅涉及并发编程的基础知识</p>
<span id="more"></span>

<h2 id="1-JUC概述"><a href="#1-JUC概述" class="headerlink" title="1. JUC概述"></a>1. JUC概述</h2><h3 id="1-1-什么是JUC"><a href="#1-1-什么是JUC" class="headerlink" title="1.1 什么是JUC"></a>1.1 什么是JUC</h3><p>JUC就是java.util.concurrent工具包的简称，是Java中一个处理线程的工具包；</p>
<h3 id="1-2-线程和进程相关概念"><a href="#1-2-线程和进程相关概念" class="headerlink" title="1.2 线程和进程相关概念"></a>1.2 线程和进程相关概念</h3><h4 id="1-2-1-线程和进程"><a href="#1-2-1-线程和进程" class="headerlink" title="1.2.1 线程和进程"></a>1.2.1 线程和进程</h4><ul>
<li>进程：是系统进行资源分配和调度的基本单位，进程是程序的实体，同时也是线程的容器；</li>
<li>线程：是操作系统能够进行运算调度的最小单位，被包含在进程中，是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流，在一个进程中可以并发多个线程，每条线程并行执行不同的任务；</li>
</ul>
<h4 id="1-2-2-wait-和sleep-的区别"><a href="#1-2-2-wait-和sleep-的区别" class="headerlink" title="1.2.2 wait()和sleep()的区别"></a>1.2.2 wait()和sleep()的区别</h4><ul>
<li>相同点：一旦执行方法，都可以使得当前的进程进入阻塞状态；</li>
<li>不同点：<ol>
<li>两个方法声明的位置不同：Thread类中声明sleep()，Object类中声明wait()；</li>
<li>调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须在同步代码块或同步方法中调用；</li>
<li>关于是否释放同步监视器：如果两个方法都是用在同步代码块或同步方法中，sleep()不会释放，wait()会释放；</li>
</ol>
</li>
</ul>
<h4 id="1-2-3-notify-和notifyAll-区别"><a href="#1-2-3-notify-和notifyAll-区别" class="headerlink" title="1.2.3 notify()和notifyAll()区别"></a>1.2.3 notify()和notifyAll()区别</h4><ul>
<li>notify( )：一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的那个；</li>
<li>notifyAll( )：一旦执行此方法，就会唤醒所有被wait的线程；</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>这两个方法必须使用在同步代码块或同步方法中；</li>
<li>这两个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现异常；</li>
</ol>
<h4 id="1-2-4-线程状态"><a href="#1-2-4-线程状态" class="headerlink" title="1.2.4 线程状态"></a>1.2.4 线程状态</h4><p>线程在一定条件下状态会发生变化。线程一共有以下几种状态：</p>
<ol>
<li>**新建状态(New)**：新创建线程对象，如Thread thread = new Thread()。</li>
<li><strong>就绪状态(Runnable)<strong>：线程对象创建后，其他线程调用了thread.start()。该状态的线程位于“</strong>可运行线程池</strong>”中，变得可运行，只等待获取CPU的使用权<strong>。</strong>即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</li>
<li>**运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。</li>
<li>**阻塞状态(Blocked)**：线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</li>
</ol>
<ul>
<li><strong>阻塞的情况分三种：</strong><ul>
<li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“<strong>等待池”</strong>中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</li>
<li>同步阻塞：运行的线程在获取对象的synchronized同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入<strong>“锁池”</strong>中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>**死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h3 id="1-3-并发与并行"><a href="#1-3-并发与并行" class="headerlink" title="1.3 并发与并行"></a>1.3 并发与并行</h3><ul>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
</ul>
<h3 id="1-4-同步和异步"><a href="#1-4-同步和异步" class="headerlink" title="1.4 同步和异步"></a>1.4 同步和异步</h3><ul>
<li>同步：指发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 </li>
<li>异步：指发送方发出数据后，不等接收方发回响应，就直接接着发送下个数据包的通讯方式。</li>
</ul>
<h3 id="1-5-管程"><a href="#1-5-管程" class="headerlink" title="1.5 管程"></a>1.5 管程</h3><p>管程（Monitor，又称为监视器）即所说的锁，是一种同步机制，保证在同一个时间只有一个线程能去访问被保护的数据或者代码，JVM同步基于进入和退出，使用管程对象实现的，即加锁和解锁操作；</p>
<h3 id="1-6-用户线程和守护线程"><a href="#1-6-用户线程和守护线程" class="headerlink" title="1.6 用户线程和守护线程"></a>1.6 用户线程和守护线程</h3><ul>
<li><p>如果JVM中所有的线程都是守护线程，那么JVM就会退出，进而守护线程也会退出；如果JVM中还存在用户线程，那么JVM就会一直存活，不会退出。</p>
<ul>
<li>守护线程：依赖于用户线程，用户线程退出了，守护线程也就会退出，典型的守护线程如垃圾回收线程。</li>
<li>用户线程：是独立存在的，不会因为其他用户线程退出而退出。</li>
</ul>
</li>
</ul>
<h2 id="2-Lock接口（Lock锁）"><a href="#2-Lock接口（Lock锁）" class="headerlink" title="2. Lock接口（Lock锁）"></a>2. Lock接口（Lock锁）</h2><h3 id="2-1-Synchronized关键字"><a href="#2-1-Synchronized关键字" class="headerlink" title="2.1 Synchronized关键字"></a>2.1 Synchronized关键字</h3><ol>
<li><p>修饰一个代码块时，被修饰的代码块称为同步代码块，其作用的范围是大括号{}中的代码，作用的对象是这个代码块的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">synchronized</span> (同步监视器) &#123;</span><br><span class="line"> 	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：<span class="number">1.</span>操作共享数据的代码，即为需要被同步的代码；</span><br><span class="line">     <span class="number">2.</span>共享数据：多个线程共同操作的变量；</span><br><span class="line">     <span class="number">3.</span>同步监视器，俗称：锁，任何一个类的对象都能充当锁，但要求多个线程必须要共用同一把锁；</span><br><span class="line">补充：实现Runnable接口创建方式，锁可以考虑用实现类对象<span class="built_in">this</span>表示，此时的<span class="built_in">this</span>必须是唯一的实现类的对象；</span><br><span class="line">     在继承Thread类创建多线程的方式中，慎用<span class="built_in">this</span>充当同步监视器，考虑使用当前类充当同步监视器；  </span><br></pre></td></tr></table></figure></li>
<li><p>修饰一个方法时，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">权限修饰符 <span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名() &#123;</span><br><span class="line">    <span class="comment">//操作共享数据的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"><span class="number">1.</span>同步方法仍然涉及到同步监视器，只是不需要显式声明；</span><br><span class="line"><span class="number">2.</span>非静态同步方法，同步监视器是实现类对象：<span class="built_in">this</span></span><br><span class="line">  静态同步方法，同步监视器是当前类本身：类名.class</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-多线程编程步骤"><a href="#2-2-多线程编程步骤" class="headerlink" title="2.2 多线程编程步骤"></a>2.2 多线程编程步骤</h3><p>第一步：创建资源类，在资源类创建属性和操作方法；</p>
<p>第二步：在资源类操作方法</p>
<p>第三步：创建多个线程，调用资源类的操作方法；</p>
<p>第四步：判断条件写到while中防止虚假唤醒问题；</p>
<h3 id="2-3-Lock接口概述"><a href="#2-3-Lock接口概述" class="headerlink" title="2.3 Lock接口概述"></a>2.3 Lock接口概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="number">1.</span>实现类实例化可重入锁ReentrantLock属性：<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>( )</span><br><span class="line"><span class="number">2.</span>重写的run( )中调用锁定方法Lock( )，使后续的代码单线程实现</span><br><span class="line"><span class="number">3.</span>调用解锁方法unlock( )</span><br></pre></td></tr></table></figure>

<p><strong>Synchronized和Lock的区别：</strong></p>
<ul>
<li>相同点：二者都可以解决线程安全问题；</li>
<li>不同点：<ol>
<li>synchronized机制在执行完相应的同步代码后，自动地释放同步监视器，而Lock需要手动的启动同步（Lock( )），同时结束同步也需要手动的实现（unlock( )，建议在finally块中释放锁避免出现死锁；</li>
<li>synchronized是Java的关键字，而Lock是一个类，通过这个类可以实现同步访问；</li>
</ol>
</li>
</ul>
<h3 id="2-4-创建线程的多种方式"><a href="#2-4-创建线程的多种方式" class="headerlink" title="2.4 创建线程的多种方式"></a>2.4 创建线程的多种方式</h3><h4 id="2-4-1-继承Thread类"><a href="#2-4-1-继承Thread类" class="headerlink" title="2.4.1 继承Thread类"></a>2.4.1 继承Thread类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个继承于Thread类的子类；</span><br><span class="line"><span class="number">2.</span>重写Thread类的run( )，将此线程执行的操作声明在run( )中;</span><br><span class="line"><span class="number">3.</span>创建Thread类的子类的对象;</span><br><span class="line"><span class="number">4.</span>通过此对象调用start( );</span><br><span class="line">	① 启动当前线程；</span><br><span class="line">	② 调用当前线程的run( )方法 ;</span><br><span class="line"></span><br><span class="line">注意点：</span><br><span class="line"><span class="number">1.</span>我们不能通过直接调用run( )的方式启动线程，必须通过对象.start( )的方式；</span><br><span class="line"><span class="number">2.</span>再启动一个线程时，需要重新创建一个线程的对象去start( )执行；</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-实现Runnable接口"><a href="#2-4-2-实现Runnable接口" class="headerlink" title="2.4.2 实现Runnable接口"></a>2.4.2 实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个实现了Runnable接口的类；</span><br><span class="line"><span class="number">2.</span>实现类去实现Runnable中的抽象方法：run( )</span><br><span class="line"><span class="number">3.</span>创建实现类的对象；</span><br><span class="line"><span class="number">4.</span>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象；</span><br><span class="line"><span class="number">5.</span>通过Thread类的对象调用start( )，在start( )中调用了Runnable类型target的run( )</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用匿名内部类方式进行实现：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//大括号中调用具体方法</span></span><br><span class="line">&#125;).start(); </span><br></pre></td></tr></table></figure>

<p><strong>比较继承Thread类和实现Runnable接口这两种创建方式：</strong>两种方式都需要重写run( )，但开发中优先选择实现Runnable接口的方式<br><strong>原因：</strong></p>
<ol>
<li>实现的方式没有类的单继承性的局限性；</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况；</li>
</ol>
<h4 id="2-4-3-使用Callable接口（详情后续章节讲解）"><a href="#2-4-3-使用Callable接口（详情后续章节讲解）" class="headerlink" title="2.4.3 使用Callable接口（详情后续章节讲解）"></a>2.4.3 使用Callable接口（详情后续章节讲解）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line"><span class="number">1.</span>创建一个实现Callable的实现类；</span><br><span class="line"><span class="number">2.</span>实现call( )方法，将此线程需要执行的操作声明在call( )中，可以有返回值；</span><br><span class="line"><span class="number">3.</span>创建Callable接口实现类的对象；</span><br><span class="line"><span class="number">4.</span>将此Callable接口实现类的对象作为参数传递到FutureTask的构造器中，创建FutureTask的对象；</span><br><span class="line"><span class="number">5.</span>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start( )方法；</span><br><span class="line"><span class="number">6.</span>获取Callable中call方法的返回值，get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用匿名实现类方式进行实现：</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>(</span><br><span class="line">        () -&gt; <span class="keyword">return</span> 返回值</span><br><span class="line">    )).start(); </span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-使用ThreadPool线程池（详情后续章节讲解）"><a href="#2-4-4-使用ThreadPool线程池（详情后续章节讲解）" class="headerlink" title="2.4.4 使用ThreadPool线程池（详情后续章节讲解）"></a>2.4.4 使用ThreadPool线程池（详情后续章节讲解）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">步骤</span><br><span class="line"><span class="number">1.</span>提供指定线程数量的线程池</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(线程数量)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象；</span><br><span class="line">executorService.execute(实现类对象)：适用于Runnable接口</span><br><span class="line">executorService.submit(实现类对象)：适用于Callable接口</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭连接池</span><br><span class="line">executorService.shutdown( )；</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">使用线程池方法的好处：</span><br><span class="line"><span class="comment">//提前创建多个线程放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁，实现重复利用；</span></span><br><span class="line"><span class="number">1.</span>提高响应速度，减少创建新线程的时间</span><br><span class="line"><span class="number">2.</span>降低资源消耗（重读利用线程池中的线程，不需要每次都创建）</span><br><span class="line"><span class="number">3.</span>便于线程管理</span><br></pre></td></tr></table></figure>



<h2 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h2><p>线程间通信定义：当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。</p>
<h3 id="3-1-虚假唤醒问题"><a href="#3-1-虚假唤醒问题" class="headerlink" title="3.1 虚假唤醒问题"></a>3.1 虚假唤醒问题</h3><p><strong>概念：</strong>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功；</p>
<p><strong>解决方法：</strong>当有两个线程调用相同的方法时，线程唤醒调用了<code>notifyAll()</code>方法，会唤醒所有线程，这两条线程都会被唤醒，如果用<code>if</code>，因为<code>if</code>只会执行一次，这就会不进行条件判断直接执行下一步的代码，造成了线程虚假唤醒问题；如果用<code>while</code>，线程虽然被唤醒，但还是会进行循环判断直到满足才执行，就避免了线程虚假唤醒的问题；</p>
<h3 id="3-2-线程间通信方式"><a href="#3-2-线程间通信方式" class="headerlink" title="3.2 线程间通信方式"></a>3.2 线程间通信方式</h3><p>首先线程通信的模型主要可以分为两种，分别为<strong>共享内存</strong>和<strong>消息传递</strong>，以下方式都是基于这两种模型来实现的：</p>
<p>以一道实际题目为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">有两个线程A、B，A线程向一个集合里面依次添加元素&quot;abc&quot;字符串，一共添加十次，当添加到第五次的时候，希望B线程能够收到A线程的通知，然后B线程执行相关的业务操作。</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-共享内存"><a href="#3-2-1-共享内存" class="headerlink" title="3.2.1 共享内存"></a>3.2.1 共享内存</h4><p><strong>思路：</strong>线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信；</p>
<h5 id="方式一：使用volatile关键字"><a href="#方式一：使用volatile关键字" class="headerlink" title="方式一：使用volatile关键字"></a>方式一：使用volatile关键字</h5><p>基于<strong>volatile</strong> 关键字来实现线程间相互通信是使用<strong>共享内存</strong>的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个共享变量来实现通信，必须是volatile修饰的，否则线程不能及时感知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">notice</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//修改共享变量值</span></span><br><span class="line">                    notice = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (notice) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方式二：使用JUC中的类-CountDownLatch（详情后续章节讲解）"><a href="#方式二：使用JUC中的类-CountDownLatch（详情后续章节讲解）" class="headerlink" title="方式二：使用JUC中的类 CountDownLatch（详情后续章节讲解）"></a>方式二：使用JUC中的类 CountDownLatch（详情后续章节讲解）</h5><p>CountDownLatch基于AQS框架，相当于也是维护了一个线程间共享变量state。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建countDownLatch对象并设置计数器初始值</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//计数器减1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	countDownLatch.await();</span><br><span class="line">                	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    	e.printStackTrace();</span><br><span class="line">                	&#125; </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-消息传递"><a href="#3-2-2-消息传递" class="headerlink" title="3.2.2 消息传递"></a>3.2.2 消息传递</h4><h5 id="方式三：wait-notify-结合synchronized等待通知方式"><a href="#方式三：wait-notify-结合synchronized等待通知方式" class="headerlink" title="方式三：wait()/notify()结合synchronized等待通知方式"></a>方式三：wait()/notify()结合synchronized等待通知方式</h5><p>使用Object类的wait() 和 notify() 方法基于线程间消息传递的思想，但要注意wait()和 notify()必须配合synchronized使用，wait())释放锁，而notify()不释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestSync.class) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                	list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                	System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                	<span class="keyword">try</span> &#123;</span><br><span class="line">                    	Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    	e.printStackTrace();</span><br><span class="line">                	&#125;</span><br><span class="line">                	<span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    	<span class="comment">//唤醒线程B</span></span><br><span class="line">                        lock.notify();</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestSync.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    	<span class="keyword">try</span> &#123;</span><br><span class="line">                    		lock.wait();</span><br><span class="line">                		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    		e.printStackTrace();</span><br><span class="line">                		&#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方式四：使用-Lock接口中的ReentrantLock结合-Condition"><a href="#方式四：使用-Lock接口中的ReentrantLock结合-Condition" class="headerlink" title="方式四：使用 Lock接口中的ReentrantLock结合 Condition"></a>方式四：使用 Lock接口中的ReentrantLock结合 Condition</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//实现线程A</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A向list中添加一个元素，此时list中的元素个数为：&quot;</span> + list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    condition.singal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//实现线程B</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (list.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B收到通知开始执行业务&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//先启动线程B</span></span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再启动线程A</span></span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="4-集合的线程安全"><a href="#4-集合的线程安全" class="headerlink" title="4. 集合的线程安全"></a>4. 集合的线程安全</h2><h4 id="4-1-线程安全问题"><a href="#4-1-线程安全问题" class="headerlink" title="4.1 线程安全问题"></a>4.1 线程安全问题</h4><p><strong>问题出现原因：</strong>当某个线程操作共享数据的过程中，尚未操作完成时，其他线程也参与进来操作同一份共享数据；</p>
<p><strong>解决思路：</strong>当一个线程a在操作共享数据时，其他进程不能参与进来，直到线程a操作完共享数据时线程才可以操作共享数据，这种情况即使线程a出现了阻塞也不能被改变；</p>
<h4 id="4-2-ArrayList集合线程不安全和解决方案"><a href="#4-2-ArrayList集合线程不安全和解决方案" class="headerlink" title="4.2 ArrayList集合线程不安全和解决方案"></a>4.2 ArrayList集合线程不安全和解决方案</h4><p>ArrayList在向集合添加内容的同时从集合中获取内容可能会产生并发修改问题（ConcurrentModificationException），可见ArrayList是线程不安全的；</p>
<p><strong>解决方案：</strong></p>
<h5 id="方案一：将ArrayList替换成Vector（现在基本不用）"><a href="#方案一：将ArrayList替换成Vector（现在基本不用）" class="headerlink" title="方案一：将ArrayList替换成Vector（现在基本不用）"></a>方案一：将ArrayList替换成Vector（现在基本不用）</h5><h5 id="方案二：套用Collections工具类中的synchronizedList（现在很少使用）"><a href="#方案二：套用Collections工具类中的synchronizedList（现在很少使用）" class="headerlink" title="方案二：套用Collections工具类中的synchronizedList（现在很少使用）"></a>方案二：套用Collections工具类中的synchronizedList（现在很少使用）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h5 id="方案三：使用JUC中的类CopyOnWriteArrayList"><a href="#方案三：使用JUC中的类CopyOnWriteArrayList" class="headerlink" title="方案三：使用JUC中的类CopyOnWriteArrayList"></a>方案三：使用JUC中的类CopyOnWriteArrayList</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList实现了写时复制技术，读的过程是并发读，写的过程是先复制一份与原本集合相同的新集合后，往新集合中写入新内容，写入新内容结束后新集合再与原本集合合并，之后读的过程就读取合并的新集合。</p>
<h4 id="4-3-HashSet集合线程不安全和解决方案"><a href="#4-3-HashSet集合线程不安全和解决方案" class="headerlink" title="4.3 HashSet集合线程不安全和解决方案"></a>4.3 HashSet集合线程不安全和解决方案</h4><h5 id="解决方案：使用JUC中的类CopyOnWriteArraySet"><a href="#解决方案：使用JUC中的类CopyOnWriteArraySet" class="headerlink" title="解决方案：使用JUC中的类CopyOnWriteArraySet"></a>解决方案：使用JUC中的类CopyOnWriteArraySet</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="4-4-HashMap集合线程不安全和解决方案"><a href="#4-4-HashMap集合线程不安全和解决方案" class="headerlink" title="4.4 HashMap集合线程不安全和解决方案"></a>4.4 HashMap集合线程不安全和解决方案</h4><h5 id="解决方案：使用JUC中的类ConcurrentHashMap"><a href="#解决方案：使用JUC中的类ConcurrentHashMap" class="headerlink" title="解决方案：使用JUC中的类ConcurrentHashMap"></a>解决方案：使用JUC中的类ConcurrentHashMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h2 id="5-多线程锁"><a href="#5-多线程锁" class="headerlink" title="5. 多线程锁"></a>5. 多线程锁</h2><h4 id="5-1-synchronized锁的情况"><a href="#5-1-synchronized锁的情况" class="headerlink" title="5.1 synchronized锁的情况"></a>5.1 synchronized锁的情况</h4><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为以下三种方式：</p>
<ul>
<li>对于普通同步方法，所示当前实例对象；</li>
<li>对于静态同步方法，锁是当前类的Class对象；</li>
<li>对于同步代码块，锁是Synchonized()括号中配置的对象；</li>
</ul>
<h4 id="5-2-锁的分类"><a href="#5-2-锁的分类" class="headerlink" title="5.2 锁的分类"></a>5.2 锁的分类</h4><h5 id="一、公平锁与非公平锁"><a href="#一、公平锁与非公平锁" class="headerlink" title="一、公平锁与非公平锁"></a>一、公平锁与非公平锁</h5><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁，效率比非公平锁低。</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。其执行效率高，但可能会造成优先级反转或者饥饿现象。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言：</strong></p>
<p>　　对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p>
<p>　　对于Synchronized而言，也是一种非公平锁，但由于其并不像ReentrantLock是通过AQS来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h5 id="二、可重入锁"><a href="#二、可重入锁" class="headerlink" title="二、可重入锁"></a>二、可重入锁</h5><ul>
<li>可重入锁又名递归锁，是指在同一个线程中，在外层方法获取锁的时候，进入内层方法会自动获取锁。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言</strong>：它们都是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>
<h5 id="三、独占锁和共享锁（详情后续章节讲解）"><a href="#三、独占锁和共享锁（详情后续章节讲解）" class="headerlink" title="三、独占锁和共享锁（详情后续章节讲解）"></a>三、独占锁和共享锁（详情后续章节讲解）</h5><p><strong>AQS</strong>：抽象队列同步器，简单来说AQS就是一个抽象类AbstractQueuedSynchronizer，没有实现任何的接口，仅仅定义了同步状态state的获取和释放的方法。它还提供了一个FIFO队列（先进先出），多线程竞争资源的时候，没有竞争到的线程就会进入队列中进行等待，并且定义了一套多线程访问共享资源的同步框架。</p>
<p>在AQS中的锁类型有两种：分别是Exclusive(独占锁)和Share(共享锁)。</p>
<ul>
<li>独占锁是指该锁一次只能被一个线程所持有。</li>
<li>共享锁是指该锁可被多个线程所持有。</li>
</ul>
<p><strong>对于Lock接口和Synchronized而言：</strong></p>
<p>　　对于Java ReentrantLock而言其是独占锁。但是对于Lock接口的另一个实现类ReadWriteLock而言，其读锁是共享锁，其写锁是独占锁。读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。独占锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>　　对于Synchronized而言其是独占锁。</p>
<h4 id="5-3-一些锁的概念"><a href="#5-3-一些锁的概念" class="headerlink" title="5.3 一些锁的概念"></a>5.3 一些锁的概念</h4><h5 id="一、偏向锁、轻量级锁和重量级锁"><a href="#一、偏向锁、轻量级锁和重量级锁" class="headerlink" title="一、偏向锁、轻量级锁和重量级锁"></a>一、偏向锁、轻量级锁和重量级锁</h5><p>这三种锁是指锁的状态，并且是<strong>只针对Synchronized</strong>而言的。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>
<ul>
<li><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
</li>
<li><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
</li>
<li><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p>
</li>
</ul>
<h5 id="二、乐观锁和悲观锁"><a href="#二、乐观锁和悲观锁" class="headerlink" title="二、乐观锁和悲观锁"></a>二、乐观锁和悲观锁</h5><p>乐观锁与悲观锁并不是特指某两种类型的锁，只是人们定义出来的概念或思想，主要是指如何看待并发同步的角度。</p>
<ul>
<li><p>乐观锁：乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。</p>
<ul>
<li><p>数据版本机制</p>
<p>实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 核心<span class="keyword">SQL</span>代码如下：</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> xxx<span class="operator">=</span>#&#123;xxx&#125;, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>CAS操作</strong></p>
<p>CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p>
</li>
</ul>
</li>
<li><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
</li>
</ul>
<p><strong>使用说明：</strong></p>
<ol>
<li>悲观锁适合<code>写操作非常多</code>的场景；乐观锁适合<code>读操作非常多</code>的场景，不加锁会带来大量的性能提升。</li>
<li>悲观锁在Java中的使用，就是利用各种锁，比如Java里面的同步原语synchronized关键字的实现就是悲观锁。；乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
</ol>
<h5 id="三、自旋锁"><a href="#三、自旋锁" class="headerlink" title="三、自旋锁"></a>三、自旋锁</h5><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<h4 id="5-4-死锁"><a href="#5-4-死锁" class="headerlink" title="5.4 死锁"></a>5.4 死锁</h4><ul>
<li>死锁：两个或两个以上进程分别占用对方的同步资源不放弃，都在互相等待对方放弃自己需要的同步资源，就形成了线程的死锁，死锁时线程处于阻塞状态；</li>
</ul>
<h5 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h5><ol>
<li><p>竞争资源</p>
<ul>
<li>竞争不可剥夺资源（指当系统资源分配给某进程后，不能强行收回，只能在进程用完后自行释放的资源，如打印机等。）</li>
<li>竞争临时资源（指由一个进程产生，被另一个进程使用，短时间后便无用的资源，故也称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等。）</li>
</ul>
</li>
<li><p>进程间推进顺序非法</p>
<p>若P1保持了资源R1，将因R2已被P2占用而阻塞；P2保持了资源R2，也将因R1已被P1占用而阻塞，于是发生进程死锁。</p>
</li>
</ol>
<h5 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h5><ol>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求与保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h5 id="一个死锁的实现例子"><a href="#一个死锁的实现例子" class="headerlink" title="一个死锁的实现例子"></a>一个死锁的实现例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(str1)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str1&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span>(str2)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str2&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(str2)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str2&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span>(str1)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁住 str1&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码解释：</span></span><br><span class="line"><span class="comment">程序中有两个线程，分别是线程a和线程b，线程a锁住了str1,获得锁之后休眠1秒钟，同时线程b锁住了str2后,也进行休眠操作。当线程a休眠完了之后去锁str2，但是str2已经被线程b给锁住了，这边只能等待，同样的线程b休眠完之后也要去锁str1，但是str1已经被线程a给锁住了，同样也只能等待，处于永远互相等待的状态这样就产生了死锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h5><p><strong>一、预防死锁：破坏必要条件之一</strong></p>
<ol>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不剥夺条件）</li>
<li>资源有序分配：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏循环等待条件）</li>
</ol>
<p><strong>二、避免死锁</strong></p>
<ol>
<li><p>以确定的顺序获得锁</p>
<p>如果必须获取多个锁，可以使用<code>银行家算法</code>进行解决，所有的锁都按照特定的顺序获取。</p>
</li>
<li><p>超时放弃锁</p>
<p>Lock接口提供了<code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁，通过这种方式，也可以很有效地避免死锁。 </p>
</li>
</ol>
<p><strong>三、解除死锁</strong></p>
<p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ol>
<li><p>剥夺并赋予资源：从其它进程剥夺足够数量的资源给死锁进程以解除死锁状态。</p>
</li>
<li><p>撤消死锁进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用使死锁状态消除为止。</p>
</li>
</ol>
<h2 id="6-Callable接口"><a href="#6-Callable接口" class="headerlink" title="6. Callable接口"></a>6. Callable接口</h2><h4 id="6-1-Runnable接口与Callable接口对比"><a href="#6-1-Runnable接口与Callable接口对比" class="headerlink" title="6.1 Runnable接口与Callable接口对比"></a>6.1 Runnable接口与Callable接口对比</h4><ol>
<li>是否有返回值：Runnable接口没有返回值，Callable接口有返回值；</li>
<li>是否会抛出异常：Runnable接口如果无法实现不会抛出异常，而Callable接口会抛出异常；</li>
<li>实现方法不同。Runnable接口使用run()，Callable接口使用call()；</li>
<li>运行Callable可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ol>
<h4 id="6-2-Future接口"><a href="#6-2-Future接口" class="headerlink" title="6.2 Future接口"></a>6.2 Future接口</h4><p>Future是一个接口，代表了一个异步计算的结果，它定义了5个方法：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptInRunning)</code>：取消一个任务，并返回取消结果，参数表示是否中断线程。</li>
<li><code>boolean isCancelled()</code>：判断任务是否被取消。</li>
<li><code>Boolean isDone()</code>：判断当前任务是否执行完毕，包括正常执行完毕、执行异常或者任务取消。</li>
<li><code>V get()</code>：获取任务执行结果，任务结束之前会阻塞。</li>
<li><code>V get(long timeout, TimeUnit unit)</code>：在指定时间内尝试获取执行结果。若超时则抛出超时异常</li>
</ul>
<h4 id="6-3-FutureTask类"><a href="#6-3-FutureTask类" class="headerlink" title="6.3 FutureTask类"></a>6.3 FutureTask类</h4><p><strong>类继承结构</strong></p>
<ul>
<li><p>FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既可以作为Runnable被Thread执行，也可以获取Future异步执行的结果；</p>
</li>
<li><p>FutureTask有两个构造方法，一个接收Callable的参数实例，另一个接收Runnable的参数实例，当传入的参数是Runnable时，也会通过**<code>Executors.callable(runnable, result)</code>**方法将其转成Callable类型（即无论哪个构造方法最终都是执行Callable类型的任务），返回值类型为V（指定的泛型类型）；</p>
</li>
</ul>
<h2 id="7-JUC辅助类"><a href="#7-JUC辅助类" class="headerlink" title="7. JUC辅助类"></a>7. JUC辅助类</h2><h4 id="7-1-减少计数CountDownLatch"><a href="#7-1-减少计数CountDownLatch" class="headerlink" title="7.1 减少计数CountDownLatch"></a>7.1 减少计数CountDownLatch</h4><p>CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行减1操作，使await方法等待计数器不大于0，然后继续执行await方法之后的语句；</p>
<ul>
<li>CountDownLatch主要有两个方法countDown和await，当一个或多个线程调用<code>await()</code>方法时，这些方法会阻塞，其他线程调用<code>countDown()</code>方法会将计数器减1，调用countDown方法的线程不会阻塞，当计数器的值变为0时，因await方法阻塞的线程会被唤醒继续执行；</li>
</ul>
<h4 id="7-2-循环栅栏CyclicBarrier"><a href="#7-2-循环栅栏CyclicBarrier" class="headerlink" title="7.2 循环栅栏CyclicBarrier"></a>7.2 循环栅栏CyclicBarrier</h4><p>CyclicBarrier的构造方法**<code>CyclicBarrier(int parties, Runnable barrierAction)</code>**第一个参数是目标障碍数，每次执行CyclicBarrier障碍数会加1，只有达到了目标障碍数才会启动，执行cyclicBarrier.await()之后的语句。可以将CyclicBarrier理解为加1操作；</p>
<h4 id="7-3-信号灯Semaphore"><a href="#7-3-信号灯Semaphore" class="headerlink" title="7.3 信号灯Semaphore"></a>7.3 信号灯Semaphore</h4><p>Semaphore管理一系列许可证，每个acquire()方法阻塞，直到有一个许可证可以获得，然后拿走一个许可证；每个release()方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。</p>
<p><strong>Semaphore的主要方法如下：</strong></p>
<ul>
<li><p><code>void acquire()</code>：从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</p>
<ol>
<li><p>当调用semaphore.acquire() 方法时，当前线程会尝试去同步队列获取一个许可，获取许可的过程也就是使用原子的操作去修改同步队列的state ，获取一个许可则修改为state=state-1；</p>
</li>
<li><p>当计算出来的state&lt;0，则代表许可数量不足，此时会创建一个Node节点加入阻塞队列，挂起当前线程；</p>
</li>
<li><p>当计算出来的state&gt;=0，则代表获取许可成功。</p>
</li>
</ol>
</li>
<li><p><code>void release()</code>：释放一个许可，将其返回给信号量。</p>
<ol>
<li><p>当调用semaphore.release() 方法时，线程会尝试释放一个许可，释放许可的过程也就是把同步队列的state修改为state=state+1的过程</p>
</li>
<li><p>释放许可成功之后，同时会唤醒同步队列中的一个线程。</p>
</li>
<li><p>被唤醒的节点会重新尝试去修改state=state-1 的操作，如果state&gt;=0则获取许可成功，否则重新进入阻塞队列，挂起线程。</p>
</li>
</ol>
</li>
</ul>
<h2 id="8-ReentrantReadWriteLock读写锁"><a href="#8-ReentrantReadWriteLock读写锁" class="headerlink" title="8. ReentrantReadWriteLock读写锁"></a>8. ReentrantReadWriteLock读写锁</h2><h4 id="8-1-读写锁简介"><a href="#8-1-读写锁简介" class="headerlink" title="8.1 读写锁简介"></a>8.1 读写锁简介</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">场景分析：</span><br><span class="line">对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程可以同时读一个资源，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</span><br></pre></td></tr></table></figure>

<p>针对这种场景，JUC提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为<strong>共享锁</strong>；一个是写相关的锁，称为**排他锁(或独占锁)<strong>，分别采用其</strong><code>readLock()</code><strong>和</strong><code>writeLock()</code>**方法；</p>
<p><strong>注意：</strong>所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p>
<h4 id="8-2-线程进入读写锁的条件"><a href="#8-2-线程进入读写锁的条件" class="headerlink" title="8.2 线程进入读写锁的条件"></a>8.2 线程进入读写锁的条件</h4><ol>
<li><p>线程进入读锁的前提条件：</p>
<ul>
<li>没有其他线程的写锁；</li>
<li>没有写请求，或者<strong>有写请求，但调用线程和持有锁的线程是同一个</strong>；</li>
</ul>
</li>
<li><p>线程进入写锁的前提条件：</p>
<ul>
<li>没有其他线程的读锁；（读写互斥）</li>
<li>没有其他线程的写锁；（写写互斥）</li>
</ul>
</li>
</ol>
<h4 id="8-3-读写锁的特性"><a href="#8-3-读写锁的特性" class="headerlink" title="8.3 读写锁的特性"></a>8.3 读写锁的特性</h4><p>（1）公平选择性：支持非公平和公平的锁获取方式，默认为非公平锁。</p>
<p>（2）支持可重入：读锁和写锁都支持线程重进入，读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p>
<p>（3）锁降级：允许从写锁降级为读锁，实现方式：<strong>先获取写锁，然后获取读锁，最后释放写锁，释放读锁</strong>。但不允许读锁升级为写锁；</p>
<h2 id="9-BlockingQueue阻塞队列"><a href="#9-BlockingQueue阻塞队列" class="headerlink" title="9. BlockingQueue阻塞队列"></a>9. BlockingQueue阻塞队列</h2><h4 id="9-1-阻塞队列使用场景"><a href="#9-1-阻塞队列使用场景" class="headerlink" title="9.1 阻塞队列使用场景"></a>9.1 阻塞队列使用场景</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">场景分析：</span><br><span class="line">对于生产者和消费者模型，通过队列实现两者之间的数据共享。如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度必须要大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，生产者必须暂停生产（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕；</span><br></pre></td></tr></table></figure>

<p><strong>阻塞队列实现效果：</strong></p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</li>
</ul>
<h4 id="9-2-阻塞队列核心方法"><a href="#9-2-阻塞队列核心方法" class="headerlink" title="9.2 阻塞队列核心方法"></a>9.2 阻塞队列核心方法</h4><h5 id="一、放入数据"><a href="#一、放入数据" class="headerlink" title="一、放入数据"></a>一、放入数据</h5><ol>
<li><code>offer(E e)</code>：在不违反容量限制的情况下，可立即将指定元素插入此队列，成功返回true，当无可用空间时候，返回false。</li>
<li><code>offer(E o, long timeout, TimeUnit unit)</code>： 将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false。</li>
<li><code>put()</code>：直接在队列中插入元素，当无可用空间时阻塞当前线程等待。直到有空间才继续；<strong>（此方法会阻塞当前执行方法的线程）</strong></li>
<li><code>add(E e)</code>：在不违反容量限制的情况下，可立即将指定元素插入此队列，成功返回true，当无可用空间时，返回illegalStateException异常。<strong>（此方法会返回异常）</strong></li>
</ol>
<h5 id="二、获取数据"><a href="#二、获取数据" class="headerlink" title="二、获取数据"></a>二、获取数据</h5><ol>
<li><code>poll(time)</code>：取走BlockingQueue里队首的对象，若不能立即取出则可以等time参数规定的时间，若还是取不到时返回null;</li>
<li><code>take()</code>：获取并移除队列头部的元素，无元素时候阻塞当前线程等待。直到队列有新的数据被加入可获取; <strong>（此方法会阻塞当前执行方法的线程）</strong></li>
</ol>
<h4 id="9-3-阻塞队列分类"><a href="#9-3-阻塞队列分类" class="headerlink" title="9.3 阻塞队列分类"></a>9.3 阻塞队列分类</h4><h5 id="1-ArrayBlockingQueue-常用"><a href="#1-ArrayBlockingQueue-常用" class="headerlink" title="1. ArrayBlockingQueue(常用)"></a>1. ArrayBlockingQueue(常用)</h5><ul>
<li><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部维护了一个定长数组，以便缓存队列中的数据对象，还保存着两个整型变量，分别标识着队列的头部和尾部在数组中的位置；<strong>（由数组结构组成的有界阻塞队列）</strong></p>
</li>
<li><p><strong>ArrayBlockingQueue和LinkedBlockingQueue比较：</strong></p>
<ul>
<li>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；</li>
<li>ArrayBlockingQueue在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。</li>
</ul>
</li>
<li><p>创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
</li>
</ul>
<h5 id="2-LinkedBlockingQueue-常用"><a href="#2-LinkedBlockingQueue-常用" class="headerlink" title="2. LinkedBlockingQueue(常用)"></a>2. LinkedBlockingQueue(常用)</h5><ul>
<li>基于链表的阻塞队列实现，与ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程才会被唤醒，反之对于消费者这端的处理也基于同样的原理。<strong>（由链表结构组成的有界阻塞队列）</strong></li>
<li>LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li>
</ul>
<h5 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h5><ul>
<li>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素；</li>
<li>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<strong>（使用优先级队列实现的延迟无界阻塞队列）</strong></li>
</ul>
<h5 id="4-PriorityBlockingQueue"><a href="#4-PriorityBlockingQueue" class="headerlink" title="4. PriorityBlockingQueue"></a>4. PriorityBlockingQueue</h5><ul>
<li>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。<strong>（支持优先级排序的无界阻塞队列）</strong></li>
<li>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</li>
</ul>
<h5 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h5><p>一种无缓冲的等待队列<strong>（不存储元素的阻塞队列，即单个元素的队列）</strong></p>
<h2 id="10-ThreadPool线程池"><a href="#10-ThreadPool线程池" class="headerlink" title="10. ThreadPool线程池"></a>10. ThreadPool线程池</h2><h4 id="10-1-线程池架构"><a href="#10-1-线程池架构" class="headerlink" title="10.1 线程池架构"></a>10.1 线程池架构</h4><p>Java中的线程池是通过Executor框架实现的，该框架中使用了Executor、Executors、ExecutorService和ThreadPoolExecutor类；</p>
<h4 id="10-2-线程池基本结构"><a href="#10-2-线程池基本结构" class="headerlink" title="10.2 线程池基本结构"></a>10.2 线程池基本结构</h4><p>用户通过使用线程池的<code>execute()</code>方法创建线程，将Runnable提交到线程池中进行执行。当线程池中无空闲线程时，这个新加入的Runnable就会被放入等待队列。当有线程空闲下来的时候，就会去等待队列里查看是否还有排队等待的任务，如果有就会队列中取出任务并继续执行。如果没有线程就会进入休眠。</p>
<p><strong>当我们把一个Runnable交给线程池去执行的时候，这个线程池处理的流程如下：</strong></p>
<ol>
<li><p>先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务指派给某一个空闲线程去执行。如果没有空闲，<strong>判断核心线程池是否到达corePoolSize</strong>，当当前线程池中的核心线程数还小于 corePoolSize，那就再创建一个新的工作线程来执行任务。</p>
</li>
<li><p>如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，<strong>判断等待队列是否已满</strong>，没满就把这个新任务放到等待队列中。</p>
</li>
<li><p>如果等待队列又满了，<strong>判断当前线程数是否到达maximumPoolSize</strong>，如果还未到达，就继续创建工作线程。如果已经到达了，就执行饱和策略，交给RejectedExecutionHandler来决定怎么处理这个任务。</p>
</li>
</ol>
<h4 id="10-3-Executors类提供的四种线程池"><a href="#10-3-Executors类提供的四种线程池" class="headerlink" title="10.3 Executors类提供的四种线程池"></a>10.3 Executors类提供的四种线程池</h4><h5 id="1-newSingleThreadExecutor"><a href="#1-newSingleThreadExecutor" class="headerlink" title="1. newSingleThreadExecutor"></a>1. newSingleThreadExecutor</h5><ul>
<li>创建<strong>单线程的线程池</strong>。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
</ul>
<h5 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool"></a>2. newFixedThreadPool</h5><ul>
<li>创建<strong>指定线程数的线程池</strong>。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到队列中，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ul>
<h5 id="3-newCachedThreadPool"><a href="#3-newCachedThreadPool" class="headerlink" title="3. newCachedThreadPool"></a>3. newCachedThreadPool</h5><ul>
<li>创建<strong>可缓存的线程池</strong>。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，若无可回收，则添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 </li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为60秒)，则该工作线程将自动终止。终止后，如果又提交了新的任务，则线程池重新创建一个工作线程。</li>
</ul>
<h5 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4. newScheduledThreadPool"></a>4. newScheduledThreadPool</h5><ul>
<li>创建<strong>定长的线程池</strong>，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</li>
</ul>
<p><strong>总结：</strong>除了newScheduledThreadPool之外，其它线程池内部都是基于<code> ThreadPoolExecutor类</code>实现的，<strong>在实际开发时也通常继承ThreadPoolExecutor类自定义线程池</strong>；</p>
<h4 id="10-4-ThreadPoolExecutor类中的的七个参数解释："><a href="#10-4-ThreadPoolExecutor类中的的七个参数解释：" class="headerlink" title="10.4 ThreadPoolExecutor类中的的七个参数解释："></a>10.4 ThreadPoolExecutor类中的的七个参数解释：</h4><ol>
<li><p><strong>corePoolSize：线程池核心线程大小</strong></p>
<p>线程池中会维护一个常驻的最小线程数量，即使这些线程处理空闲状态也不会被销毁，这个最小线程数量即是corePoolSize；</p>
</li>
<li><p><strong>maximumPoolSize：线程池最大线程数量</strong></p>
<p>一个任务被提交到线程池后，首先会找是否有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定；</p>
</li>
<li><p><strong>keepAliveTime：空闲线程存活时间</strong></p>
<p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定；</p>
</li>
<li><p><strong>unit：空闲线程存活时间单位</strong></p>
<p>unit作为keepAliveTime的计量单位；</p>
</li>
<li><p><strong>workQueue：工作队列（采用阻塞队列）</strong></p>
<p>务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。阻塞队列的分类参考<strong>9.3 阻塞队列分类</strong>；</p>
</li>
<li><p><strong>threadFactory：线程工厂</strong></p>
<p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
</li>
<li><p><strong>handler：拒绝策略</strong></p>
<p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会根据拒绝策略进行处理，<strong>拒绝策略可分为以下4种：</strong></p>
<ul>
<li>CallerRunsPolicy：将某些任务回退给调用者线程，降低新任务的流量；</li>
<li>AbortPolicy(默认策略)：直接抛出RejectedExecutionException异常阻止系统正常运行；</li>
<li>DiscardPolicy：丢弃无法处理的任务，不予任何处理也不抛出异常；</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，并把当前任务加入队列中尝试再次提交当前任务；</li>
</ul>
</li>
</ol>
<h2 id="11-Fock-Join分支合并框架（后续补充）"><a href="#11-Fock-Join分支合并框架（后续补充）" class="headerlink" title="11. Fock/Join分支合并框架（后续补充）"></a>11. Fock/Join分支合并框架（后续补充）</h2><h4 id="11-1-Fork-Join框架简介"><a href="#11-1-Fork-Join框架简介" class="headerlink" title="11.1 Fork / Join框架简介"></a>11.1 Fork / Join框架简介</h4><p>Fork / Join将一个大的任务拆分成多个子任务进行并行处理，最后将子任务的结果合并成最终的计算结果；</p>
<ul>
<li>Fork：把一个复杂任务进行分拆；</li>
<li>Join：把分拆任务的结果进行合并；</li>
</ul>
<h4 id="11-2-Fork-Join框架与线程池区别"><a href="#11-2-Fork-Join框架与线程池区别" class="headerlink" title="11.2 Fork / Join框架与线程池区别"></a>11.2 Fork / Join框架与线程池区别</h4><p>Fork/Join框架采用“工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>
<p>相对于一般的线程池实现，Fork/Join框架的优势体现在对其中包含的任务的处理方式上。在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在Fork/Join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程的等待时间和提高了性能。</p>
<h2 id="12-CompleteableFuture异步回调（后续补充）"><a href="#12-CompleteableFuture异步回调（后续补充）" class="headerlink" title="12. CompleteableFuture异步回调（后续补充）"></a>12. CompleteableFuture异步回调（后续补充）</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合学习笔记</title>
    <url>/2020/03/12/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习Java集合时所记录的笔记；</p>
<span id="more"></span>



<h2 id="1-Java集合概述"><a href="#1-Java集合概述" class="headerlink" title="1. Java集合概述"></a>1. Java集合概述</h2><h3 id="1-1-集合与数组的比较"><a href="#1-1-集合与数组的比较" class="headerlink" title="1.1 集合与数组的比较"></a>1.1 集合与数组的比较</h3><p><strong>一、数组在存储多个数据方面的特点：</strong></p>
<ul>
<li>一旦初始化以后，其长度就确定了；</li>
<li>数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据了；</li>
</ul>
<p><strong>二、数组在存储多个数据方面的缺点：</strong></p>
<ul>
<li>一旦初始化以后，其长度就不可修改了；</li>
<li>数组中提供的方法有限，不便于添加、删除、插入数据等操作。同时效率不高；</li>
<li>数组没有现成的属性或方法获取数组中实际元素的个数；</li>
<li>数组存储对于无序、不可重复的需求不能满足；</li>
</ul>
<p><strong>三、集合存储的优点：</strong></p>
<ul>
<li>可以解决数组存储数据方面的以上弊端；</li>
</ul>
<h2 id="2-Collection接口（重点）"><a href="#2-Collection接口（重点）" class="headerlink" title="2. Collection接口（重点）"></a>2. Collection接口（重点）</h2><h3 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h3><p><strong>注意：</strong>Collection接口的实现类的对象中添加数据obj时，要求obj所在类必须要<strong>重写equals( )方法</strong>;</p>
<p><strong>常用方法如下：</strong></p>
<ol>
<li><code>add(Object e)</code>：将元素e添加到集合中</li>
<li><code>size( )</code>：获取添加的元素的个数</li>
<li><code>addAll(Collection coll)</code>：将coll集合中的元素添加到当前的集合中</li>
<li><code>isEmpty( )</code>：判断当前集合是否为空</li>
<li><code>clear( )</code>：清空结合元素</li>
<li><code>contains(Object obj)</code>：判断当前集合中是否包含obj，在判断氏会调用obj对象所在类的equals( )方法</li>
<li><code>containsAll(Collection coll)</code>：判断形参coll中的所有元素是否都存在于当前集合中</li>
<li><code>remove(Object obj)</code>：从当前集合中移除obj元素</li>
<li><code>removeAll(Collection coll)</code>：从当前集合中移除coll中的所有的元素</li>
<li><code>retainAll(Collection coll)</code>：获取当前集合和coll集合的交集，并返回给当前集合</li>
<li><code>equals(Object obj)</code>：判断两个集合的元素是否相同</li>
<li><code>hasjCode( )</code>：返回当前对象的哈希值</li>
<li><code>toAttay( )</code>：将集合变为数组（将数组变为集合：调用Arrays类的静态方法asList( )；）</li>
<li><code>iterator( )</code>：返回Iterator接口的实例，用于遍历集合元素</li>
</ol>
<h3 id="2-2-Iterator迭代器接口"><a href="#2-2-Iterator迭代器接口" class="headerlink" title="2.2 Iterator迭代器接口"></a>2.2 Iterator迭代器接口</h3><p><strong>Iterator迭代器的作用：</strong>进行集合元素的遍历操作；</p>
<h4 id="2-2-1-Iterator接口使用方法"><a href="#2-2-1-Iterator接口使用方法" class="headerlink" title="2.2.1 Iterator接口使用方法"></a>2.2.1 Iterator接口使用方法</h4><ol>
<li><code>hasNext( )</code>：判断是否还有下一个元素；</li>
<li><code>next( )</code>：①指针下移；②将下移以后集合位置上的元素返回；</li>
<li><code>remove( )</code>：Iterator内部定义的方法，可以在遍历的时候删除集合中的元素，<strong>注意此方法不同于集合直接调用的remove( )</strong>;</li>
</ol>
<h4 id="2-2-2-遍历集合的几种方式"><a href="#2-2-2-遍历集合的几种方式" class="headerlink" title="2.2.2 遍历集合的几种方式"></a>2.2.2 遍历集合的几种方式</h4><h5 id="1-遍历方式一：使用iterator迭代器"><a href="#1-遍历方式一：使用iterator迭代器" class="headerlink" title="1. 遍历方式一：使用iterator迭代器"></a>1. 遍历方式一：使用iterator迭代器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator( );</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext( )) &#123;</span><br><span class="line">	System.out.println(iterator.next( ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意以下错误方式：</span></span><br><span class="line"><span class="keyword">while</span>(coll.iterator( ).hasNext( )) &#123;</span><br><span class="line">	System.out.println(coll.iterator( ).next( ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误原因：集合对象每次调用iterator( )方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前；</span></span><br></pre></td></tr></table></figure>

<h5 id="2-遍历方式二：使用foreach循环"><a href="#2-遍历方式二：使用foreach循环" class="headerlink" title="2. 遍历方式二：使用foreach循环"></a>2. 遍历方式二：使用foreach循环</h5><p><strong>注意：</strong>foreach循环用于遍历集合和数组，内部其实仍然调用了迭代器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="keyword">for</span>(Object obj : coll) &#123;</span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-遍历方式三：使用普通循环"><a href="#3-遍历方式三：使用普通循环" class="headerlink" title="3. 遍历方式三：使用普通循环"></a>3. 遍历方式三：使用普通循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>( );</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; coll.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-List接口"><a href="#2-3-List接口" class="headerlink" title="2.3 List接口"></a>2.3 List接口</h3><p>特点：<strong>存储有序的、可重复的数据；</strong>可理解为动态数组，用于替换原有的数组；</p>
<h4 id="2-3-1-ArrayList（常用）"><a href="#2-3-1-ArrayList（常用）" class="headerlink" title="2.3.1 ArrayList（常用）"></a>2.3.1 ArrayList（常用）</h4><p>ArrayList 继承自 AbstractList，实现了 List 接口，是一个可以动态修改的数组，与普通数组的区别就是它<strong>没有固定大小的限制</strong>；</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>add()</code>：将元素插入到指定位置的ArrayList中；</li>
<li><code>contains()</code>：判断元素是否在ArrayList；</li>
<li><code>get()</code>：通过索引值获取ArrayList中的元素；</li>
<li><code>subList(int fromIndex, int toIndex)</code>：用于截取并返回动态数组中的一部分；</li>
<li><code>set(int index, E element)</code>：用于替换动态数组中指定索引的元素；</li>
<li><code>sort(Comparator c)</code>：根据指定的顺序对动态数组中的元素进行排序；</li>
<li><code>removeIf(Predicate&lt;E&gt; filter)</code>：用于删除所有满足特定条件的数组元素；</li>
<li><code>forEach(Consumer&lt;E&gt; action)</code>：用于遍历动态数组中每一个元素并执行特定操作</li>
</ul>
<h4 id="2-3-2-LinkedList（常用）"><a href="#2-3-2-LinkedList（常用）" class="headerlink" title="2.3.2 LinkedList（常用）"></a>2.3.2 LinkedList（常用）</h4><p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低;</p>
<p><strong>注意：</strong>LinkedList 实现了 Queue接口 ，可作为单向队列使用；同时实现了Deque接口，可作为双端队列和栈使用；</p>
<ul>
<li>队列(Queue)：限定所有的插入只能在表的一端进行，而所有的删除都在表的另一端进行的线性表。表中允许插入的一端称为队尾(Rear)，允许删除的一端称为队头(Front)。队列的操作是按先进先出(FIFO)的原则进行的。</li>
<li>栈(Stack)：限定仅在表尾进行插入和删除运算的线性表，表尾称为栈顶(top)，表头称为栈底(bottom)。也是一种特殊的线性表，是一种后进先出(LIFO)的结构。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>add(int index, E element)</code>：向指定位置插入元素；</li>
<li><code>addFirst() / addLast()</code>：把元素加到列表首部 / 尾部；</li>
<li><code>removeLast()</code>：删除并返回最后一个元素；</li>
<li><code>E poll()</code>：删除并返回第一个元素；</li>
<li><code>E get(int index)</code>：返回指定位置的元素；</li>
<li><code>int indexOf(Object o)</code>：查找指定元素从前往后第一次出现的索引；</li>
<li><code>E set(int index, E element)</code>：设置指定位置的元素；</li>
<li><code>Object[] toArray()</code>：返回一个由链表元素组成的数组；</li>
<li><code>int size()</code>：返回链表元素个数；</li>
</ul>
<h4 id="2-3-3-Vector（已过时）"><a href="#2-3-3-Vector（已过时）" class="headerlink" title="2.3.3 Vector（已过时）"></a>2.3.3 Vector（已过时）</h4><h4 id="2-3-4-三者的异同点"><a href="#2-3-4-三者的异同点" class="headerlink" title="2.3.4 三者的异同点"></a>2.3.4 三者的异同点</h4><ul>
<li>相同点：两个类都实现了List接口，存储数据的特点相同，都是存储有序的、可重复的数据；</li>
<li>不同点：<ul>
<li>ArrayList：作为List接口的主要实现类：线程不安全，效率高，底层使用Object[ ] elementData存储；</li>
<li>LinkedList：底层使用双向循环链表存储，在此链表上每一个数据节点都由三部分组成：前指针（指向前面的节点的位置），数据，后指针（指向后面的节点的位置），最后一个节点的后指针指向第一个节点的前指针，形成一个循环。线程不安全，对于频繁的插入和删除操作，使用此类效率比ArrayList效率高；</li>
<li>Vector：作为List接口的古老实现类：线程安全，效率低，底层使用Object[ ] elementData存储；</li>
</ul>
</li>
</ul>
<h4 id="2-3-5-List接口使用场景推荐"><a href="#2-3-5-List接口使用场景推荐" class="headerlink" title="2.3.5 List接口使用场景推荐"></a>2.3.5 List接口使用场景推荐</h4><p><strong>如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List</strong></p>
<p>对ArrayList和LinkedList的优缺点进行分析：</p>
<p><strong>ArrayList</strong></p>
<p>优点：ArrayList是实现了基于动态数组的数据结构，地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着的）。</p>
<p>缺点：因为地址连续，当要插入和删除时，Arraylist需要前后移动数据，所以插入和删除操作效率比较低。</p>
<p><strong>LinkedList</strong></p>
<p>优点：LinkedList是基于链表的数据结构，地址任意，所以开辟内存空间时不需要连续的地址，对于新增和删除操作比较占优势。</p>
<p>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</p>
<p>即对于ArrayList和LinkedList的使用场景推荐如下：</p>
<ol>
<li>对于需要快速插入，删除元素，应该使用LinkedList。</li>
<li>对于需要快速随机访问元素，应该使用ArrayList。</li>
<li>对于“<strong>单线程环境</strong>” 或者 “<strong>多线程环境，但List仅仅只会被单个线程操作</strong>”，此时应该使用ArrayList。对于“<strong>多线程环境，且List可能同时被多个线程操作</strong>”，此时，应该使用LinkedList。</li>
</ol>
<h3 id="2-4-Set接口"><a href="#2-4-Set接口" class="headerlink" title="2.4 Set接口"></a>2.4 Set接口</h3><p>特点：<strong>存储无序的、不可重复的数据</strong>；</p>
<ul>
<li><strong>无序性</strong>：不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的；</li>
<li><strong>不可重复性</strong>：保证添加的元素按照equals( )判断时不能返回true，即相同的元素只能添加一个；</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>向Set中添加数据，其所在的类一定要重写hashCode( )和equals( )；<ul>
<li><strong>要同时重写equals()和hashCode()的原因：</strong>因为添加进集合的时候首先需要判断该集合中是否含有需要添加的元素，这个时候就要使用contains方法。contains方法内部调用equals方法，所以要重写**<code>equals()</code><strong>；而本来Object类中equals()相等，hashCode()必然相等，只有两个都相等才能说明是同一个对象，仅仅重写equals()就打破了这种逻辑，所以还需要重写</strong><code>hashCode()</code>**;</li>
</ul>
</li>
<li>重写的hashCode( )和equals( )尽可能保持一致：相等的对象必须具有相等的散列码；</li>
</ol>
<h4 id="2-4-1-HashSet（常用）"><a href="#2-4-1-HashSet（常用）" class="headerlink" title="2.4.1 HashSet（常用）"></a>2.4.1 HashSet（常用）</h4><p>HashSet底层是<strong>数组+链表</strong>的结构；<br><strong>元素添加例子：</strong><br>向HashSet中添加元素a，首先调用元素a所在类的hashCode( )方法，计算元素a的哈希值，此哈希值通过某种算法计算出在HashSet底层数组中的存放位置（即索引位置），判断数组此位置上是否已经有元素：</p>
<ul>
<li>如果此位置上没有其他元素，则元素a添加成功；<strong>（情况1）</strong></li>
<li>如果此位置上有其他元素b（或以链表形式存放的多个元素），则比较元素a与元素b的hash值：<ul>
<li>如果hash值不相同，则元素a添加成功；<strong>（情况2）</strong></li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul>
<li>若equals()返回true，元素a添加失败；</li>
<li>若返回false则元素a添加成功；<strong>（情况3）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上元素b以链表方式存储，元素b存储在数组中并指向元素a；</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>boolean contains(Object o)</code>：若此set包含指定的元素，则返回true;</li>
<li><code>boolean add(E e)</code>：如果指定的元素尚不存在，则将其添加到此集合中</li>
</ul>
<h4 id="2-4-2-LinkedHashSet"><a href="#2-4-2-LinkedHashSet" class="headerlink" title="2.4.2 LinkedHashSet"></a>2.4.2 LinkedHashSet</h4><p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据；</p>
<h4 id="2-4-3-TreeSet"><a href="#2-4-3-TreeSet" class="headerlink" title="2.4.3 TreeSet"></a>2.4.3 TreeSet</h4><p><strong>使用要求：</strong></p>
<ol>
<li>向TreeSet中添加的数据，要求是相同类的对象，不能添加不同类的对象；</li>
<li>两种排序方式：自然排序（实现Comparable接口）、定制排序（实现Comparator接口）<ul>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo( )返回0，不再是equals( )</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare( )返回0，不再是equals( )</li>
</ul>
</li>
</ol>
<h4 id="2-4-4-三者的异同点"><a href="#2-4-4-三者的异同点" class="headerlink" title="2.4.4 三者的异同点"></a>2.4.4 三者的异同点</h4><ul>
<li><p>相同点：三者都实现了Set接口，存储无序的、不可重复的数据；</p>
</li>
<li><p>不同点：</p>
<ul>
<li>HashSet：作为Set接口的主要实现类，线程不安全，可以存储null值；</li>
<li>LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet；</li>
<li>TreeSet：可以按照添加对象的指定属性进行排序，底层存储结构是红黑树；</li>
</ul>
</li>
</ul>
<h2 id="3-Map接口（重点）"><a href="#3-Map接口（重点）" class="headerlink" title="3. Map接口（重点）"></a>3. Map接口（重点）</h2><p>定义：双列集合，用来存储一对对（key-value）的数据</p>
<h3 id="3-1-Map的特点"><a href="#3-1-Map的特点" class="headerlink" title="3.1 Map的特点"></a>3.1 Map的特点</h3><ul>
<li>Map中的key：无序的、不可重复的，使用Set存储所有key（以HashMap类为例，key所在的类要重写equals()和hashCode()方法）</li>
<li>Map中的value：无序的、可重复的，使用Collection存储所有value（value所在的类要重写equals()方法）<br>一个键值对：key-value构成了一个Entry对象</li>
<li>Map中的entry：无序的、不可重复的，key-value构成了一个Entry键值对对象，使用Set存储所有的entry</li>
</ul>
<h3 id="3-2-HashMap（常用）"><a href="#3-2-HashMap（常用）" class="headerlink" title="3.2 HashMap（常用）"></a>3.2 HashMap（常用）</h3><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1. HashMap概述"></a>1. HashMap概述</h4><p><strong>HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表后通过key对象的equals()逐一比对查找。</p>
<ul>
<li><strong>注意：</strong>JDK7.0时底层结构只有数组+链表，JDK8.0后底层结构为<strong>数组+链表+红黑树</strong>；（当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储）</li>
</ul>
<p><strong>哈希冲突：</strong>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了（即<strong>两个不同的元素，通过哈希函数得出的实际存储地址相同</strong>），其实这就是所谓的哈希冲突，也叫哈希碰撞。</p>
<h4 id="2-HashMap在JDK7-0与JDK-8-0底层实现原理对比"><a href="#2-HashMap在JDK7-0与JDK-8-0底层实现原理对比" class="headerlink" title="2. HashMap在JDK7.0与JDK 8.0底层实现原理对比"></a>2. HashMap在JDK7.0与JDK 8.0底层实现原理对比</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">HashMap</span>( );</span><br><span class="line">不同于像JDK7<span class="number">.0</span>在实例化以后，底层创建了长度为<span class="number">16</span>的一维数组Entry[ ] table，在JDK8<span class="number">.0</span>后底层没有创建一个长度为<span class="number">16</span>的数组，底层数组变为是Node[ ]，而非Entry[ ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.put(key1, value1)</span><br><span class="line">在JDK8<span class="number">.0</span>，首次调用put( )方法时，底层才创建了长度为<span class="number">16</span>的数组执行put()</span><br><span class="line">    </span><br><span class="line">JDK7<span class="number">.0</span>与<span class="number">8.0</span>时执行流程类似如下：</span><br><span class="line">首先调用key1所在类的hashcode( )计算key1哈希值，哈希值经过某种算法计算以后得到在Entry数组中的存放位置</span><br><span class="line">如果此位置上的数据为空，此时的key1-value1添加成功；（情况<span class="number">1</span>）</span><br><span class="line">如果此位置上的数据不为空，比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">	如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功；（情况<span class="number">2</span>）</span><br><span class="line">	如果key1的哈希值与已经存在的某个数据（key2-value2）的哈希值相同，继续调用key1所在类的equals(key2)方法比较：</span><br><span class="line">		如果equals()返回<span class="literal">false</span>，则key1-value1添加成功；（情况<span class="number">3</span>）</span><br><span class="line">		如果equals()返回<span class="literal">true</span>，使用value1替换value2</span><br><span class="line"></span><br><span class="line">注意：关于情况<span class="number">2</span>和<span class="number">3</span>，此时key1-value1和原来的数据以链表的方式存储；</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<ul>
<li><code>size()</code>：计算 HashMap 中键/值对的数量；</li>
<li><code>put(K key，V value)</code>：将键/值对添加到 HashMap 中；</li>
<li><code>containsKey(Object key)</code>：检查 HashMap 中是否存在指定的 key 对应的映射关系；</li>
<li><code>replace(K key, V oldValue, V newValue)</code>：替换 HashMap 中是指定的 key 对应的 value；</li>
<li><code>forEach(BiConsumer&lt;K, V&gt; action)</code>：用于对 HashMap 中的每个映射执行指定的操作；</li>
<li><code>merge(key, value, remappingFunction)</code>：先判断指定的 key 是否存在，如果不存在，则添加键值对到 hashMap 中；</li>
<li><code>keySet() / values() / entrySet()</code>：分别是返回所有key / value / 键值对；</li>
<li><code>getOrDefault(Object key, V defaultValue)</code>：获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值；</li>
</ul>
<h3 id="3-3-LinkedHashMap"><a href="#3-3-LinkedHashMap" class="headerlink" title="3.3 LinkedHashMap"></a>3.3 LinkedHashMap</h3><h3 id="3-4-TreeMap"><a href="#3-4-TreeMap" class="headerlink" title="3.4 TreeMap"></a>3.4 TreeMap</h3><h3 id="3-5-HashTable（已过时）"><a href="#3-5-HashTable（已过时）" class="headerlink" title="3.5 HashTable（已过时）"></a>3.5 HashTable（已过时）</h3><h3 id="3-6-Properties"><a href="#3-6-Properties" class="headerlink" title="3.6 Properties"></a>3.6 Properties</h3><h3 id="3-7-五者的异同点"><a href="#3-7-五者的异同点" class="headerlink" title="3.7 五者的异同点"></a>3.7 五者的异同点</h3><ul>
<li>不同点：<ul>
<li>HashMap：作为Map接口的主要实现类，线程不安全，效率高；可以存储null的key和value；</li>
<li>LinkedHashMap：保证在遍历Map元素时，可以按照添加的顺序实现遍历，原因在原有的HashMap底层结构基础上添加了一对指针，指向前一个和后一个元素；（对于频繁的遍历操作，此类执行效率高于HashMap）</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历，此时考虑key的自然排序或定制排序；</li>
<li>Hashtable：作为古老的实现类，线程安全，效率低，不可以存储null的key和value；</li>
<li>Properties：Hashtable的子类，<strong>常用来处理配置文件</strong>，key和value都是String类型的；</li>
</ul>
</li>
</ul>
<h2 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4. Collections工具类"></a>4. Collections工具类</h2><p>Collections：是操作Set、、List和Map等集合的工具类</p>
<p><strong>常用方法：</strong></p>
<ol>
<li><p>排序操作（均为static方法）</p>
<ul>
<li><code>reverse(List)</code>：反转List中元素的顺序</li>
<li><code>shuffle(List)</code>：对List集合元素进行随机排序</li>
<li><code>sort(List, Comparator)</code>：根据指定的Comparator产生的顺序对List集合元素按升序排序</li>
<li><code>swap(List, int, int)</code>：将指定List集合中的i处元素和j处元素进行交换</li>
</ul>
</li>
<li><p>查找替换</p>
<ul>
<li><code>Object max(Collection)</code>：根据元素的自然排序，返回给定集合中的最大元素</li>
<li><code>int frequency(Collection, Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest, List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：使用新值替换旧值</li>
</ul>
<p><code>synchronizedList(List)</code>：将指定集合包装成线程同步的集合（用于解决ArrayList和HashMap线程安全问题）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习笔记</title>
    <url>/2020/03/08/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人学习Java相关反射时所总结的入门笔记，对反射的理解还不够深入；</p>
<span id="more"></span>



<h2 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1. 问题导入"></a>1. 问题导入</h2><h3 id="1-1-如何看待面向对象的封装性和反射机制？两者是否矛盾？"><a href="#1-1-如何看待面向对象的封装性和反射机制？两者是否矛盾？" class="headerlink" title="1.1 如何看待面向对象的封装性和反射机制？两者是否矛盾？"></a>1.1 如何看待面向对象的封装性和反射机制？两者是否矛盾？</h3><p>答：两者并不矛盾。封装性相当于是建议其他类去调用当前类的公共方法，而私有方法不建议去调用，因为公共的方法可能比私有的方法更好，在公共方法里面可能添加了一些私有方法没有的逻辑。如果非要调用私有的方法，也可以调用，那我们就通过反射的方式去调用。<strong>（总结：封装性解决的是访问权限。即建议调用哪个的问题；反射解决的是调用类的问题 ，即能不能调的问题。）</strong></p>
<h3 id="1-2-开发中到底用直接new还是反射的方式调用公共结构？"><a href="#1-2-开发中到底用直接new还是反射的方式调用公共结构？" class="headerlink" title="1.2 开发中到底用直接new还是反射的方式调用公共结构？"></a>1.2 开发中到底用直接new还是反射的方式调用公共结构？</h3><p><strong>建议：</strong>直接使用new的方式调用公共结构；</p>
<p><strong>什么时候会用反射的方式：</strong>反射的特征是动态性，在编译时无法确定要new哪个类的对象时可以选用反射；</p>
<h2 id="2-反射常用API的使用"><a href="#2-反射常用API的使用" class="headerlink" title="2. 反射常用API的使用"></a>2. 反射常用API的使用</h2><h3 id="2-1-获取反射中的Class实例"><a href="#2-1-获取反射中的Class实例" class="headerlink" title="2.1 获取反射中的Class实例"></a>2.1 获取反射中的Class实例</h3><h4 id="2-1-1-调用Class的静态方法：Class-forname-String-classPath"><a href="#2-1-1-调用Class的静态方法：Class-forname-String-classPath" class="headerlink" title="2.1.1 调用Class的静态方法：Class.forname(String classPath)"></a>2.1.1 调用Class的静态方法：Class.forname(String classPath)</h4><p>当可以知道该类的全路径名时，推荐优先使用使用该方法获取 Class 类对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-调用运行时类的属性：类名-class"><a href="#2-1-2-调用运行时类的属性：类名-class" class="headerlink" title="2.1.2 调用运行时类的属性：类名.class"></a>2.1.2 调用运行时类的属性：类名.class</h4><p>这种方法只适合在编译前就知道操作的 Class;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-通过运行时类的对象：对象名-getClass"><a href="#2-1-3-通过运行时类的对象：对象名-getClass" class="headerlink" title="2.1.3 通过运行时类的对象：对象名.getClass()"></a>2.1.3 通过运行时类的对象：对象名.getClass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-使用类的加载器：ClassLoader"><a href="#2-1-4-使用类的加载器：ClassLoader" class="headerlink" title="2.1.4 使用类的加载器：ClassLoader"></a>2.1.4 使用类的加载器：ClassLoader</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-创建运行时类的对象"><a href="#2-2-创建运行时类的对象" class="headerlink" title="2.2 创建运行时类的对象"></a>2.2 创建运行时类的对象</h3><h4 id="2-2-1-通过-Class类对象的-newInstance-方法"><a href="#2-2-1-通过-Class类对象的-newInstance-方法" class="headerlink" title="2.2.1 通过 Class类对象的 newInstance() 方法"></a>2.2.1 通过 Class类对象的 newInstance() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)clazz.newInstance();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-通过-Constructor构造器对象的-newInstance-方法"><a href="#2-2-2-通过-Constructor构造器对象的-newInstance-方法" class="headerlink" title="2.2.2 通过 Constructor构造器对象的 newInstance() 方法"></a>2.2.2 通过 Constructor构造器对象的 newInstance() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是：</strong>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p>
<h3 id="2-3-获取运行时类的属性、方法、构造器"><a href="#2-3-获取运行时类的属性、方法、构造器" class="headerlink" title="2.3 获取运行时类的属性、方法、构造器"></a>2.3 获取运行时类的属性、方法、构造器</h3><h4 id="2-3-1-获取运行时类的属性"><a href="#2-3-1-获取运行时类的属性" class="headerlink" title="2.3.1 获取运行时类的属性"></a>2.3.1 获取运行时类的属性</h4><ul>
<li><code>getFields()</code>：获取当前运行时类及其父类中声明为public访问权限的属性；</li>
<li><code>getDeclaredFields()</code>：获取当前运行时类中声明的所有属性（不包括父类中声明的属性）；</li>
</ul>
<h4 id="2-3-2-获取运行时类的方法"><a href="#2-3-2-获取运行时类的方法" class="headerlink" title="2.3.2 获取运行时类的方法"></a>2.3.2 获取运行时类的方法</h4><ul>
<li><code>getMethods()</code>：获取当前运行时类及其父类中声明为public访问权限的方法；</li>
<li><code>getDeclaredMethods()</code>：获取当前运行时类中声明的所有方法（不包括父类中声明的属性）；</li>
</ul>
<h4 id="2-3-3-获取运行时类的构造器"><a href="#2-3-3-获取运行时类的构造器" class="headerlink" title="2.3.3 获取运行时类的构造器"></a>2.3.3 获取运行时类的构造器</h4><ul>
<li><code>getConstructors()</code>：获取当前运行时类中声明为public访问权限的构造器；</li>
<li><code>getDeclaredConstructors()</code>：获取当前运行时类中声明的所有构造器；</li>
</ul>
<h3 id="2-4-调用运行时类的指定属性、方法"><a href="#2-4-调用运行时类的指定属性、方法" class="headerlink" title="2.4 调用运行时类的指定属性、方法"></a>2.4 调用运行时类的指定属性、方法</h3><h4 id="2-4-1-调用运行时类的指定属性"><a href="#2-4-1-调用运行时类的指定属性" class="headerlink" title="2.4.1 调用运行时类的指定属性"></a>2.4.1 调用运行时类的指定属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以自定义类Person为例：</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"><span class="comment">//创建运行时类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取运行时类中指定变量名的属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证当前属性时可访问的</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取、设置指定对象的此属性值</span></span><br><span class="line"><span class="comment">//set()：参数1指明设置哪个对象的属性，参数2设置具体的当前属性值</span></span><br><span class="line">name.set(p, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="comment">//get()：参数指明获取哪个对象的当前属性值</span></span><br><span class="line">System.out.println(name.get(p));</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-调用运行时类的指定方法"><a href="#2-4-2-调用运行时类的指定方法" class="headerlink" title="2.4.2 调用运行时类的指定方法"></a>2.4.2 调用运行时类的指定方法</h4><p><strong>一、对于非静态方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以自定义类Person为例：</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"><span class="comment">//创建运行时类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定的某个方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethd(方法名, 可变形参);</span><br><span class="line"><span class="comment">//保证当前方法是可访问的</span></span><br><span class="line">show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//调用invoke()</span></span><br><span class="line"><span class="comment">// invoke()：参数1是方法的调用者，参数2是给方法形参赋值的实参，invoke()的返回值即为对应类中调用的方法的返回值</span></span><br><span class="line">show.invoke(p, 实参)</span><br></pre></td></tr></table></figure>

<p><strong>二、对于静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethd(方法名);</span><br><span class="line">showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//静态方法使用当前类去调用，使用当前类.class的形式</span></span><br><span class="line">showDesc.invoke(Person.class)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的IO流学习笔记</title>
    <url>/2020/03/04/Java%E7%9A%84IO%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人在学习Java的IO流知识时所记录的笔记，涉及IO流的基础知识；</p>
<span id="more"></span>

<h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h2><h3 id="1-1-File类基本概念"><a href="#1-1-File类基本概念" class="headerlink" title="1.1 File类基本概念"></a>1.1 File类基本概念</h3><ol>
<li>File类的一个对象，代表一个文件或一个文件目录；</li>
<li>File类声明在java.io包下；</li>
<li>创建实例的三种方式：<ul>
<li>File(String filePath)<br>①相对路径：相较于某个路径下指明的路径<br>②绝对路径：包含盘符在内的文件或文件目录的路径</li>
<li>File(String parentPath, String childPath)</li>
<li>File(File parentPath, String childPath)</li>
</ul>
</li>
<li>File类的对象常会作为参数传递到流的构造器中，指明读取或写入的终点；</li>
</ol>
<p><strong>注意：</strong>涉及读取或写入文件内容必须使用IO流来完成；</p>
<h3 id="1-2-File类常用方法"><a href="#1-2-File类常用方法" class="headerlink" title="1.2 File类常用方法"></a>1.2 File类常用方法</h3><p><strong>获取功能：</strong></p>
<ol>
<li><code>String getAbsolutePath()</code>：获取绝对路径</li>
<li><code>String getPath()</code>：获取路径</li>
<li><code>String getName()</code>：获取名称</li>
<li><code>String getParent()</code>：获取上层文件目录路径，若没有就返回null</li>
<li><code>Long length()</code>：获取文件长度，不能获取目录的长度</li>
<li><code>Long lastModified()</code>：获取最后一次的修改时间(ms)</li>
<li><code>String[] list()</code>：获取指定目录下的所有文件或文件目录的名称数组</li>
<li><code>File[] listFiles()</code>：获取指定目录下的所有文件或文件目录的File数组</li>
</ol>
<p><strong>重命名功能：</strong></p>
<ol start="9">
<li><p><code>boolean renameTo(File dest)</code>：把文件重命名为指定的文件路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> file1.renameTo(file2)</span><br><span class="line"><span class="comment">// 注意：要想返回true，需要file1在硬盘中必须存在，且file2不能在硬盘中存在；</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>判断功能：</strong></p>
<ol start="10">
<li><code>boolean isDirectory()</code>：判断是否是文件目录</li>
<li><code>boolean isFile()</code>：判断是否是文件</li>
<li><code>boolean exists()</code>：判断是否存在</li>
<li><code>boolean canRead()</code>：判断是否可读</li>
<li><code>boolean canWrite()</code>：判断是否可写</li>
<li><code>boolean isHidden()</code>：判断是否隐藏</li>
</ol>
<p><strong>创建和删除功能：</strong></p>
<ol start="16">
<li><code>boolean createNewFile()</code>：创建文件，若文件已存在返回false</li>
<li><code>boolean mkdir()</code>：创建文件目录，上层目录不存在就不创建</li>
<li><code>boolean mkdirs()</code>：创建文件目录，上层目录不存在就一并创建</li>
<li><code>boolean delete()</code>：删除文件或文件夹</li>
</ol>
<h2 id="2-节点流（文件流）"><a href="#2-节点流（文件流）" class="headerlink" title="2. 节点流（文件流）"></a>2. 节点流（文件流）</h2><p><strong>注意：</strong>字符流不能用来处理图片等字节数据，处理字节数据要用字节流；</p>
<p><strong>总结：</strong>字节流和字符流的读写操作基本步骤一致，都是分为4步；</p>
<h3 id="2-1-字节流"><a href="#2-1-字节流" class="headerlink" title="2.1 字节流"></a>2.1 字节流</h3><h4 id="2-1-1-字节输入流：FileInputStream"><a href="#2-1-1-字节输入流：FileInputStream" class="headerlink" title="2.1.1 字节输入流：FileInputStream"></a>2.1.1 字节输入流：FileInputStream</h4><p><strong>FileInputStream读取非文本文件基本操作：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明要操作的文件：</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>FileInputStream流的实例化，提供具体的流：</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入操作</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; <span class="comment">// 记录每次读取的字节的个数 </span></span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">	System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流的关闭操作</span><br><span class="line"><span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">	fis.close( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="number">1.</span>对于文本文件(.txt, .java, .c, .cpp等)建议使用字符流处理，字节流处理可能出现乱码；</span><br><span class="line"><span class="number">2.</span>对于非文本文件(图片、视频等)必须使用字节流处理；</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-字节输出流：FileOutputStream"><a href="#2-1-2-字节输出流：FileOutputStream" class="headerlink" title="2.1.2 字节输出流：FileOutputStream"></a>2.1.2 字节输出流：FileOutputStream</h4><p><strong>使用FileInputStream和FileOutputStream实现非文本文件的复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件： </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象：</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);  </span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 （复制过程）</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>];</span><br><span class="line"><span class="comment">// 记录每次读入到buffer数组中的字符的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.read(buffer); </span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//每次写出len个字符，从0开始</span></span><br><span class="line">	fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;  </span><br><span class="line">	fis.close( ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;  </span><br><span class="line">	fos.close( ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-字符流"><a href="#2-2-字符流" class="headerlink" title="2.2 字符流"></a>2.2 字符流</h3><h4 id="2-2-1-字符输入流：FileReader"><a href="#2-2-1-字符输入流：FileReader" class="headerlink" title="2.2.1 字符输入流：FileReader"></a>2.2.1 字符输入流：FileReader</h4><p><strong>FileReader读入数据基本操作步骤：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明要操作的文件：</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>；</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"><span class="comment">//相对地址相较于当前Module</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Filereader流的实例化，提供具体的流：</span><br><span class="line">fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="comment">//读入的文件一定要存在，否则就会报FileNotFoundException</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入操作</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fr.read( );</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.println((<span class="type">char</span>)data);</span><br><span class="line">	data = fr.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//read( )：返回读入的一个字符，如果到达文件末尾返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流的关闭操作</span><br><span class="line"><span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">	fr.close( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理，把close()放在finally块中</span></span><br></pre></td></tr></table></figure>

<p>使用read的重载方法<code>read(char[ ] cbuf)</code>进行读入操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fr.read(cbuf);</span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 方式一：遍历char[]数组,注意此处i&lt;len不可以写成 i&lt;cbuf.length</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">		System.out.print(cbuf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：将char[]数组转换为str再遍历字符串,注意不可以只写cbuf，要指定范围</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">	System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read(char[ ] cbuf)：返回每次读入cbuf数组中字符的个数，如果到达文件末尾返回-1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-字符输出流：FileWriter"><a href="#2-2-2-字符输出流：FileWriter" class="headerlink" title="2.2.2 字符输出流：FileWriter"></a>2.2.2 字符输出流：FileWriter</h4><p><strong>FileWriter写出数据基本操作步骤：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明写出到的文件： </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>； </span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>FileWriter流的实例化，用于数据写出： </span><br><span class="line">fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的写出操作 </span><br><span class="line">fw.write(<span class="string">&quot;String&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123; </span><br><span class="line">	fw.close( ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="number">1.</span>输出操作，对应的File如果不存在，在输出的过程中会自动创建此文件；</span><br><span class="line"><span class="number">2.</span>对应的File如果存在，根据构造器不同:</span><br><span class="line">	<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file)会对原有文件进行覆盖</span><br><span class="line">	<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>)不会对原有文件进行覆盖，而是在原有文件基础上追加内容</span><br></pre></td></tr></table></figure>

<p><strong>使用FileReader和FileWriter实现文本文件的复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件： </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象：</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);  </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 （复制过程）</span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>];</span><br><span class="line"><span class="comment">// 记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fr.read(cbuf); </span><br><span class="line"><span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//每次写出len个字符，从0开始</span></span><br><span class="line">	fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123; </span><br><span class="line">	fr.close( ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123; </span><br><span class="line">	fw.close( ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-处理流"><a href="#3-处理流" class="headerlink" title="3. 处理流"></a>3. 处理流</h2><h3 id="3-1-缓冲流"><a href="#3-1-缓冲流" class="headerlink" title="3.1 缓冲流"></a>3.1 缓冲流</h3><p><strong>作用：</strong>内部提供了一个缓冲区，提高流的读取和写入的速度；(因此缓冲流读写速度快于文件流)</p>
<h4 id="3-1-1-字节型"><a href="#3-1-1-字节型" class="headerlink" title="3.1.1 字节型"></a>3.1.1 字节型</h4><p>作用在InputStream上：BufferedInputStream</p>
<p>作用在OutputStream上：BufferedOutputStream</p>
<p><strong>使用BufferedInputStream和BufferedOutputStream实现非文本文件复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件:（造文件）</span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象:（造流）</span><br><span class="line"><span class="comment">// 先造内层的节点流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile); </span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(destFile); </span><br><span class="line"><span class="comment">// 再造外层的缓冲流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 ：（复制过程） </span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line"> 	bos.write(buffer, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作 </span><br><span class="line"><span class="comment">// 要求：先关闭外层的流，再关闭内层的流（即造流先内后外，关流先外后内）</span></span><br><span class="line">bos.close( ); </span><br><span class="line">bis.close( ); </span><br><span class="line"><span class="comment">// 说明：关闭外层流的同时，内层流也会自动地进行关闭，关于内层流的关闭操作其实可以省略</span></span><br><span class="line">fos.close( ); </span><br><span class="line">fis.close( ); </span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-字符型"><a href="#3-1-2-字符型" class="headerlink" title="3.1.2 字符型"></a>3.1.2 字符型</h4><p>作用在FileReader上：BufferedReader</p>
<p>作用在FileWriter上：BufferedWriter</p>
<p><strong>使用BufferedReader和BufferedWriter实现文本文件复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>实例化File类的对象，指明读入和写出的文件:（造文件） </span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath)； </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建输入流和输出流的对象:（造流） </span><br><span class="line"><span class="comment">// 先造内层的节点流 </span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile); </span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile); </span><br><span class="line"><span class="comment">// 再造外层的缓冲流 </span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr); </span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数据的读入和写出操作 ：（复制过程） </span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = br.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	bw.write(cbuf, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>流资源的关闭操作</span><br><span class="line"><span class="comment">// 内层文件流会在外层缓冲流关闭时自动关闭，因此可以省略文件流的关闭步骤</span></span><br><span class="line">br.close( ); </span><br><span class="line">bw.close( ); </span><br></pre></td></tr></table></figure>

<h3 id="3-2-转换流"><a href="#3-2-转换流" class="headerlink" title="3.2 转换流"></a>3.2 转换流</h3><p><strong>作用：</strong>提供了在字节流和字符流之间的转换，本身属于字符流；</p>
<p>将一个字节的输入流转换为字符的输入流（解码）：InputStreamReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 造文件、造流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String filepath)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数2指明字符集，具体使用哪个字符集取决于文件保存时使用的字符集 </span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure>

<p>将一个字符的输出流转换为字节的输出流（编码）：OutputStreamWriter</p>
<p><strong>切换字符集实现文件读入与写出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String path));</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String path));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStream -&gt; Reader(字节流转换为字符流)</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="comment">// Writer -&gt; OutputStream(字符流转换为字节流)</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len; </span><br><span class="line"><span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123; </span><br><span class="line">	osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">isr.close();</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure>

<h3 id="3-3-对象流"><a href="#3-3-对象流" class="headerlink" title="3.3 对象流"></a>3.3 对象流</h3><p><strong>作用：</strong>用于存储和读取基本数据类型数据或对象的处理流，可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来；</p>
<p><strong>对象序列化机制：</strong>允许把内存中任何实现了Serializable接口的对象转换成与平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象；</p>
<p><strong>ObjectOutputStream序列化：对象写入到数据源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>造文件、造节点流和处理流</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;object.data&quot;</span>)</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file))</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>写出对象</span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a example&quot;</span>));</span><br><span class="line"><span class="comment">//刷新操作</span></span><br><span class="line">oos.flush( ); </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源</span><br><span class="line">oos.close( );</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInputStream反序列化：从数据源还原对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化：将磁盘文件中的对象还原为内存中的一个Java对象</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>造文件、造节点流和处理流 </span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;object.data&quot;</span>) </span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>读取对象   </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) ois.readObject( );</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源 </span><br><span class="line">ois.close( );</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<h3 id="3-4-其他流"><a href="#3-4-其他流" class="headerlink" title="3.4 其他流"></a>3.4 其他流</h3><h4 id="3-4-1-标准输入流、输出流"><a href="#3-4-1-标准输入流、输出流" class="headerlink" title="3.4.1 标准输入流、输出流"></a>3.4.1 标准输入流、输出流</h4><ul>
<li><p>System.in：标准的输入流，默认从键盘输入</p>
</li>
<li><p>System.out：标准的输出流，默认从控制台输出</p>
<p><strong>注意：</strong>可以通过System类的<code>setIn(InputStream is)</code> / <code>setOut(PrintStream ps)</code>方式重新指定输入和输出的流；</p>
</li>
</ul>
<h4 id="3-4-2-打印流"><a href="#3-4-2-打印流" class="headerlink" title="3.4.2 打印流"></a>3.4.2 打印流</h4><p><strong>作用：</strong>将基本数据类型的数据格式转化为字符串输出；</p>
<ul>
<li>字节输出流：PrintStream</li>
<li>字符输出流：PrintWriter</li>
</ul>
<h4 id="3-4-3-数据流"><a href="#3-4-3-数据流" class="headerlink" title="3.4.3 数据流"></a>3.4.3 数据流</h4><p><strong>作用：</strong>用于读取或写出基本数据类型的变量或字符串；</p>
<ul>
<li>DateInputStream：将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中</li>
<li>DateOutputStream：将内存中的字符串、基本数据类型的变量写出到文件中</li>
</ul>
<p><strong>注意：</strong>读取不同类型的数据的顺序要与当初写入文件时保存的数据的顺序一致；</p>
<h4 id="3-4-4-随机存取文件流"><a href="#3-4-4-随机存取文件流" class="headerlink" title="3.4.4 随机存取文件流"></a>3.4.4 随机存取文件流</h4><ul>
<li>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口，既可作为输入流，也可作为输出流；</li>
<li>RandomAccessFile支持随机访问方式，程序可以直接跳到文件的任意地方读、写文件（由于其对象包含一个记录指针用以标示当前读写处的位置），支持只访问文件的部分内容，或者向已存在的文件后追加内容；</li>
<li>如果RandomAccessFile作为输出流时，写出到的文件如果不存在则会在执行过程中自动创建，如果已经存在则会对原有文件内容从头覆盖；</li>
</ul>
<p><strong>RandomAccessFile实现数据的读写操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建两个对象，一个用于写入，一个用于读取</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mode参数指定RandomAccessFile的访问模式：</span></span><br><span class="line"><span class="comment">访问模式有以下4种：</span></span><br><span class="line"><span class="comment">r：以只读方式打开</span></span><br><span class="line"><span class="comment">rw：打开以便读取和写入</span></span><br><span class="line"><span class="comment">rwd：打开以便读取和写入，并同步文件内容的更新</span></span><br><span class="line"><span class="comment">rws：打开以便读取和写入，并同步文件内容和元数据的更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String pathname, mode))</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(String pathname, mode))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[ ] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>]; </span><br><span class="line"><span class="type">int</span> len;  </span><br><span class="line"><span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line"> 	raf2.write(buffer, <span class="number">0</span>, len); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raf1.close();</span><br><span class="line">raf2.close();</span><br></pre></td></tr></table></figure>

<p><strong>RandomAccessFile实现数据的插入操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法：<span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span>：将文件记录指针定位到角标为pos位置</span><br><span class="line"></span><br><span class="line">如何实现插入新的数据而不会覆盖后面数据的效果?</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将指针调到角标为pos的位置</span></span><br><span class="line">raf.seek(pos); </span><br><span class="line"><span class="comment">//保存指针pos后面的所有数据到StringBuilder中</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>().length);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[ ] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="type">int</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = raf.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调指针到pos，写入要插入到pos后的内容</span></span><br><span class="line">raf.seek(pos); </span><br><span class="line">raf.write(<span class="string">&quot;String&quot;</span>.getBytes())</span><br><span class="line"><span class="comment">//将StringBuilder中保存的数据重新写入到文件中</span></span><br><span class="line">raf.write(builder.toString().getBytes())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
