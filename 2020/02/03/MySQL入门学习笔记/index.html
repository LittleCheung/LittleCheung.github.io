<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"littlecheung.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言这是个人刚开始学习MySQL数据库时所记录的一些笔记，总结成十几章内容，包括基本增删改查操作语句，创建数据库，创建修改数据表，约束，视图，存储过程和函数，变量，流程控制和触发器等内容，适合刚开始接触数据库学习的小伙伴o(￣▽￣)ブ">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL入门学习笔记">
<meta property="og:url" content="https://littlecheung.github.io/2020/02/03/MySQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="小张的个人博客">
<meta property="og:description" content="前言这是个人刚开始学习MySQL数据库时所记录的一些笔记，总结成十几章内容，包括基本增删改查操作语句，创建数据库，创建修改数据表，约束，视图，存储过程和函数，变量，流程控制和触发器等内容，适合刚开始接触数据库学习的小伙伴o(￣▽￣)ブ">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-03T09:20:34.000Z">
<meta property="article:modified_time" content="2022-03-04T05:28:42.721Z">
<meta property="article:author" content="Lucas Cheung">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://littlecheung.github.io/2020/02/03/MySQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL入门学习笔记 | 小张的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小张的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人充电 | 生活点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/LittleCheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlecheung.github.io/2020/02/03/MySQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Littlecheung.jpg">
      <meta itemprop="name" content="Lucas Cheung">
      <meta itemprop="description" content="坂道偶像宅 | 后端打工人 | 小镇青年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小张的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL入门学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-03 17:20:34" itemprop="dateCreated datePublished" datetime="2020-02-03T17:20:34+08:00">2020-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 13:28:42" itemprop="dateModified" datetime="2022-03-04T13:28:42+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是个人刚开始学习MySQL数据库时所记录的一些笔记，总结成十几章内容，包括基本增删改查操作语句，创建数据库，创建修改数据表，约束，视图，存储过程和函数，变量，流程控制和触发器等内容，适合刚开始接触数据库学习的小伙伴o(<em>￣▽￣</em>)ブ</p>
<span id="more"></span>

<h1 id="第-01-章-数据库概述"><a href="#第-01-章-数据库概述" class="headerlink" title="第 01 章 数据库概述"></a>第 01 章 数据库概述</h1><h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><ul>
<li>持久化(persistence)： 把数据保存到可掉电式存储设备中以供之后使用 。大多数情况下，特别是企</li>
</ul>
<p>业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以保存 ，而持久化的实现过程大多</p>
<p>通过各种关系数据库来完成。</p>
<ul>
<li>持久化的主要作用：将内存中的数据存储在关系型数据库中。</li>
</ul>
<h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2. 1 数据库的相关概念"></a>2. 1 数据库的相关概念</h3><ul>
<li><p>DB：数据库（Database），其本质是一个文件系统。它保存了一系列有组织的数据。</p>
</li>
<li><p>DBMS：数据库管理系统（Database Management System），是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</p>
</li>
<li><p>SQL：结构化查询语言（Structured Query Language）专门用来与数据库通信的语言。</p>
</li>
</ul>
<h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2. 2 数据库与数据库管理系统的关系"></a>2. 2 数据库与数据库管理系统的关系</h3><p>数据库管理系统(DBMS)可以管理多个数据库(DB)，为保存应用中实体的数据，在数据库创建会多个表以保存程序中实体用户的数据。</p>
<h2 id="3-RDBMS-与-非RDBMS"><a href="#3-RDBMS-与-非RDBMS" class="headerlink" title="3. RDBMS 与 非RDBMS"></a>3. RDBMS 与 非RDBMS</h2><h3 id="3-1-关系型数据库-RDBMS"><a href="#3-1-关系型数据库-RDBMS" class="headerlink" title="3.1 关系型数据库(RDBMS)"></a>3.1 关系型数据库(RDBMS)</h3><h4 id="3-1-1-实质"><a href="#3-1-1-实质" class="headerlink" title="3. 1. 1 实质"></a>3. 1. 1 实质</h4><ul>
<li><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。</p>
</li>
<li><p>关系型数据库以行(row)和列(column)的形式存储数据，这一系列的行和列被称为表(table)，一组表组成了一个库(database)。</p>
</li>
<li><p>关系型数据库，就是建立在关系模型基础上的数据库。</p>
</li>
<li><p>SQL 是关系型数据库的查询语言。</p>
</li>
</ul>
<h4 id="3-1-2-优势"><a href="#3-1-2-优势" class="headerlink" title="3. 1. 2 优势"></a>3. 1. 2 优势</h4><ul>
<li><p>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
</li>
<li><p>事务支持：使得对于安全性能很高的数据访问要求得以实现。</p>
</li>
</ul>
<h3 id="3-2-非关系型数据库-非RDBMS"><a href="#3-2-非关系型数据库-非RDBMS" class="headerlink" title="3. 2 非关系型数据库(非RDBMS)"></a>3. 2 非关系型数据库(非RDBMS)</h3><h4 id="非关系型数据库种类"><a href="#非关系型数据库种类" class="headerlink" title="非关系型数据库种类"></a>非关系型数据库种类</h4><ol>
<li><p>键值型数据库</p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，就会消耗大量的计算。键值型数据库典型的使用场景是作为内存缓存。Redis是最流行的键值型数据库。</p>
</li>
<li><p>文档型数据库</p>
<p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。</p>
</li>
<li><p>搜索引擎数据库</p>
<p>搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。典型产品有Solr、Elasticsearch、Splunk 等。</p>
</li>
<li><p>列式数据库</p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足之处在于功能相对有限。典型产品有HBase等。</p>
</li>
<li><p>图形数据库</p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。图形数据库就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。典型产品有Neo4J、InfoGrid等。</p>
</li>
</ol>
<h1 id="第-02-章-SELECT语句"><a href="#第-02-章-SELECT语句" class="headerlink" title="第 02 章 SELECT语句"></a>第 02 章 SELECT语句</h1><h2 id="1-基本SELECT语句"><a href="#1-基本SELECT语句" class="headerlink" title="1. 基本SELECT语句"></a>1. 基本SELECT语句</h2><h3 id="1-1-SELECT-…-FROM-…"><a href="#1-1-SELECT-…-FROM-…" class="headerlink" title="1. 1 SELECT … FROM …"></a>1. 1 SELECT … FROM …</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span> 标识从哪个表中选择</span><br></pre></td></tr></table></figure>
<p>选择全部列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<h3 id="1-2-列的别名"><a href="#1-2-列的别名" class="headerlink" title="1. 2 列的别名"></a>1. 2 列的别名</h3><p><strong>别名使用方法</strong>：紧跟列名，也可以 在列名和别名之间加入关键字<strong>AS</strong>，别名使用双引号 ，以便在别名中包含空格或特殊的字符并区分大小写。AS 可以省略，在实际使用时建议别名简短，见名知意；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> name, commission_pct comm</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-去除重复行"><a href="#1-3-去除重复行" class="headerlink" title="1. 3 去除重复行"></a>1. 3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行，在SELECT语句中使用关键字<strong>DISTINCT</strong>去除重复行；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p>要注意的是：</p>
<ol>
<li><p>DISTINCT 需要放到所有列名的前面，否则会报错。</p>
</li>
<li><p>DISTINCT 其实是对后面所有列名的组合进行去重。</p>
</li>
</ol>
<h3 id="1-4-空值参与运算"><a href="#1-4-空值参与运算" class="headerlink" title="1. 4 空值参与运算"></a>1. 4 空值参与运算</h3><p>所有运算符或列值遇到null值，运算的结果都为null</p>
<p>值得注意的是，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0 ，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h3 id="1-5-查询常数"><a href="#1-5-查询常数" class="headerlink" title="1. 5 查询常数"></a>1. 5 查询常数</h3><ul>
<li><p>SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p>
</li>
<li><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
</li>
</ul>
<h2 id="2-过滤数据"><a href="#2-过滤数据" class="headerlink" title="2. 过滤数据"></a>2. 过滤数据</h2><p>语法：使用<strong>WHERE子句</strong>，将不满足条件的行过滤掉，WHERE子句紧随 FROM子句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段 <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 过滤条件</span><br></pre></td></tr></table></figure>


<h1 id="第-03-章-运算符"><a href="#第-03-章-运算符" class="headerlink" title="第 03 章 运算符"></a>第 03 章 运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。</p>
<ol>
<li>加法与减法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</p>
</li>
<li><p>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</p>
</li>
<li><p>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</p>
</li>
<li><p>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按 0 计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</p>
</li>
</ul>
<ol start="2">
<li>乘法与除法运算符</li>
</ol>
<p>由运算结果可以得出如下结论：</p>
<ul>
<li><p>一个数乘以整数 1 和除以整数 1 后仍得原数；</p>
</li>
<li><p>一个数乘以浮点数 1 和除以浮点数 1 后变成浮点数，数值与原数相等；</p>
</li>
<li><p>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</p>
</li>
<li><p>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后 4 位；</p>
</li>
<li><p>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</p>
</li>
<li><p>在数学运算中， 0 不能用作除数，在MySQL中，一个数除以 0 为NULL。</p>
</li>
</ul>
<ol start="3">
<li>求模（求余）运算符</li>
</ol>
<h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1 ，比较的结果为假则返回 0 ，其他情况则返回NULL。比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<ol>
<li><p>等号运算符</p>
<p>等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回 1 ，不相等则返回0 。</p>
<p>在使用等号运算符时，遵循如下规则：</p>
</li>
</ol>
<ul>
<li><p>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</p>
</li>
<li><p>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</p>
</li>
<li><p>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</p>
</li>
<li><p>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</p>
</li>
</ul>
<ol start="2">
<li><p>安全等于运算符</p>
<p>安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，唯一的区别是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为 1 ，而不为NULL；当一个操作数为NULL时，其返回值为 0 ，而不为NULL。</p>
</li>
<li><p>不等于运算符 </p>
<p>不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回 1 ，相等则返回 0 。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 </p>
</li>
<li><p>空运算符 </p>
<p>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回 1 ，否则返回0 。</p>
</li>
<li><p>非空运算符 </p>
<p>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回 1 ，否则返回 0 。 </p>
</li>
<li><p>最小值运算符 </p>
<p>语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>最大值运算符 </p>
<p>语法格式为：GREATEST(值 1 ，值 2 ，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
</li>
<li><p>BETWEEN AND运算符 </p>
<p>BETWEEN运算符使用的格式通常为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D <span class="keyword">FROM</span> <span class="keyword">TABLE</span> </span><br><span class="line"><span class="keyword">WHERE</span> C <span class="keyword">BETWEEN</span> A <span class="keyword">AND</span> B</span><br></pre></td></tr></table></figure>

<p>此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0 。</p>
</li>
<li><p>IN运算符 </p>
<p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
</li>
<li><p>NOT IN运算符 </p>
<p>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回 1 ，否则返回 0 。</p>
</li>
<li><p>LIKE运算符</p>
<p>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回 1 ，否则返回0 。如果给定的值或者匹配条件为NULL，则返回结果为NULL。LIKE运算符通常与通配符一起使用。</p>
</li>
<li><p>REGEXP运算符</p>
<p>REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1 ；如果不满足，则返回 0 。若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
</li>
</ol>
<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为 1 、 0 或者NULL。</p>
<p>MySQL中支持 4 种逻辑运算符如下：</p>
<ol>
<li><p>逻辑非运算符 </p>
<p>逻辑非（NOT或!）运算符表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL。</p>
</li>
<li><p>逻辑与运算符 </p>
<p>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL。</p>
</li>
<li><p>逻辑或运算符 </p>
<p>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
</li>
</ol>
<p><strong>注意</strong>：OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
<ol start="4">
<li><p>逻辑异或运算符 </p>
<p>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1 。</p>
</li>
</ol>
<h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<ol>
<li><p>按位与运算符 </p>
<p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位或运算符 </p>
<p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位异或运算符 </p>
<p>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0 。</p>
</li>
<li><p>按位取反运算符 </p>
<p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</p>
</li>
</ol>
<p><strong>注意</strong>：由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以 10 &amp; ~ 1 ，首先，对数字 1 进</p>
<p>行按位取反操作，结果除了最低位为 0 ，其他位都为 1 ，然后与 10 进行按位与操作，结果为 10 。</p>
<ol start="5">
<li><p>按位右移运算符 </p>
<p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。</p>
</li>
<li><p>按位左移运算符 按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐。</p>
</li>
</ol>
<h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p>结论：赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p>
<h1 id="第-04-章-排序与分页"><a href="#第-04-章-排序与分页" class="headerlink" title="第 04 章 排序与分页"></a>第 04 章 排序与分页</h1><h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1. 1 排序规则"></a>1. 1 排序规则</h3><p>使用 <strong>ORDER BY 子句</strong>进行排序，ASC（ascend）为升序，DESC（descend）为降序，ORDER BY 子句在SELECT语句的结尾。</p>
<h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1. 2 单列排序"></a>1. 2 单列排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 例子如下：</span><br><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date ;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1. 3 多列排序"></a>1. 3 多列排序</h3><p>可以使用不在SELECT列表中的列排序。在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</p>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-分页规则"><a href="#2-1-分页规则" class="headerlink" title="2. 1 分页规则"></a>2. 1 分页规则</h3><p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。MySQL中使用 **LIMIT **实现分页，LIMIT 子句必须放在整个SELECT语句的最后！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [位置偏移量],行数</span><br></pre></td></tr></table></figure>

<p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
<p><strong>举例</strong>：MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第 5 条记录开始后面的 3 条记录，和“LIMIT4,3;”返回的结果相同。</p>
<p><strong>分页显式公式</strong>：LIMIT（当前页数- 1 ）*每页条数，每页条数</p>
<p><strong>使用 LIMIT 的好处</strong>：约束返回结果的数量可以减少据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回；</p>
<h1 id="第-05-章-多表查询"><a href="#第-05-章-多表查询" class="headerlink" title="第 05 章 多表查询"></a>第 05 章 多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p><strong>前提条件</strong>：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<h2 id="1-笛卡尔积产生的问题"><a href="#1-笛卡尔积产生的问题" class="headerlink" title="1. 笛卡尔积产生的问题"></a>1. 笛卡尔积产生的问题</h2><h3 id="1-1-笛卡尔积（或交叉连接）的理解"><a href="#1-1-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1. 1 笛卡尔积（或交叉连接）的理解"></a>1. 1 笛卡尔积（或交叉连接）的理解</h3><ul>
<li><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p>
</li>
<li><p>SQL 92 中，笛卡尔积也称为交叉连接，英文是 CROSS JOIN。在 SQL 99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。</p>
</li>
</ul>
<h3 id="1-2-分析与问题解决"><a href="#1-2-分析与问题解决" class="headerlink" title="1. 2 分析与问题解决"></a>1. 2 分析与问题解决</h3><p>笛卡尔积的错误会在下面条件下产生 ：</p>
<ol>
<li><p>省略多个表的连接条件（或关联条件）</p>
</li>
<li><p>连接条件（或关联条件）无效</p>
</li>
<li><p>所有表中的所有行互相连接</p>
</li>
</ol>
<p>为了避免笛卡尔积， 可以 在 WHERE 加入有效的连接条件。加入连接条件后，查询语法如下：</p>
<p><strong>在 WHERE子句中写入连接条件，在表中有相同列时，在列名之前加上表名前缀</strong></p>
<h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类-1-：等值连接-vs-非等值连接"><a href="#分类-1-：等值连接-vs-非等值连接" class="headerlink" title="分类 1 ：等值连接 vs 非等值连接"></a>分类 1 ：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> table1.column <span class="number">1</span> <span class="operator">=</span> table2.column <span class="number">2</span> ;  #连接条件为等号即为等值连接</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>多个连接条件与 AND 操作符</p>
</li>
<li><p>区分重复的列名，当多个表中有相同列时，必须在列名之前加上表名前缀，在不同表中具有相同列名的列可以用表名加以区分。</p>
</li>
<li><p>使用表的别名可以简化查询，列名前使用表名前缀可以提高查询效率。但需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p>
</li>
<li><p>连接 n个表,至少需要n- 1 个连接条件。 比如，连接三个表，至少需要两个连接条件。</p>
</li>
</ol>
<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>一个用户查询请求涉及到多个表的时候，连接两个表的条件为=时，就是等值连接连接；其他的运算符连接的就是非等值连接。<br><strong>注意</strong>：连接条件中的各连接字段类型必须是可比的，但不必是相同的，整型和浮点型是可比的，但是字符型和整型就不可比。</p>
<h3 id="分类-2-：自连接-vs-非自连接"><a href="#分类-2-：自连接-vs-非自连接" class="headerlink" title="分类 2 ：自连接 vs 非自连接"></a>分类 2 ：自连接 vs 非自连接</h3><p>自连接就是当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询操作。</p>
<h3 id="分类-3-：内连接-vs-外连接"><a href="#分类-3-：内连接-vs-外连接" class="headerlink" title="分类 3 ：内连接 vs 外连接"></a>分类 3 ：内连接 vs 外连接</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行；</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
<ul>
<li><p>如果是左外连接，则连接条件中左边的表也称为主表，右边的表称为从表。</p>
</li>
<li><p>如果是右外连接，则连接条件中右边的表也称为主表，左边的表称为从表。</p>
</li>
</ul>
<h4 id="SQL-92-语法：使用-创建连接"><a href="#SQL-92-语法：使用-创建连接" class="headerlink" title="SQL 92 语法：使用(+)创建连接"></a>SQL 92 语法：使用(+)创建连接</h4><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接，而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p>
<p>下面是SQL92关于外连接的语法：(层次性和可读性不强不推荐使用)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id(<span class="operator">+</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees ,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id(<span class="operator">+</span>) <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="3-SQL-99-语法实现多表查询"><a href="#3-SQL-99-语法实现多表查询" class="headerlink" title="3. SQL 99 语法实现多表查询"></a>3. SQL 99 语法实现多表查询</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3. 1 基本语法"></a>3. 1 基本语法</h3><p>使用JOIN…ON子句创建连接的语法结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column,table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3. 2 内连接(INNER JOIN)的实现"></a>3. 2 内连接(INNER JOIN)的实现</h3><p><strong>语法说明</strong>：</p>
<ul>
<li><p>可以使用 ON 子句指定额外的连接条件 ，这个连接条件是与其它条件分开的，ON 子句使语句具有更高的易读性 ；</p>
</li>
<li><p>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接；</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3. 3 外连接(OUTER JOIN)的实现"></a>3. 3 外连接(OUTER JOIN)的实现</h3><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3. 3. 1 左外连接(LEFT OUTER JOIN)"></a>3. 3. 1 左外连接(LEFT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3. 3. 2 右外连接(RIGHT OUTER JOIN)"></a>3. 3. 2 右外连接(RIGHT OUTER JOIN)</h4><p><strong>语法格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：LEFT JOIN 和 RIGHT JOIN 只存在于 SQL 99 及以后的标准中，在 SQL 92 中不存在，只能用 (+) 表示。</p>
<h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3. 3. 3 满外连接(FULL OUTER JOIN)"></a>3. 3. 3 满外连接(FULL OUTER JOIN)</h4><p>满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
<p>SQL 99 是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</p>
<p><strong>需要注意的是</strong>：MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。</p>
<h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><p>合并查询结果 利用<strong>UNION</strong>关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p>
<h5 id="语法格式："><a href="#语法格式：" class="headerlink" title="语法格式："></a>语法格式：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UNION操作符：UNION 操作符返回两个查询的结果集的并集，并去除重复记录。</p>
</li>
<li><p>UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
</li>
</ul>
<p><strong>注意</strong>：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
<h2 id="5-SQL-99-语法新特性"><a href="#5-SQL-99-语法新特性" class="headerlink" title="5. SQL 99 语法新特性"></a>5. SQL 99 语法新特性</h2><h3 id="5-1-自然连接"><a href="#5-1-自然连接" class="headerlink" title="5. 1 自然连接"></a>5. 1 自然连接</h3><p>SQL 99 在 SQL 92 的基础上提供了一些特殊语法，比如<strong>NATURAL JOIN</strong>用来表示自然连接。我们可以把自然连接理解为 SQL 92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。</p>
<p>在SQL 92 标准中写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br></pre></td></tr></table></figure>

<p>在 SQL 99 中你可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-USING连接"><a href="#5-2-USING连接" class="headerlink" title="5. 2 USING连接"></a>5. 2 USING连接</h3><p>当我们进行连接的时候，SQL 99 还支持使用 <strong>USING</strong> 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br></pre></td></tr></table></figure>

<p>与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure>



<h2 id="6-章节小结"><a href="#6-章节小结" class="headerlink" title="6. 章节小结"></a>6. 章节小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p>
<ul>
<li><p>WHERE：适用于所有关联查询</p>
</li>
<li><p>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</p>
</li>
<li><p>USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">where</span>后面</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#把关联条件写在<span class="keyword">on</span>后面，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#把关联字段写在<span class="keyword">using</span>()中，只能和<span class="keyword">JOIN</span>一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示<span class="operator">=</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs <span class="keyword">USING</span>(job_id);</span><br></pre></td></tr></table></figure>



<h1 id="第-06-章-聚合函数"><a href="#第-06-章-聚合函数" class="headerlink" title="第 06 章 聚合函数"></a>第 06 章 聚合函数</h1><p>区别于MySQL对单个值操作的单行函数，实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p>
<h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul>
<li><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p>
</li>
<li><p>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</p>
</li>
</ul>
<h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1. 1 AVG和SUM函数"></a>1. 1 AVG和SUM函数</h3><p>可以对数值型数据使用AVG 和 SUM 函数。</p>
<h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1. 2 MIN和MAX函数"></a>1. 2 MIN和MAX函数</h3><p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p>
<h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1. 3 COUNT函数"></a>1. 3 COUNT函数</h3><p>COUNT(*)返回表中记录总数，适用于任意数据类型 。COUNT(expr) 返回 expr不为空 的记录总数。</p>
<p><strong>问题1</strong>：用count(*)，count(1)，count(列名)谁好呢?</p>
<p>这取决于所用的引擎，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，好于具体的count(列名)。</p>
<p><strong>问题2</strong>：能不能使用count(列名)替换count(*)?</p>
<p>不要使用 count(列名)来替代 count(*)，count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2. 1 基本使用"></a>2. 1 基本使用</h3><p>可以使用<strong>GROUP BY子句</strong>将表中的数据分成若干组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2-2-GROUP-BY中使用WITH-ROLLUP"><a href="#2-2-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2. 2 GROUP BY中使用WITH ROLLUP"></a>2. 2 GROUP BY中使用WITH ROLLUP</h3><p>使用<strong>WITH ROLLUP</strong>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的。</p>
<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3. 1 基本使用"></a>3. 1 基本使用</h3><p>使用<strong>HAVING子句</strong>来过滤分组</p>
<p>使用情况如下：</p>
<ol>
<li><p>行已经被分组。</p>
</li>
<li><p>使用了聚合函数，注意不能在 WHERE 子句中使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span> <span class="number">10000</span> ;</span><br><span class="line"></span><br><span class="line"># 下面为错误的使用方法</span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure></li>
<li><p>满足HAVING 子句中条件的分组将被显示。</p>
</li>
<li><p>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</p>
</li>
</ol>
<h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3. 2 WHERE和HAVING的对比"></a>3. 2 WHERE和HAVING的对比</h3><p><strong>区别 1 ：</strong></p>
<ul>
<li><p>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；</p>
</li>
<li><p>HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</p>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p>
</li>
</ul>
<p><strong>区别 2 ：</strong></p>
<p>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p>
<p><strong>各自的优点与缺点：</strong></p>
<ul>
<li><p>WHERE 先筛选数据再关联，执行效率高，但不能使用分组中的计算函数进行筛选</p>
</li>
<li><p>HAVING 可以使用分组中的计算函数，在最后的结果集中进行筛选，但执行效率较低</p>
</li>
</ul>
<p><strong>开发中的参考选择：</strong></p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p>
<h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4. 1 查询的结构"></a>4. 1 查询的结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT .......</span><br><span class="line"></span><br><span class="line">#其中：</span><br><span class="line">#（ <span class="number">1</span> ）<span class="keyword">from</span>：从哪些表中筛选</span><br><span class="line">#（ <span class="number">2</span> ）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（ <span class="number">3</span> ）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（ <span class="number">4</span> ）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据</span><br><span class="line">#（ <span class="number">5</span> ）<span class="keyword">having</span>：在统计结果中再次筛选</span><br><span class="line">#（ <span class="number">6</span> ）<span class="keyword">order</span> <span class="keyword">by</span>：排序</span><br><span class="line">#（ <span class="number">7</span> ）limit：分页</span><br></pre></td></tr></table></figure>
<h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4. 2 SELECT执行顺序"></a>4. 2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p>
<ol>
<li><p>关键字的顺序是不能颠倒的，关键字顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT...</span><br></pre></td></tr></table></figure></li>
<li><p>SELECT 语句的执行顺序 （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
</li>
</ol>
<p>比如你写了一个 SQL 语句，那么它的执行顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> 的字段 <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num # 顺序 <span class="number">5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id # 顺序 <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> # 顺序 <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id # 顺序 <span class="number">3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> # 顺序 <span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> # 顺序 <span class="number">6</span></span><br><span class="line">LIMIT <span class="number">2</span> # 顺序 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h1 id="第-07-章-子查询"><a href="#第-07-章-子查询" class="headerlink" title="第 07 章 子查询"></a>第 07 章 子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询;</p>
<h2 id="1-子查询基本情况"><a href="#1-子查询基本情况" class="headerlink" title="1. 子查询基本情况"></a>1. 子查询基本情况</h2><h3 id="1-1-子查询的基本使用"><a href="#1-1-子查询的基本使用" class="headerlink" title="1. 1 子查询的基本使用"></a>1. 1 子查询的基本使用</h3><p><strong>子查询的基本语法结构例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>子查询（内查询）在主查询之前一次执行完成。子查询的结果被主查询（外查询）使用 。</p>
</li>
<li><p>子查询要包含在括号内将子查询放在比较条件的右侧，单行操作符对应单行子查询，多行操作符对应多行子查询。</p>
</li>
</ol>
<h3 id="1-2-子查询的分类"><a href="#1-2-子查询的分类" class="headerlink" title="1. 2 子查询的分类"></a>1. 2 子查询的分类</h3><p><strong>分类方式 1 ：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。</p>
<p><strong>分类方式 2 ：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为相关(或关联)子查询和不相关(或非关联)子查询。</p>
<ul>
<li>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</li>
</ul>
<ul>
<li>如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</li>
</ul>
<h2 id="2-多行子查询"><a href="#2-多行子查询" class="headerlink" title="2. 多行子查询"></a>2. 多行子查询</h2><p>多行子查询也称为集合比较子查询，内查询返回多行，使用多行比较操作符</p>
<h3 id="2-1-多行比较操作符"><a href="#2-1-多行比较操作符" class="headerlink" title="2. 1 多行比较操作符"></a>2. 1 多行比较操作符</h3><p>IN 等于列表中的 任意一个</p>
<p>ANY 需要和单行比较操作符一起使用，和子查询返回的 某一个 值比较</p>
<p>ALL 需要和单行比较操作符一起使用，和子查询返回的 所有 值比较</p>
<p>SOME 实际上是ANY的别名，作用相同，一般常使用ANY</p>
<h2 id="3-相关子查询"><a href="#3-相关子查询" class="headerlink" title="3. 相关子查询"></a>3. 相关子查询</h2><h3 id="3-1-相关子查询执行流程"><a href="#3-1-相关子查询执行流程" class="headerlink" title="3. 1 相关子查询执行流程"></a>3. 1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<ul>
<li><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p>
</li>
<li><p>在ORDER BY 中使用子查询：</p>
</li>
</ul>
<h3 id="3-2-EXISTS-与-NOT-EXISTS关键字"><a href="#3-2-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="3. 2 EXISTS 与 NOT EXISTS关键字"></a>3. 2 EXISTS 与 NOT EXISTS关键字</h3><p>关联子查询通常也会和 <strong>EXISTS</strong>操作符一起来使用，用来检查在子查询中是否存在满足条件的行。如果在子查询中不存在满足条件的行，条件返回 FALSE，继续在子查询中查找，如果在子查询中存在满足条件的行，不在子查询中继续查找，条件返回 TRUE；</p>
<p><strong>NOT EXISTS</strong>关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span></span><br><span class="line">e1.employee_id);</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是：</strong></p>
<p>当既可以使用子查询，也可以使用自连接时，一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<h1 id="第-8-章-创建和管理表"><a href="#第-8-章-创建和管理表" class="headerlink" title="第 8 章 创建和管理表"></a>第 8 章 创建和管理表</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-标识符命名规则"><a href="#1-1-标识符命名规则" class="headerlink" title="1. 1 标识符命名规则"></a>1. 1 标识符命名规则</h3><ul>
<li><p>数据库名、表名不得超过 30 个字符，变量名限制为 29 个，必须只能包含 A–Z, a–z, 0 – 9 , _共 63 个字符</p>
</li>
<li><p>数据库名、表名、字段名等对象名中间不要包含空格</p>
</li>
<li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名，必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</p>
</li>
<li><p>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</p>
</li>
</ul>
<h3 id="1-2-MySQL中的数据类型"><a href="#1-2-MySQL中的数据类型" class="headerlink" title="1. 2 MySQL中的数据类型"></a>1. 2 MySQL中的数据类型</h3><p><strong>类型举例：</strong></p>
<ul>
<li><p>整数类型 TINYINT、SMALLINT、MEDIUMINT、 INT(或INTEGER) 、BIGINT</p>
</li>
<li><p>浮点类型 FLOAT、DOUBLE</p>
</li>
<li><p>定点数类型 DECIMAL</p>
</li>
<li><p>位类型 BIT</p>
</li>
<li><p>日期时间类型 YEAR、TIME、 DATE 、DATETIME、TIMESTAMP</p>
</li>
<li><p>文本字符串类型 CHAR、 VARCHAR 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</p>
</li>
<li><p>枚举类型 ENUM</p>
</li>
<li><p>集合类型 SET</p>
</li>
<li><p>二进制字符串类型BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</p>
</li>
<li><p>JSON类型 JSON对象、JSON数组</p>
</li>
<li><p>空间数据类型</p>
</li>
</ul>
<p>单值：GEOMETRY、POINT、LINESTRING、POLYGON；</p>
<p>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</p>
<p><strong>数据类型描述：</strong></p>
<ul>
<li><p>INT 从-2^31到2^31-1的整型数据。存储大小为 4 个字节</p>
</li>
<li><p>CHAR(size) 定长字符数据。若未指定，默认为 1 个字符，最大长度 255</p>
</li>
<li><p>VARCHAR(size) 可变长字符数据，根据字符串实际长度保存， 必须指定长度</p>
</li>
<li><p>FLOAT(M,D)单精度，占用 4 个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</p>
</li>
<li><p>DOUBLE(M,D) 双精度，占用 8 个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</p>
</li>
<li><p>DECIMAL(M,D)高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</p>
</li>
</ul>
<ul>
<li><p>DATE 日期型数据，格式’YYYY-MM-DD’</p>
</li>
<li><p>BLOB 二进制形式的长文本数据，最大可达4G</p>
</li>
<li><p>TEXT 长文本数据，最大可达4G</p>
</li>
</ul>
<h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2. 1 创建数据库"></a>2. 1 创建数据库</h3><p>方式 1 ：创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：创建数据库并指定字符集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br></pre></td></tr></table></figure>

<p>方式 3 ：判断数据库是否已经存在，不存在则创建数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p>
<h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2. 2 使用数据库"></a>2. 2 使用数据库</h3><p>查看当前所有的数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure>

<p>查看当前正在使用的数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure>

<p>查看指定库下所有的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>查看数据库的创建信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名\G</span><br></pre></td></tr></table></figure>

<p>使用/切换数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名”。</p>
<h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2. 3 修改数据库"></a>2. 3 修改数据库</h3><p>更改数据库字符集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure>

<h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2. 4 删除数据库"></a>2. 4 删除数据库</h3><p>方式 1 ：删除指定的数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：判断数据库是否存在后再删除指定的数据库（推荐）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="3-1-创建方式"><a href="#3-1-创建方式" class="headerlink" title="3. 1 创建方式"></a>3. 1 创建方式</h3><p><strong>语法格式：</strong></p>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
<p><strong>必须指定：</strong>表名、列名(或字段名)，数据类型， 长度</p>
<p><strong>可选指定：</strong>表约束条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">字段<span class="number">1</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">2</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">3</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">......</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-查看数据表结构"><a href="#3-2-查看数据表结构" class="headerlink" title="3. 2 查看数据表结构"></a>3. 2 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>

<h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。使用 ALTER TABLE 语句可以实现：</p>
<p>向已有的表中添加列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 【<span class="keyword">COLUMN</span>】 字段名 字段类型 【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名】;</span><br></pre></td></tr></table></figure>

<p>修改现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 【<span class="keyword">COLUMN</span>】 字段名 <span class="number">1</span> 字段类型 【<span class="keyword">DEFAULT</span> 默认值】【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名</span><br><span class="line"><span class="number">2</span> 】;</span><br></pre></td></tr></table></figure>

<p>删除现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 【<span class="keyword">COLUMN</span>】字段名</span><br></pre></td></tr></table></figure>

<p>重命名现有表中的列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 【<span class="keyword">column</span>】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>

<h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><p>方式一：使用RENAME</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> emp</span><br><span class="line"><span class="keyword">TO</span> myemp;</span><br></pre></td></tr></table></figure>

<p>方式二：必须是对象的拥有者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> dept</span><br><span class="line">RENAME [<span class="keyword">TO</span>] detail_dept;  <span class="comment">-- [TO]可以省略</span></span><br></pre></td></tr></table></figure>

<h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><p>在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, ..., 数据表n];</span><br></pre></td></tr></table></figure>

<p>IF EXISTS的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<p><strong>注意：</strong>DROP TABLE 语句不能回滚</p>
<h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><p>TRUNCATE TABLE语句：删除表中所有的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 数据表;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚；</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h1 id="第-9-章-增删改语句"><a href="#第-9-章-增删改语句" class="headerlink" title="第 9 章 增删改语句"></a>第 9 章 增删改语句</h1><h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-将数据插入表中"><a href="#1-1-将数据插入表中" class="headerlink" title="1. 1 将数据插入表中"></a>1. 1 将数据插入表中</h3><p>使用<strong>INSERT 语句</strong>向表中插入数据。</p>
<p><strong>方式 1 ：</strong>VALUES的方式添加，使用这种语法一次只能向表中插入一条数据。</p>
<p>情况 1 ：为表的所有字段按默认顺序插入数据，</p>
<ul>
<li>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,....);</span><br></pre></td></tr></table></figure>
<p>情况 2 ：为表的指定字段插入数据</p>
<ul>
<li><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
</li>
<li><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span> (value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>情况 3 ：同时插入多条记录</p>
<ul>
<li><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开</p>
<p>基本语法格式如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1 [, column2, ..., columnn])</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">(value1 [,value2, ..., valuen]),</span><br><span class="line">......</span><br><span class="line">(value1 [,value2, ..., valuen]);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><p>VALUES也可以写成VALUE，但是VALUES是标准写法。</p>
</li>
<li><p>字符和日期型数据应包含在单引号中。</p>
</li>
</ul>
<h3 id="1-2-将查询结果插入到表中"><a href="#1-2-将查询结果插入到表中" class="headerlink" title="1. 2 将查询结果插入到表中"></a>1. 2 将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, ..., tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, ..., src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<p>在 INSERT 语句中加入子查询不必书写 VALUES 子句,子查询中的值列表应与 INSERT 子句中的列名对应。</p>
<h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p>使用 <strong>UPDATE 语句</strong>更新数据。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> 更新字段<span class="operator">=</span>更新值</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以一次更新多条数据。</p>
</li>
<li><p>如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;</p>
</li>
<li><p>使用 WHERE 子句指定需要更新的数据，如果省略 WHERE 子句，则表中的所有数据都将被更新。</p>
</li>
</ul>
<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><p>使用 <strong>DELETE 语句</strong>从表中删除数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p>
<p><strong>truncate table与delete table对比：</strong></p>
<p>相同点：都可以删除表中所有数据，同时保留表结构<br>不同点：truncate table清除全部表数据后不可回滚；delete table不带where时也清除全部表数据，同时数据可以回滚；</p>
<h1 id="第-10-章-约束"><a href="#第-10-章-约束" class="headerlink" title="第 10 章 约束"></a>第 10 章 约束</h1><h2 id="1-约束概述"><a href="#1-约束概述" class="headerlink" title="1. 约束概述"></a>1. 约束概述</h2><h3 id="1-1-什么是约束"><a href="#1-1-什么是约束" class="headerlink" title="1. 1 什么是约束"></a>1. 1 什么是约束</h3><p>约束是表级的强制规定。可以在 创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建后通过 ALTER TABLE 语句规定约束 。</p>
<h3 id="1-2-约束的分类"><a href="#1-2-约束的分类" class="headerlink" title="1. 2 约束的分类"></a>1. 2 约束的分类</h3><p>根据约束数据列的限制， 约束可分为：</p>
<ul>
<li><p>单列约束 ：每个约束只约束一列</p>
</li>
<li><p>多列约束 ：每个约束可约束多列数据</p>
</li>
</ul>
<p>根据约束的作用范围 ，约束可分为：</p>
<ul>
<li><p>列级约束 ：只能作用在一个列上，跟在列的定义后面</p>
</li>
<li><p>表级约束 ：可以作用在多个列上，不与列一起，而是单独定义</p>
</li>
</ul>
<p>根据约束起的作用 ，约束可分为：</p>
<ul>
<li><p>NOT NULL 非空约束，规定某个字段不能为空</p>
</li>
<li><p>UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的</p>
</li>
<li><p>PRIMARY KEY 主键(非空且唯一)约束</p>
</li>
<li><p>FOREIGN KEY 外键约束</p>
</li>
<li><p>CHECK 检查约束</p>
</li>
<li><p>DEFAULT 默认值约束</p>
</li>
</ul>
<p>**注意： **MySQL不支持check约束，但可以使用check约束，不过没有任何效果</p>
<h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2. 1 作用"></a>2. 1 作用</h3><p>限定某个字段/某列的值不允许为空</p>
<h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2. 2 关键字"></a>2. 2 关键字</h3><p>NOT NULL</p>
<h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2. 3 特点"></a>2. 3 特点</h3><ul>
<li><p>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</p>
</li>
<li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空，一个表可以有很多列都分别限定了非空</p>
</li>
<li><p>空字符串’不等于NULL， 0 也不等于NULL</p>
</li>
</ul>
<h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2. 4 添加非空约束"></a>2. 4 添加非空约束</h3><p>（1）建表时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2. 5 删除非空约束"></a>2. 5 删除非空约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">NULL</span>;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型;#去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br></pre></td></tr></table></figure>
<h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3. 1 作用"></a>3. 1 作用</h3><p>用来限制某个字段/某列的值不能重复。</p>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3. 2 关键字"></a>3. 2 关键字</h3><p>UNIQUE</p>
<h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3. 3 特点"></a>3. 3 特点</h3><ul>
<li><p>同一个表可以有多个唯一约束。</p>
</li>
<li><p>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</p>
</li>
<li><p>唯一性约束允许列值为空。</p>
</li>
<li><p>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</p>
</li>
<li><p>MySQL会给唯一约束的列上默认创建一个唯一索引。</p>
</li>
</ul>
<h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3. 4 添加唯一约束"></a>3. 4 添加唯一约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后指定唯一键约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> key(字段列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 字段类型 <span class="keyword">unique</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3. 5 关于复合唯一约束"></a>3. 5 关于复合唯一约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">unique</span> key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-删除唯一约束"><a href="#3-6-删除唯一约束" class="headerlink" title="3. 6 删除唯一约束"></a>3. 6 删除唯一约束</h3><ul>
<li><p>添加唯一性约束的列上也会自动创建唯一索引，删除唯一约束只能通过删除唯一索引的方式删除。</p>
</li>
<li><p>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</p>
</li>
</ul>
<p><strong>注意：</strong>可以通过 show index from 表名称;查看表的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>; #查看都有哪些约束</span><br></pre></td></tr></table></figure>
<h2 id="4-PRIMARY-KEY-主键约束"><a href="#4-PRIMARY-KEY-主键约束" class="headerlink" title="4. PRIMARY KEY 主键约束"></a>4. PRIMARY KEY 主键约束</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4. 1 作用"></a>4. 1 作用</h3><p>用来唯一标识表中的一行记录。</p>
<h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4. 2 关键字"></a>4. 2 关键字</h3><p>primary key</p>
<h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4. 3 特点"></a>4. 3 特点</h3><ul>
<li><p>主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。</p>
</li>
<li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
</li>
<li><p>主键约束对应着表中的一列或者多列（复合主键），如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p>
</li>
<li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
</li>
</ul>
<p><strong>值得注意的是：</strong>不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
<h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4. 4 添加主键约束"></a>4. 4 添加主键约束</h3><p>（ 1 ）建表时指定主键约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key, #列级模式</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型</span><br><span class="line">);</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">primary</span> key(字段名) #表级模式</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后增加主键约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure>

<h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4. 5 关于复合主键"></a>4. 5 关于复合主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">primary</span> key(字段名<span class="number">1</span>,字段名<span class="number">2</span>)  #表示字段 <span class="number">1</span> 和字段 <span class="number">2</span> 的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4. 6 删除主键约束"></a>4. 6 删除主键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
<h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5. 1 作用"></a>5. 1 作用</h3><p>某个字段的值自增</p>
<h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5. 2 关键字"></a>5. 2 关键字</h3><p>auto_increment</p>
<h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5. 3 特点和要求"></a>5. 3 特点和要求</h3><ul>
<li><p>一个表最多只能有一个自增长列</p>
</li>
<li><p>当需要产生唯一标识符或顺序值时，可设置自增长</p>
</li>
<li><p>自增长列约束的列必须是键列（主键列，唯一键列）</p>
</li>
<li><p>自增约束的列的数据类型必须是整数类型</p>
</li>
<li><p>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
</li>
</ul>
<h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5. 4 如何指定自增约束"></a>5. 4 如何指定自增约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key auto_increment,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,,</span><br><span class="line"><span class="keyword">primary</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br></pre></td></tr></table></figure>

<h3 id="5-5-删除自增约束"><a href="#5-5-删除自增约束" class="headerlink" title="5. 5 删除自增约束"></a>5. 5 删除自增约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure>

<h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6. 1 作用"></a>6. 1 作用</h3><p>限定某个表的某个字段的引用完整性。</p>
<h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6. 2 关键字"></a>6. 2 关键字</h3><p>FOREIGN KEY</p>
<h3 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6. 3 主表和从表/父表和子表"></a>6. 3 主表和从表/父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<p><strong>例子1：</strong>员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p>
<p><strong>例如2：</strong>学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p>
<h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6. 4 特点"></a>6. 4 特点</h3><p>（ 1 ）从表的外键列，必须引用/参考主表的主键或唯一约束的列，因为被依赖/被参考的值必须是唯一的</p>
<p>（ 2 ）在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名，也可以指定外键约束名。</p>
<p>（ 3 ）创建(CREATE)表时就指定外键约束的话，必须先创建主表，再创建从表</p>
<p>（ 4 ）删表时，先删从表（或先删除外键约束），再删除主表</p>
<p>（ 5 ）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p>
<p>（ 6 ）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p>
<p>（ 7 ）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。</p>
<p>（ 8 ） 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）</p>
<p>（ 9 ）删除外键约束后，必须手动删除对应的索引</p>
<h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6. 5 添加外键约束"></a>6. 5 添加外键约束</h3><p>（ 1 ）建表时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表名称(</span><br><span class="line">字段 <span class="number">1</span> 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段 <span class="number">2</span> 数据类型,</span><br><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键约束名称<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY（从表的某个字段) <span class="keyword">references</span> 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line"><span class="comment">-- FOREIGN KEY: 在表级指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES: 标示在父表中的列</span></span><br></pre></td></tr></table></figure>

<p>（ 2 ）建表后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段);</span><br></pre></td></tr></table></figure>

<h3 id="6-6-删除外键约束"><a href="#6-6-删除外键约束" class="headerlink" title="6. 6 删除外键约束"></a>6. 6 删除外键约束</h3><p>流程如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">1</span> )第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">（ <span class="number">2</span> ）第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称; #查看某个表的索引名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>
<h2 id="7-DEFAULT约束"><a href="#7-DEFAULT约束" class="headerlink" title="7. DEFAULT约束"></a>7. DEFAULT约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7. 1 作用"></a>7. 1 作用</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h3 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7. 2 关键字"></a>7. 2 关键字</h3><p>DEFAULT</p>
<h3 id="7-3-如何给字段加默认值"><a href="#7-3-如何给字段加默认值" class="headerlink" title="7. 3 如何给字段加默认值"></a>7. 3 如何给字段加默认值</h3><h5 id="（-1-）建表时"><a href="#（-1-）建表时" class="headerlink" title="（ 1 ）建表时"></a>（ 1 ）建表时</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line"><span class="keyword">primary</span> key(字段名),</span><br><span class="line"><span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure>

<h5 id="（-2-）建表后"><a href="#（-2-）建表后" class="headerlink" title="（ 2 ）建表后"></a>（ 2 ）建表后</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值</span><br></pre></td></tr></table></figure>
<h3 id="7-4-删除默认值约束"><a href="#7-4-删除默认值约束" class="headerlink" title="7. 4 删除默认值约束"></a>7. 4 删除默认值约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br></pre></td></tr></table></figure>

<h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h1 id="第-11-章-视图"><a href="#第-11-章-视图" class="headerlink" title="第 11 章 视图"></a>第 11 章 视图</h1><h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><ul>
<li><p>表(TABLE)</p>
<p> 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</p>
</li>
<li><p>数据字典</p>
<p>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</p>
</li>
<li><p>约束(CONSTRAINT)</p>
<p>执行数据校验的规则，用于保证数据完整性的规则</p>
</li>
<li><p>视图(VIEW)</p>
<p> 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</p>
</li>
<li><p>索引(INDEX) </p>
<p>用于提高查询性能，相当于书的目录</p>
</li>
<li><p>存储过程(PROCEDURE)</p>
<p>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</p>
</li>
<li><p>存储函数(FUNCTION)</p>
<p>用于完成一次特定的计算，具有一个返回值</p>
</li>
<li><p>触发器(TRIGGER)</p>
<p>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</p>
</li>
</ul>
<h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2. 1 为什么使用视图？"></a>2. 1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p>
<h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2. 2 视图的理解"></a>2. 2 视图的理解</h3><ul>
<li><p>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p>
</li>
<li><p>视图建立在已有表的基础上 , 视图赖以建立的这些表称为基表 。</p>
</li>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
</li>
<li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句</p>
</li>
<li><p>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</p>
</li>
<li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
</li>
</ul>
<h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><p>在 CREATE VIEW 语句中嵌入子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br></pre></td></tr></table></figure>
<p><strong>说明 1 ：</strong>实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形</p>
<p>成一张虚拟表。</p>
<p><strong>说明 2 ：</strong>在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字</p>
<p>段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法 1 ：查看数据库的表对象、视图对象</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>

<p>语法 2 ：查看视图的结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 视图名称;</span><br></pre></td></tr></table></figure>

<p>语法 3 ：查看视图的属性信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>语法 4 ：查看视图的详细定义信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>

<h2 id="5-不可更新的视图"><a href="#5-不可更新的视图" class="headerlink" title="5. 不可更新的视图"></a>5. 不可更新的视图</h2><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li><p>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</p>
</li>
<li><p>在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</p>
</li>
<li><p>视图定义基于一个不可更新视图；</p>
</li>
<li><p>常量视图。</p>
</li>
<li><p>在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p>
</li>
</ul>
<p><strong>总结：</strong>虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图的数据。 对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p>
<h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6. 1 修改视图"></a>6. 1 修改视图</h3><p>方式 1 ：使用CREATE OR REPLACE VIEW 子句 修改视图</p>
<p><strong>注意：</strong>CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
<p>方式 2 ：ALTER VIEW</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6. 2 删除视图"></a>6. 2 删除视图</h3><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7. 1 视图优点"></a>7. 1 视图优点</h3><ol>
<li><p>操作简单</p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
</li>
<li><p>减少数据冗余</p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
</li>
<li><p>数据安全</p>
<p>MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， 用户不需要查询数据表，可以直接通过视图获取数据表中的信息 。这在一定程度上保障了数据表中数据的安全性。</p>
</li>
<li><p>适应灵活多变的需求</p>
<p>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
</li>
<li><p>能够分解复杂的查询逻辑 </p>
<p>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
</li>
</ol>
<h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7. 2 视图不足"></a>7. 2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么， 如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<h1 id="第-12-章-存储过程与函数"><a href="#第-12-章-存储过程与函数" class="headerlink" title="第 12 章 存储过程与函数"></a>第 12 章 存储过程与函数</h1><h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1. 1 理解"></a>1. 1 理解</h3><p><strong>含义 ：</strong>存储过程的英文是 Stored Procedure。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。</p>
<p><strong>执行过程：</strong>存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处 ：</strong></p>
<ol>
<li><p>简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </p>
</li>
<li><p>减少操作过程中的失误，提高效率</p>
</li>
<li><p>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </p>
</li>
<li><p>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p>
</li>
</ol>
<p><strong>和视图、函数的对比 ：</strong></p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1. 2 分类"></a>1. 2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<ol>
<li>没有参数（无参数无返回） </li>
<li>仅仅带 IN 类型（有参数无返回）</li>
<li>仅仅带 OUT 类型（无参数有返回） </li>
<li>既带 IN 又带 OUT（有参数有返回） </li>
<li>带 INOUT（有参数有返回）</li>
</ol>
<p><strong>注意：</strong>IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2. 1 语法分析"></a>2. 1 语法分析</h3><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span> 新的结束标记</span><br><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>参数前面的符号的意思</li>
</ol>
<ul>
<li><p>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认是 IN，表示输入参数。</p>
</li>
<li><p>OUT：当前参数为输出参数，也就是表示出参；执行完成后，调用这个存储过程客户端或者应用程序就可以读取这个参数返回值了。</p>
</li>
<li><p>INOUT：当前参数既可以为输入参数，也可以为输出参数。</p>
</li>
</ul>
<ol start="2">
<li><p>形参类型可以是 MySQL数据库中的任意类型。</p>
</li>
<li><p>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
</li>
</ol>
<ul>
<li><p>LANGUAGE SQL：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p>
</li>
<li><p>[NOT] DETERMINISTIC：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p>
</li>
<li><p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。</p>
</li>
<li><p>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</p>
</li>
<li><p>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</p>
</li>
<li><p>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</p>
</li>
<li><p>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。默认情况下，系统会指定为CONTAINS SQL。</p>
</li>
<li><p>SQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。</p>
</li>
<li><p>DEFINER表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</p>
</li>
<li><p>INVOKER表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。如果没有设置相关的值，则MySQL默认指定值为DEFINER。</p>
</li>
<li><p>COMMENT ‘string’：注释信息，可以用来描述存储过程。</p>
</li>
</ul>
<ol start="4">
<li><p>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
</li>
<li><p>需要设置新的结束标记</p>
</li>
</ol>
<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p>
<p><strong>比如：</strong>“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p>
<h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><p>调用格式如下：</p>
<p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4. 1 语法分析"></a>4. 1 语法分析</h3><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><p>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p>
</li>
<li><p>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。</p>
</li>
<li><p>characteristic 创建函数时指定的对函数的约束。</p>
</li>
<li><p>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
</li>
</ol>
<h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4. 2 调用存储函数"></a>4. 2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。</p>
<h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5. 1 查看"></a>5. 1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍 3 种方法。</p>
<ol>
<li><p>使用SHOW CREATE语句查看存储过程和函数的创建信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure></li>
<li><p>使用SHOW STATUS语句查看存储过程和函数的状态信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">#[<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。 </span><br></pre></td></tr></table></figure></li>
<li><p>从information_schema.Routines表中查看存储过程和函数的信息</p>
</li>
</ol>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;];</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>如果在MySQL数据库中存在存储过程和函数名称相同情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
<h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5. 2 修改"></a>5. 2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<p><strong>注意：</strong>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
<h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5. 3 删除"></a>5. 3 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br><span class="line"># IF <span class="keyword">EXISTS</span>：如果程序或函数不存储，它可以防止发生错误，产生一个用<span class="keyword">SHOW</span> WARNINGS查看的警告。</span><br></pre></td></tr></table></figure>

<h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6. 1 优点"></a>6. 1 优点</h3><ol>
<li><p>存储过程可以一次编译多次使用。 存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
</li>
<li><p>可以减少开发工作量。 将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
</li>
<li><p>存储过程的安全性强。 我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</p>
</li>
<li><p>可以减少网络传输量。 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
</li>
<li><p>良好的封装性。 在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
</li>
</ol>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6. 2 缺点"></a>6. 2 缺点</h3><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<ol>
<li><p>可移植性差。 存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
</li>
<li><p>调试困难。 只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
</li>
<li><p>存储过程的版本管理很困难。 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
</li>
<li><p>它不适合高并发的场景。 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
</li>
</ol>
<h1 id="第-13-章-变量、流程控制与游标"><a href="#第-13-章-变量、流程控制与游标" class="headerlink" title="第 13 章 变量、流程控制与游标"></a>第 13 章 变量、流程控制与游标</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ul>
<li><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
</li>
<li><p>在 MySQL 数据库中，变量分为系统变量以及用户自定义变量。</p>
</li>
</ul>
<h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1. 1 系统变量"></a>1. 1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1. 1. 1 系统变量分类"></a>1. 1. 1 系统变量分类</h4><ul>
<li><p>变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数；</p>
</li>
<li><p>系统变量分为全局系统变量（需要添加global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 如果不写，默认为会话级别。 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
</li>
<li><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p>
</li>
<li><p>全局系统变量针对于所有会话（连接）有效，但不能跨重启，而会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值，但是会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</p>
</li>
</ul>
<h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1. 1. 2 查看系统变量"></a>1. 1. 2 查看系统变量</h4><p>查看所有或部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看指定系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure>

<p>作为 MySQL 编码规范，MySQL 中的系统变量以“**@@**”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
<h4 id="1-1-3修改系统变量"><a href="#1-1-3修改系统变量" class="headerlink" title="1.1.3修改系统变量"></a>1.1.3修改系统变量</h4><p>方式 1 ：修改MySQL配置文件，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式 2 ：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式 <span class="number">1</span> ：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1. 2 用户变量"></a>1. 2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1. 2. 1 用户变量分类"></a>1. 2. 1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个“**@**”开头。根据作用范围不同，又分为会话用户变量和局部变量。</p>
<ul>
<li><p>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</p>
</li>
<li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</p>
</li>
</ul>
<h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1. 2. 2 会话用户变量"></a>1. 2. 2 会话用户变量</h4><p>作用域：<strong>针对于当前会话有效</strong>，可定义在会话的任何位置，等同于会话变量的作用域</p>
<ol>
<li>查看用户变量的值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>声明变量并初始化</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">1</span> ：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>赋值（更新用户变量的值）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1. 2. 3 局部变量"></a>1. 2. 3 局部变量</h4><p>定义：可以使用DECLARE语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的<strong>BEGIN … END 中</strong>有效，只能放在 BEGIN … END 中，而且只能放在第一句</p>
<ol>
<li>定义变量</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 [<span class="keyword">default</span> 值];  # 如果没有<span class="keyword">DEFAULT</span>子句，初始值为NULLBEGIN</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量赋值</li>
</ol>
<p>方式 1 ：一般用于赋简单的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：一般用于赋表中的字段值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure>

<p>3 .使用变量 （查看、比较、运算等)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>

<h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><p>只要是执行的程序，流程就分为三大类：</p>
<ul>
<li><p>顺序结构：程序从上往下依次执行</p>
</li>
<li><p>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</p>
</li>
<li><p>循环结构：程序满足一定条件下，重复执行一组语句</p>
</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li><p>条件判断语句：IF 语句和 CASE 语句</p>
</li>
<li><p>循环语句：LOOP、WHILE 和 REPEAT 语句</p>
</li>
<li><p>跳转语句：ITERATE 和 LEAVE 语句</p>
</li>
</ul>
<h3 id="2-1-分支结构之-IF"><a href="#2-1-分支结构之-IF" class="headerlink" title="2. 1 分支结构之 IF"></a>2. 1 分支结构之 IF</h3><p>IF 语句的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF 表达式 <span class="number">1</span> <span class="keyword">THEN</span> 操作 <span class="number">1</span></span><br><span class="line">[ELSEIF 表达式 <span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]......</span><br><span class="line">[<span class="keyword">ELSE</span> 操作N]</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br><span class="line">#根据表达式的结果为<span class="literal">TRUE</span>或<span class="literal">FALSE</span>执行相应的语句。这里“[]”中的内容是可选的。</span><br></pre></td></tr></table></figure>

<p>特点：① 不同的表达式对应不同的操作  ② 使用在begin end中</p>
<h3 id="2-2-分支结构之-CASE"><a href="#2-2-分支结构之-CASE" class="headerlink" title="2. 2 分支结构之 CASE"></a>2. 2 分支结构之 CASE</h3><p>CASE 语句的语法结构 1 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构 2 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">1</span> <span class="keyword">THEN</span> 结果 <span class="number">1</span> 或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件 <span class="number">2</span> <span class="keyword">THEN</span> 结果 <span class="number">2</span> 或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>

<h3 id="2-3-循环结构之LOOP"><a href="#2-3-循环结构之LOOP" class="headerlink" title="2. 3 循环结构之LOOP"></a>2. 3 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br><span class="line"></span><br><span class="line">#其中，loop_label表示LOOP语句的标注名称，该参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="2-4-循环结构之WHILE"><a href="#2-4-循环结构之WHILE" class="headerlink" title="2. 4 循环结构之WHILE"></a>2. 4 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br><span class="line"></span><br><span class="line"># while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环</span><br></pre></td></tr></table></figure>

<h3 id="2-5-循环结构之REPEAT"><a href="#2-5-循环结构之REPEAT" class="headerlink" title="2. 5 循环结构之REPEAT"></a>2. 5 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br><span class="line"></span><br><span class="line"># repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<ul>
<li>loop：一般用于实现简单的死循环</li>
<li>while：先判断后执行</li>
<li>repeat：先执行后判断，无条件至少执行一次</li>
</ul>
<h3 id="2-6-跳转语句之LEAVE语句"><a href="#2-6-跳转语句之LEAVE语句" class="headerlink" title="2. 6 跳转语句之LEAVE语句"></a>2. 6 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。可以把 LEAVE 理解为编程语句中的 break。</p>
<p>基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label</span><br><span class="line"># 其中，label参数表示循环的标志。LEAVE和<span class="keyword">BEGIN</span> ... <span class="keyword">END</span>或循环一起被使用。</span><br></pre></td></tr></table></figure>

<h3 id="2-7-跳转语句之ITERATE语句"><a href="#2-7-跳转语句之ITERATE语句" class="headerlink" title="2. 7 跳转语句之ITERATE语句"></a>2. 7 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。可以把 ITERATE 理解为编程语句中的 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br><span class="line"># label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</span><br></pre></td></tr></table></figure>

<h2 id="3-游标"><a href="#3-游标" class="headerlink" title="3. 游标"></a>3. 游标</h2><h3 id="3-1-什么是游标"><a href="#3-1-什么是游标" class="headerlink" title="3. 1 什么是游标"></a>3. 1 什么是游标</h3><ul>
<li><p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。 游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</p>
</li>
<li><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。MySQL中游标可以在存储过程和函数中使用。</p>
</li>
</ul>
<h3 id="3-2-使用游标步骤"><a href="#3-2-使用游标步骤" class="headerlink" title="3. 2 使用游标步骤"></a>3. 2 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><em><strong>第一步，声明游标</strong></em></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。</p>
<p>如果是用 Oracle 或者 PostgreSQL，则需要写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br></pre></td></tr></table></figure>

<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。</p>
<p><strong>第二步，打开游标</strong></p>
<p>打开游标的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。</p>
<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>var_name必须在声明游标之前就定义好。</p>
</li>
<li><p>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致 ，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
</li>
</ol>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源，如果不及时关闭， 游标会一直保持到存储过程结束 ，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<h1 id="第-14-章-触发器"><a href="#第-14-章-触发器" class="headerlink" title="第 14 章_触发器"></a>第 14 章_触发器</h1><h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><p>创建触发器的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br><span class="line"></span><br><span class="line"># 表名：表示触发器监控的对象。</span><br><span class="line"># BEFORE<span class="operator">|</span>AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</span><br><span class="line"># <span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>：表示触发的事件。</span><br><span class="line"># <span class="keyword">INSERT</span> 表示插入记录时触发；</span><br><span class="line"># <span class="keyword">UPDATE</span> 表示更新记录时触发；</span><br><span class="line"># <span class="keyword">DELETE</span> 表示删除记录时触发。</span><br></pre></td></tr></table></figure>

<p>触发器执行的语句块可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p>
<h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3. 1 查看触发器"></a>3. 1 查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式 1 ：查看当前数据库的所有触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>方式 2 ：查看当前数据库中某个触发器的定义</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure>

<p>方式 3 ：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3. 2 删除触发器"></a>3. 2 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4. 1 优点"></a>4. 1 优点</h3><ol>
<li><p>触发器可以确保数据的完整性 。</p>
</li>
<li><p>触发器可以帮助我们记录操作日志。</p>
</li>
<li><p>触发器还可以用在操作数据前，对数据进行合法性检查。</p>
</li>
</ol>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4. 2 缺点"></a>4. 2 缺点</h3><ol>
<li>触发器最大的一个问题就是可读性差。</li>
</ol>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制。这对系统维护是非常有挑战的。</p>
<ol start="2">
<li>相关数据的变更，可能会导致触发器出错。</li>
</ol>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/02/12/Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93/" rel="next" title="Java中的对象术语(PO/POJO/VO/BO/DAO/DTO)总结">
      Java中的对象术语(PO/POJO/VO/BO/DAO/DTO)总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-01-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">第 01 章 数据库概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">1. 为什么要使用数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2. 数据库与数据库管理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">2. 1 数据库的相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 2 数据库与数据库管理系统的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-RDBMS-%E4%B8%8E-%E9%9D%9ERDBMS"><span class="nav-number">2.3.</span> <span class="nav-text">3. RDBMS 与 非RDBMS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-RDBMS"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 关系型数据库(RDBMS)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%AE%9E%E8%B4%A8"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">3. 1. 1 实质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E4%BC%98%E5%8A%BF"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">3. 1. 2 优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%9ERDBMS"><span class="nav-number">2.3.2.</span> <span class="nav-text">3. 2 非关系型数据库(非RDBMS)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">非关系型数据库种类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-02-%E7%AB%A0-SELECT%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.</span> <span class="nav-text">第 02 章 SELECT语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%ACSELECT%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.</span> <span class="nav-text">1. 基本SELECT语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-SELECT-%E2%80%A6-FROM-%E2%80%A6"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. 1 SELECT … FROM …</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%88%97%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">3.1.2.</span> <span class="nav-text">1. 2 列的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="nav-number">3.1.3.</span> <span class="nav-text">1. 3 去除重复行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%A9%BA%E5%80%BC%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.4.</span> <span class="nav-text">1. 4 空值参与运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E6%9F%A5%E8%AF%A2%E5%B8%B8%E6%95%B0"><span class="nav-number">3.1.5.</span> <span class="nav-text">1. 5 查询常数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text">2. 过滤数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-03-%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.</span> <span class="nav-text">第 03 章 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.1.</span> <span class="nav-text">1. 算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">2. 比较运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.3.</span> <span class="nav-text">3. 逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.4.</span> <span class="nav-text">4. 位运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">4.5.</span> <span class="nav-text">5. 运算符的优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-04-%E7%AB%A0-%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5"><span class="nav-number">5.</span> <span class="nav-text">第 04 章 排序与分页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">1. 排序数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">5.1.1.</span> <span class="nav-text">1. 1 排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%8D%95%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">1. 2 单列排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%A4%9A%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.3.</span> <span class="nav-text">1. 3 多列排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E9%A1%B5"><span class="nav-number">5.2.</span> <span class="nav-text">2. 分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%86%E9%A1%B5%E8%A7%84%E5%88%99"><span class="nav-number">5.2.1.</span> <span class="nav-text">2. 1 分页规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-05-%E7%AB%A0-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.</span> <span class="nav-text">第 05 章 多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">1. 笛卡尔积产生的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%EF%BC%88%E6%88%96%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">6.1.1.</span> <span class="nav-text">1. 1 笛卡尔积（或交叉连接）的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-number">6.1.2.</span> <span class="nav-text">1. 2 分析与问题解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%88%86%E7%B1%BB%E8%AE%B2%E8%A7%A3"><span class="nav-number">6.2.</span> <span class="nav-text">2. 多表查询分类讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-1-%EF%BC%9A%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5-vs-%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.1.</span> <span class="nav-text">分类 1 ：等值连接 vs 非等值连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">等值连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">非等值连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-2-%EF%BC%9A%E8%87%AA%E8%BF%9E%E6%8E%A5-vs-%E9%9D%9E%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.2.</span> <span class="nav-text">分类 2 ：自连接 vs 非自连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB-3-%EF%BC%9A%E5%86%85%E8%BF%9E%E6%8E%A5-vs-%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.3.</span> <span class="nav-text">分类 3 ：内连接 vs 外连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">内连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.3.2.</span> <span class="nav-text">外连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-92-%E8%AF%AD%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8-%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.3.3.</span> <span class="nav-text">SQL 92 语法：使用(+)创建连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SQL-99-%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.3.</span> <span class="nav-text">3. SQL 99 语法实现多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">6.3.1.</span> <span class="nav-text">3. 1 基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%85%E8%BF%9E%E6%8E%A5-INNER-JOIN-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">3. 2 内连接(INNER JOIN)的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%A4%96%E8%BF%9E%E6%8E%A5-OUTER-JOIN-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.3.</span> <span class="nav-text">3. 3 外连接(OUTER JOIN)的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5-LEFT-OUTER-JOIN"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">3. 3. 1 左外连接(LEFT OUTER JOIN)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5-RIGHT-OUTER-JOIN"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">3. 3. 2 右外连接(RIGHT OUTER JOIN)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E6%BB%A1%E5%A4%96%E8%BF%9E%E6%8E%A5-FULL-OUTER-JOIN"><span class="nav-number">6.3.3.3.</span> <span class="nav-text">3. 3. 3 满外连接(FULL OUTER JOIN)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-UNION%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">4. UNION的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="nav-number">6.4.0.0.1.</span> <span class="nav-text">语法格式：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-SQL-99-%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">6.5.</span> <span class="nav-text">5. SQL 99 语法新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.5.1.</span> <span class="nav-text">5. 1 自然连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-USING%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.5.2.</span> <span class="nav-text">5. 2 USING连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%AB%A0%E8%8A%82%E5%B0%8F%E7%BB%93"><span class="nav-number">6.6.</span> <span class="nav-text">6. 章节小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-06-%E7%AB%A0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">第 06 章 聚合函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.1.</span> <span class="nav-text">1. 聚合函数介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-AVG%E5%92%8CSUM%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.1.</span> <span class="nav-text">1. 1 AVG和SUM函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-MIN%E5%92%8CMAX%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.2.</span> <span class="nav-text">1. 2 MIN和MAX函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-COUNT%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.3.</span> <span class="nav-text">1. 3 COUNT函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GROUP-BY"><span class="nav-number">7.2.</span> <span class="nav-text">2. GROUP BY</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">2. 1 基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-GROUP-BY%E4%B8%AD%E4%BD%BF%E7%94%A8WITH-ROLLUP"><span class="nav-number">7.2.2.</span> <span class="nav-text">2. 2 GROUP BY中使用WITH ROLLUP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HAVING"><span class="nav-number">7.3.</span> <span class="nav-text">3. HAVING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.1.</span> <span class="nav-text">3. 1 基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-WHERE%E5%92%8CHAVING%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">7.3.2.</span> <span class="nav-text">3. 2 WHERE和HAVING的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-SELECT%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">7.4.</span> <span class="nav-text">4. SELECT的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.1.</span> <span class="nav-text">4. 1 查询的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-SELECT%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">7.4.2.</span> <span class="nav-text">4. 2 SELECT执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">7.4.2.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-07-%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.</span> <span class="nav-text">第 07 章 子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="nav-number">8.1.</span> <span class="nav-text">1. 子查询基本情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">8.1.1.</span> <span class="nav-text">1. 1 子查询的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.2.</span> <span class="nav-text">1. 2 子查询的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.2.</span> <span class="nav-text">2. 多行子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%A4%9A%E8%A1%8C%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">8.2.1.</span> <span class="nav-text">2. 1 多行比较操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.3.</span> <span class="nav-text">3. 相关子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">8.3.1.</span> <span class="nav-text">3. 1 相关子查询执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-EXISTS-%E4%B8%8E-NOT-EXISTS%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">8.3.2.</span> <span class="nav-text">3. 2 EXISTS 与 NOT EXISTS关键字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">第 8 章 创建和管理表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">9.1.</span> <span class="nav-text">1. 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">9.1.1.</span> <span class="nav-text">1. 1 标识符命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-MySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">1. 2 MySQL中的数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.2.</span> <span class="nav-text">2. 创建和管理数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.2.1.</span> <span class="nav-text">2. 1 创建数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.2.2.</span> <span class="nav-text">2. 2 使用数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.2.3.</span> <span class="nav-text">2. 3 修改数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">9.2.4.</span> <span class="nav-text">2. 4 删除数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">9.3.</span> <span class="nav-text">3. 创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">9.3.1.</span> <span class="nav-text">3. 1 创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">9.3.2.</span> <span class="nav-text">3. 2 查看数据表结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="nav-number">9.4.</span> <span class="nav-text">4. 修改表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="nav-number">9.5.</span> <span class="nav-text">5. 重命名表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">9.6.</span> <span class="nav-text">6. 删除表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%B8%85%E7%A9%BA%E8%A1%A8"><span class="nav-number">9.7.</span> <span class="nav-text">7. 清空表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#-1"><span class="nav-number">9.7.0.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E5%A2%9E%E5%88%A0%E6%94%B9%E8%AF%AD%E5%8F%A5"><span class="nav-number">10.</span> <span class="nav-text">第 9 章 增删改语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">10.1.</span> <span class="nav-text">1. 插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E8%A1%A8%E4%B8%AD"><span class="nav-number">10.1.1.</span> <span class="nav-text">1. 1 将数据插入表中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E5%88%B0%E8%A1%A8%E4%B8%AD"><span class="nav-number">10.1.2.</span> <span class="nav-text">1. 2 将查询结果插入到表中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">10.2.</span> <span class="nav-text">2. 更新数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">10.3.</span> <span class="nav-text">3. 删除数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-10-%E7%AB%A0-%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.</span> <span class="nav-text">第 10 章 约束</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BA%A6%E6%9D%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">11.1.</span> <span class="nav-text">1. 约束概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.1.1.</span> <span class="nav-text">1. 1 什么是约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">11.1.2.</span> <span class="nav-text">1. 2 约束的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.2.</span> <span class="nav-text">2. 非空约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.2.1.</span> <span class="nav-text">2. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.2.2.</span> <span class="nav-text">2. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%89%B9%E7%82%B9"><span class="nav-number">11.2.3.</span> <span class="nav-text">2. 3 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%B7%BB%E5%8A%A0%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.2.4.</span> <span class="nav-text">2. 4 添加非空约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%88%A0%E9%99%A4%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.2.5.</span> <span class="nav-text">2. 5 删除非空约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.3.</span> <span class="nav-text">3. 唯一性约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.3.1.</span> <span class="nav-text">3. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.3.2.</span> <span class="nav-text">3. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%89%B9%E7%82%B9"><span class="nav-number">11.3.3.</span> <span class="nav-text">3. 3 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%B7%BB%E5%8A%A0%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.3.4.</span> <span class="nav-text">3. 4 添加唯一约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%85%B3%E4%BA%8E%E5%A4%8D%E5%90%88%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.3.5.</span> <span class="nav-text">3. 5 关于复合唯一约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%88%A0%E9%99%A4%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.3.6.</span> <span class="nav-text">3. 6 删除唯一约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-PRIMARY-KEY-%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.4.</span> <span class="nav-text">4. PRIMARY KEY 主键约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.4.1.</span> <span class="nav-text">4. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.4.2.</span> <span class="nav-text">4. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%89%B9%E7%82%B9"><span class="nav-number">11.4.3.</span> <span class="nav-text">4. 3 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%B7%BB%E5%8A%A0%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.4.4.</span> <span class="nav-text">4. 4 添加主键约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%85%B3%E4%BA%8E%E5%A4%8D%E5%90%88%E4%B8%BB%E9%94%AE"><span class="nav-number">11.4.5.</span> <span class="nav-text">4. 5 关于复合主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E5%88%A0%E9%99%A4%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.4.6.</span> <span class="nav-text">4. 6 删除主键约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%87%AA%E5%A2%9E%E5%88%97%EF%BC%9AAUTO-INCREMENT"><span class="nav-number">11.5.</span> <span class="nav-text">5. 自增列：AUTO_INCREMENT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.5.1.</span> <span class="nav-text">5. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.5.2.</span> <span class="nav-text">5. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E7%89%B9%E7%82%B9%E5%92%8C%E8%A6%81%E6%B1%82"><span class="nav-number">11.5.3.</span> <span class="nav-text">5. 3 特点和要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.5.4.</span> <span class="nav-text">5. 4 如何指定自增约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%88%A0%E9%99%A4%E8%87%AA%E5%A2%9E%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.5.5.</span> <span class="nav-text">5. 5 删除自增约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-FOREIGN-KEY-%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.6.</span> <span class="nav-text">6. FOREIGN KEY 约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.6.1.</span> <span class="nav-text">6. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.6.2.</span> <span class="nav-text">6. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%B8%BB%E8%A1%A8%E5%92%8C%E4%BB%8E%E8%A1%A8-%E7%88%B6%E8%A1%A8%E5%92%8C%E5%AD%90%E8%A1%A8"><span class="nav-number">11.6.3.</span> <span class="nav-text">6. 3 主表和从表&#x2F;父表和子表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E7%89%B9%E7%82%B9"><span class="nav-number">11.6.4.</span> <span class="nav-text">6. 4 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.6.5.</span> <span class="nav-text">6. 5 添加外键约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E5%88%A0%E9%99%A4%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.6.6.</span> <span class="nav-text">6. 6 删除外键约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-DEFAULT%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.7.</span> <span class="nav-text">7. DEFAULT约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">11.7.1.</span> <span class="nav-text">7. 1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">11.7.2.</span> <span class="nav-text">7. 2 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E6%AE%B5%E5%8A%A0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">11.7.3.</span> <span class="nav-text">7. 3 如何给字段加默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%88-1-%EF%BC%89%E5%BB%BA%E8%A1%A8%E6%97%B6"><span class="nav-number">11.7.3.0.1.</span> <span class="nav-text">（ 1 ）建表时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%88-2-%EF%BC%89%E5%BB%BA%E8%A1%A8%E5%90%8E"><span class="nav-number">11.7.3.0.2.</span> <span class="nav-text">（ 2 ）建表后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%88%A0%E9%99%A4%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BA%A6%E6%9D%9F"><span class="nav-number">11.7.4.</span> <span class="nav-text">7. 4 删除默认值约束</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#-2"><span class="nav-number">11.7.4.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-11-%E7%AB%A0-%E8%A7%86%E5%9B%BE"><span class="nav-number">12.</span> <span class="nav-text">第 11 章 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.1.</span> <span class="nav-text">1. 常见的数据库对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%A7%86%E5%9B%BE%E6%A6%82%E8%BF%B0"><span class="nav-number">12.2.</span> <span class="nav-text">2. 视图概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="nav-number">12.2.1.</span> <span class="nav-text">2. 1 为什么使用视图？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%A7%86%E5%9B%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">12.2.2.</span> <span class="nav-text">2. 2 视图的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="nav-number">12.3.</span> <span class="nav-text">3. 创建视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9F%A5%E7%9C%8B%E8%A7%86%E5%9B%BE"><span class="nav-number">12.4.</span> <span class="nav-text">4. 查看视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="nav-number">12.5.</span> <span class="nav-text">5. 不可更新的视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="nav-number">12.6.</span> <span class="nav-text">6. 修改、删除视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BE"><span class="nav-number">12.6.1.</span> <span class="nav-text">6. 1 修改视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="nav-number">12.6.2.</span> <span class="nav-text">6. 2 删除视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%80%BB%E7%BB%93"><span class="nav-number">12.7.</span> <span class="nav-text">7. 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E8%A7%86%E5%9B%BE%E4%BC%98%E7%82%B9"><span class="nav-number">12.7.1.</span> <span class="nav-text">7. 1 视图优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E8%A7%86%E5%9B%BE%E4%B8%8D%E8%B6%B3"><span class="nav-number">12.7.2.</span> <span class="nav-text">7. 2 视图不足</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-12-%E7%AB%A0-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">13.</span> <span class="nav-text">第 12 章 存储过程与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">13.1.</span> <span class="nav-text">1. 存储过程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%90%86%E8%A7%A3"><span class="nav-number">13.1.1.</span> <span class="nav-text">1. 1 理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%88%86%E7%B1%BB"><span class="nav-number">13.1.2.</span> <span class="nav-text">1. 2 分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">13.2.</span> <span class="nav-text">2. 创建存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">13.2.1.</span> <span class="nav-text">2. 1 语法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">13.3.</span> <span class="nav-text">3. 调用存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">13.4.</span> <span class="nav-text">4. 存储函数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">13.4.1.</span> <span class="nav-text">4. 1 语法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-number">13.4.2.</span> <span class="nav-text">4. 2 调用存储函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%A5%E7%9C%8B%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-number">13.5.</span> <span class="nav-text">5. 存储过程和函数的查看、修改、删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%9F%A5%E7%9C%8B"><span class="nav-number">13.5.1.</span> <span class="nav-text">5. 1 查看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BF%AE%E6%94%B9"><span class="nav-number">13.5.2.</span> <span class="nav-text">5. 2 修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%88%A0%E9%99%A4"><span class="nav-number">13.5.3.</span> <span class="nav-text">5. 3 删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%85%B3%E4%BA%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BA%89%E8%AE%AE"><span class="nav-number">13.6.</span> <span class="nav-text">6. 关于存储过程使用的争议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BC%98%E7%82%B9"><span class="nav-number">13.6.1.</span> <span class="nav-text">6. 1 优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%BC%BA%E7%82%B9"><span class="nav-number">13.6.2.</span> <span class="nav-text">6. 2 缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-13-%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87"><span class="nav-number">14.</span> <span class="nav-text">第 13 章 变量、流程控制与游标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.</span> <span class="nav-text">1. 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.1.</span> <span class="nav-text">1. 1 系统变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="nav-number">14.1.1.1.</span> <span class="nav-text">1. 1. 1 系统变量分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.1.2.</span> <span class="nav-text">1. 1. 2 查看系统变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.1.3.</span> <span class="nav-text">1.1.3修改系统变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.2.</span> <span class="nav-text">1. 2 用户变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="nav-number">14.1.2.1.</span> <span class="nav-text">1. 2. 1 用户变量分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E4%BC%9A%E8%AF%9D%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.2.2.</span> <span class="nav-text">1. 2. 2 会话用户变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.2.3.</span> <span class="nav-text">1. 2. 3 局部变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">14.2.</span> <span class="nav-text">2. 流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-IF"><span class="nav-number">14.2.1.</span> <span class="nav-text">2. 1 分支结构之 IF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-CASE"><span class="nav-number">14.2.2.</span> <span class="nav-text">2. 2 分支结构之 CASE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BLOOP"><span class="nav-number">14.2.3.</span> <span class="nav-text">2. 3 循环结构之LOOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BWHILE"><span class="nav-number">14.2.4.</span> <span class="nav-text">2. 4 循环结构之WHILE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8BREPEAT"><span class="nav-number">14.2.5.</span> <span class="nav-text">2. 5 循环结构之REPEAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8BLEAVE%E8%AF%AD%E5%8F%A5"><span class="nav-number">14.2.6.</span> <span class="nav-text">2. 6 跳转语句之LEAVE语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8BITERATE%E8%AF%AD%E5%8F%A5"><span class="nav-number">14.2.7.</span> <span class="nav-text">2. 7 跳转语句之ITERATE语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B8%B8%E6%A0%87"><span class="nav-number">14.3.</span> <span class="nav-text">3. 游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87"><span class="nav-number">14.3.1.</span> <span class="nav-text">3. 1 什么是游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E6%AD%A5%E9%AA%A4"><span class="nav-number">14.3.2.</span> <span class="nav-text">3. 2 使用游标步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-14-%E7%AB%A0-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">第 14 章_触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%A7%A6%E5%8F%91%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">15.1.</span> <span class="nav-text">1. 触发器概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">15.2.</span> <span class="nav-text">2. 触发器的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">15.3.</span> <span class="nav-text">3. 查看、删除触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">15.3.1.</span> <span class="nav-text">3. 1 查看触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">15.3.2.</span> <span class="nav-text">3. 2 删除触发器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">15.4.</span> <span class="nav-text">4. 触发器的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BC%98%E7%82%B9"><span class="nav-number">15.4.1.</span> <span class="nav-text">4. 1 优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%BC%BA%E7%82%B9"><span class="nav-number">15.4.2.</span> <span class="nav-text">4. 2 缺点</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lucas Cheung"
      src="/images/Littlecheung.jpg">
  <p class="site-author-name" itemprop="name">Lucas Cheung</p>
  <div class="site-description" itemprop="description">坂道偶像宅 | 后端打工人 | 小镇青年</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LittleCheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LittleCheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/Lucas_Cheung" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;Lucas_Cheung" rel="noopener" target="_blank"><i class="fab fa-gitlab fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dongnanami@gmail.com" title="E-Mail → mailto:dongnanami@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

		
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lucas Cheung</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:25</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModePath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"pluginModelPath":"assets/"});</script></body>
</html>
